{\rtf1\ansi \deff0\deflang1033

{\fonttbl
{\f0\froman Times New Roman;}
{\f2\fswiss Arial;}
{\f19\fmodern\fcharset0\fprq1 Courier New;}
}

{\colortbl;
\red0\green0\blue0;
\red0\green0\blue255;
\red0\green255\blue255;
\red0\green255\blue0;
\red255\green0\blue255;
\red255\green0\blue0;
\red255\green255\blue0;
\red255\green255\blue255;
\red0\green0\blue127;
\red0\green127\blue127;
\red0\green127\blue0;
\red127\green0\blue127;
\red127\green0\blue0;
\red127\green127\blue0;
\red127\green127\blue127;
\red192\green192\blue192;
}


{\stylesheet
{\s243\li-1800\sl-210\tqr\tx6960 \b\f2\fs19\lang1033 header;}
{\s251\sb160\sa40\sl-280\keepn \b\f2\lang1033 heading 4;}
{\s252\sb160\sa40\sl-340\keepn \b\f2\fs30\lang1033 heading 3;}
{\s253\li-1800\sb160\sa60\sl-380\keepn \b\f0\fs34\lang1033 heading 2;}
{\s254\li-1800\sb200\sa80\sl-440\keepn \b\f0\fs40\lang1033 heading 1;}
{\*\cs10 \additive Default Paragraph Font;}
{\sa160\sl240 \fs21\lang1033 Normal;}
{\s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 Ex;}
{\s44\li-1770\ri30\sb50\sl-80\brdrt\brdrs\brdrw15\brdrcf2 \fs12\lang1033 header rule;}
{\s45\li-1800\sa180\sl-440\keepn\tx0 \b\f2\fs40\up8\lang1033 Rh1;}
{\s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 Rmh;}
{\s50\sl-240\keepn \f0\fs21\lang1033 Term1;}
{\s53\li280\sl-240\keepn \f0\fs21\lang1033 Term2;}
{\s54\li280\sa80\sl-240 \f0\fs21\lang1033 Def1;}
{\s55\li560\sa80\sl-240 \f0\fs21\lang1033 Def2;}
{\s57\li-1770\ri30\sb280\sa250\sl-120\keepn\brdrb\brdrs\brdrw15\brdrcf2 \fs8\cf8\lang1033 Rule;}
{\s93\sl240 \fs21\lang1033 
Index Link;}
{\s25\sa80\widctlpar\intbl \f4\fs21\lang1024 \sbasedon0\snext25 Table Text;}
}

\paperw12240\paperh15840\margl3330\margr1530\margt-2540\margb-2220\gutter420 
\facingp\deftab280\widowctrl\ftnbj 

\sectd \binfsxn1\binsxn1\linex0\headery1990\footery360\endnhere\titlepg 

{\headerl \pard\plain \s243\li-1800\sl-210\tqr\tx6960 \b\f2\fs19\lang1033 
{\field\flddirty{\*\fldinst PAGE}{\fldrslt 4}}{\expnd50  }Autodoc Output - 03/24/99\par 
\pard\plain \s44\li-1770\ri30\sb50\sl-80\brdrt\brdrs\brdrw15\brdrcf2 \fs12\lang1033 \par }

{\headerr \pard\plain \s243\li-1800\sl-210\tqr\tx6960 \b\f2\fs19\lang1033 
\tab Autodoc Output - 03/24/99{\expnd50   }
{\field\flddirty{\*\fldinst PAGE}{\fldrslt 3}}
\par \pard\plain \s44\li-1770\ri30\sb50\sl-80\brdrt\brdrs\brdrw15\brdrcf2 \fs12\lang1033 
\par }
\pard\plain \s57\li-1770\ri30\sb280\sa250\sl-120\keepn\brdrb\brdrs\brdrw15\brdrcf2 \fs8\cf8\lang1033 \par 
\pard\plain \s254\li-1800\sb200\sa80\sl-440\keepn \b\f0\fs40\lang1033 Module HidGame\par 
\pard\plain \sa160\sl240 \fs21\lang1033 Filename: C:/NTDDK/SRC/WDM/HID/HIDGAME/HIDGAME.H\par 
\pard\plain \s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 Description\par 
\pard\plain \sa160\sl240 \fs21\lang1033 Analog WDM/HID Joystick driver.\par 

HidGame is the HID minidriver for analog joysticks. 
This driver registers with the HID class driver and 
responds to IRPs put out by HIDclass. It informs HIDClass 
about the capabilities of the joystick and polls the joystick 
in response to a read IOCTL.\par 

This driver is loaded in reponse to a "New hardware Found" 
PnP event, and consequently must have an entry in an inf file 
that binds a PnP hardware ID to this driver.\par 

Gameport joysticks are not true PnP devices, so the user has to 
inform the system about the joystick that was added to the 
gameport by using the Game Controllers CPL "Add" a joystick. 
An example of how a new joystick type can be created is provided 
in the accompanying inf file.\par 

Once a user selects a joystick and gameport, the GameCPL passes 
this information to DirectInput which sends an IOCTL to the 
gameport bus driver (GameEnum), specifying the number of axes, 
buttons and a PnPHardware ID for the joystick. The Gameport Bus 
informs PnP of a new device arrival. PnP searches the system for 
a match for the hardwareID and loads the appropriate driver.\par 

 
The following files are part of this driver.\par 

\line HidGame.c 
\line DriverEntry, CreateClose, AddDevice and Unload Routines. 
This code performs functions required for any device driver 
and so can probably be used without changes for any game 
other game device.\par 

\line PnP.c 
\line Support routines for PnP IOCTLs.\par 

\line Ioctl.c 
\line Support routines for Non PnP IOCTLs 
These deal with all the HID IOCTLs required for an ordinary 
game device and so could be used without change as there is 
no analog specific funtionality in these routines. 
Drivers for some devices may need to add code to support more 
complex devices.\par 

\line HidJoy.c 
\line Support routines to translate legacy joystick flags and 
data into HID descriptors.  The majority of this code is 
needed to support the wide variety of analog joysticks 
available so is not relevant to drivers written for specific 
devices.\par 

\line Poll.c 
\line Support routines to read analog joystick data from a 
gameport.  These functions are likely to be of little use 
in a digital joystick driver.\par 

\line i386\\timing.c 
\line Support routines to use x86 Time Stamp Counter. 
Includes code to check for the presence of, calibrate and 
read the high speed CPU timer.\par 

\line Hidgame.h 
\line Common include file. 
The general definitions are likely to be of use in most 
drivers for game devices but some customization will be needed.\par 

\line Debug.h 
\line Definitions to aid debugging. 
This contains the tag for the driver name used in debug output 
which must be changed.\par 

\line Analog.h 
\line Specific include file. 
Definitions specific to analog joystick devices.\par 

\line OemSetup.inf 
\line Sample inf file. 
See comments in this file for how to install devices.\par 

\line Source 
\line  Source file for the NT build utility\par 

\line Makefile 
\line  Used as part of the build process\par 
\pard\plain \s57\li-1770\ri30\sb280\sa250\sl-120\keepn\brdrb\brdrs\brdrw15\brdrcf2 \fs8\cf8\lang1033 \par 
\pard\plain \s254\li-1800\sb200\sa80\sl-440\keepn \b\f0\fs40\lang1033 DriverEntry\par 
\pard \plain \sa160\sl240 \fs21\lang1033 {\b NTSTATUS} {\b DriverEntry(}{\b IN PDRIVER_OBJECT} {\i DeviceObject}{\b , IN PUNICODE_STRINT} {\i RegistryPath}{\b ) }\par
\pard\plain \sa160\sl240 \fs21\lang1033 Installable driver initialization entry point. 
\line This entry point is called directly by the I/O system.\par 
\pard\plain \sa160\sl240 \fs21\lang1033 Defined in: c:/ntddk/src/wdm/hid/hidgame/hidgame.c\par 
\pard\plain \s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 Parameters\par \pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\i DeviceObject}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Pointer to the driver object\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\i RegistryPath}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Pointer to a unicode string representing the path, 
to driver-specific key in the registry.\par 
\pard\plain \s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 Return Codes\par
\trowd \trgaph72\trleft-72 \cellx3078\cellx7038 \pard\plain \intbl\s25\sa80\widctlpar\intbl \f4\fs21\lang1024 \sbasedon0\snext25 {\fs18 STATUS_SUCCESS\cell success\cell }\pard \intbl \row \pard\plain \intbl\s25\sa80\widctlpar\intbl \f4\fs21\lang1024 \sbasedon0\snext25 {\fs18 ???\cell returned HidRegisterMinidriver()\cell }\pard \intbl \row \pard\plain \li240\sa0\sl240 \f2\fs20\lang1033 \par 
\pard\plain \s57\li-1770\ri30\sb280\sa250\sl-120\keepn\brdrb\brdrs\brdrw15\brdrcf2 \fs8\cf8\lang1033 \par 
\pard\plain \s254\li-1800\sb200\sa80\sl-440\keepn \b\f0\fs40\lang1033 HGM_AddDevice\par 
\pard \plain \sa160\sl240 \fs21\lang1033 {\b NTSTATUS} {\b HGM_AddDevice(}{\b IN PDRIVER_OBJECT} {\i DeviceObject}{\b , IN PDEVICE_OBJECT} {\i FunctionalDeviceObject}{\b ) }\par
\pard\plain \sa160\sl240 \fs21\lang1033 Called by hidclass, allows us to initialize our device extensions.\par 
\pard\plain \sa160\sl240 \fs21\lang1033 Defined in: c:/ntddk/src/wdm/hid/hidgame/hidgame.c\par 
\pard\plain \s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 Parameters\par \pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\i DeviceObject}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Pointer to the driver object\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\i FunctionalDeviceObject}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Pointer to a functional device object created by hidclass.\par 
\pard\plain \s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 Return Codes\par
\trowd \trgaph72\trleft-72 \cellx3078\cellx7038 \pard\plain \intbl\s25\sa80\widctlpar\intbl \f4\fs21\lang1024 \sbasedon0\snext25 {\fs18 STATUS_SUCCESS\cell success\cell }\pard \intbl \row \pard\plain \li240\sa0\sl240 \f2\fs20\lang1033 \par 
\pard\plain \s57\li-1770\ri30\sb280\sa250\sl-120\keepn\brdrb\brdrs\brdrw15\brdrcf2 \fs8\cf8\lang1033 \par 
\pard\plain \s254\li-1800\sb200\sa80\sl-440\keepn \b\f0\fs40\lang1033 HGM_ChangeHandler\par 
\pard \plain \sa160\sl240 \fs21\lang1033 {\b VOID} {\b HGM_ChangeHandler(}{\b IN  OUT PDEVICE_EXTENSION} {\i DeviceExtension}{\b ) }\par
\pard\plain \sa160\sl240 \fs21\lang1033 Use IOCTL_GAMEENUM_EXPOSE_SIBLING and IOCTL_GAMEENUM_REMOVE_SELF 
to change the attributes of the device.\par 
\pard\plain \sa160\sl240 \fs21\lang1033 Defined in: c:/ntddk/src/wdm/hid/hidgame/hidjoy.c\par 
\pard\plain \s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 Parameters\par \pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\i DeviceExtension}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Pointer to the mini-driver device extension.\par 
\pard\plain \s57\li-1770\ri30\sb280\sa250\sl-120\keepn\brdrb\brdrs\brdrw15\brdrcf2 \fs8\cf8\lang1033 \par 
\pard\plain \s254\li-1800\sb200\sa80\sl-440\keepn \b\f0\fs40\lang1033 HGM_CreateClose\par 
\pard \plain \sa160\sl240 \fs21\lang1033 {\b NTSTATUS} {\b HGM_CreateClose(}{\b IN PDRIVER_OBJECT} {\i DeviceObject}{\b , IN PIRP} {\i Irp}{\b ) }\par
\pard\plain \sa160\sl240 \fs21\lang1033 Process the create and close IRPs sent to this device.\par 
\pard\plain \sa160\sl240 \fs21\lang1033 Defined in: c:/ntddk/src/wdm/hid/hidgame/hidgame.c\par 
\pard\plain \s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 Parameters\par \pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\i DeviceObject}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Pointer to the driver object\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\i Irp}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Pointer to an I/O Request Packet.\par 
\pard\plain \s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 Return Codes\par
\trowd \trgaph72\trleft-72 \cellx3078\cellx7038 \pard\plain \intbl\s25\sa80\widctlpar\intbl \f4\fs21\lang1024 \sbasedon0\snext25 {\fs18 STATUS_SUCCESS\cell success\cell }\pard \intbl \row \pard\plain \intbl\s25\sa80\widctlpar\intbl \f4\fs21\lang1024 \sbasedon0\snext25 {\fs18 STATUS_INVALID_PARAMETER\cell Irp not handled\cell }\pard \intbl \row \pard\plain \li240\sa0\sl240 \f2\fs20\lang1033 \par 
\pard\plain \s57\li-1770\ri30\sb280\sa250\sl-120\keepn\brdrb\brdrs\brdrw15\brdrcf2 \fs8\cf8\lang1033 \par 
\pard\plain \s254\li-1800\sb200\sa80\sl-440\keepn \b\f0\fs40\lang1033 HGM_DeviceChanged\par 
\pard \plain \sa160\sl240 \fs21\lang1033 {\b VOID} {\b HGM_DeviceChanged(}{\b IN  OUT PDEVICE_EXTENSION} {\i DeviceExtension}{\b ) }\par
\pard\plain \sa160\sl240 \fs21\lang1033 Start the process of changing the device attributes by stashing 
away all the data needed and then initializing and queuing a work 
item to call the IOCTL at the required PASSIVE_LEVEL.\par 
\pard\plain \sa160\sl240 \fs21\lang1033 Defined in: c:/ntddk/src/wdm/hid/hidgame/hidjoy.c\par 
\pard\plain \s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 Parameters\par \pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\i DeviceExtension}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Pointer to the mini-driver device extension.\par 
\pard\plain \s57\li-1770\ri30\sb280\sa250\sl-120\keepn\brdrb\brdrs\brdrw15\brdrcf2 \fs8\cf8\lang1033 \par 
\pard\plain \s254\li-1800\sb200\sa80\sl-440\keepn \b\f0\fs40\lang1033 HGM_DriverInit\par 
\pard \plain \sa160\sl240 \fs21\lang1033 {\b VOID} {\b HGM_DriverInit(void}{\b ) }\par
\pard\plain \sa160\sl240 \fs21\lang1033 Perform global initialization. 
\line This is called from DriverEntry.  Try to initialize a CPU specific 
timer but if it fails set up default\par 
\pard\plain \sa160\sl240 \fs21\lang1033 Defined in: c:/ntddk/src/wdm/hid/hidgame/hidjoy.c\par 
\pard\plain \s57\li-1770\ri30\sb280\sa250\sl-120\keepn\brdrb\brdrs\brdrw15\brdrcf2 \fs8\cf8\lang1033 \par 
\pard\plain \s254\li-1800\sb200\sa80\sl-440\keepn \b\f0\fs40\lang1033 HGM_Game2HID\par 
\pard \plain \sa160\sl240 \fs21\lang1033 {\b VOID} {\b HGM_Game2HID(}{\b IN      PDEVICE_EXTENSION} {\i DeviceExtension}{\b , IN  OUT PUHIDGAME_INPUT_DATA} {\i pHIDData}{\b ) }\par
\pard\plain \sa160\sl240 \fs21\lang1033 Process the data returned from polling the gameport into values 
and buttons for returning to HID. 
\line The meaning of the data is interpreted according to the 
characteristics of the device described in the hardware settings 
flags.\par 
\pard\plain \sa160\sl240 \fs21\lang1033 Defined in: c:/ntddk/src/wdm/hid/hidgame/hidjoy.c\par 
\pard\plain \s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 Parameters\par \pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\i DeviceExtension}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Pointer to the mini-driver device extension.\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\i pHIDData}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Pointer to the buffer into which the HID report should be written. 
This buffer must be assumed to be unaligned.\par 
\pard\plain \s57\li-1770\ri30\sb280\sa250\sl-120\keepn\brdrb\brdrs\brdrw15\brdrcf2 \fs8\cf8\lang1033 \par 
\pard\plain \s254\li-1800\sb200\sa80\sl-440\keepn \b\f0\fs40\lang1033 HGM_GenerateReport\par 
\pard \plain \sa160\sl240 \fs21\lang1033 {\b NTSTATUS} {\b HGM_GenerateReport(}{\b IN PDEVICE_OBJECT} {\i DeviceObject}{\b , IN OUT UCHAR *} {\i rgGameReport[MAXBYTES_GAME_REPORT]}{\b , OUT PUSHORT} {\i pCbReport}{\b ) }\par
\pard\plain \sa160\sl240 \fs21\lang1033 Generates a hid report descriptor for a n-axis, m-button joystick, 
depending on number of buttons and joy_hws_flags field.\par 
\pard\plain \sa160\sl240 \fs21\lang1033 Defined in: c:/ntddk/src/wdm/hid/hidgame/hidjoy.c\par 
\pard\plain \s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 Parameters\par \pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\i DeviceObject}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Pointer to the device object\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\i rgGameReport[MAXBYTES_GAME_REPORT]}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Array that receives the HID report descriptor\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\i pCbReport}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Address of a short integer that receives size of 
HID report descriptor.\par 
\pard\plain \s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 Return Codes\par
\trowd \trgaph72\trleft-72 \cellx3078\cellx7038 \pard\plain \intbl\s25\sa80\widctlpar\intbl \f4\fs21\lang1024 \sbasedon0\snext25 {\fs18 STATUS_SUCCESS\cell success\cell }\pard \intbl \row \pard\plain \intbl\s25\sa80\widctlpar\intbl \f4\fs21\lang1024 \sbasedon0\snext25 {\fs18 STATUS_BUFFER_TOO_SMALL\cell Need more memory for HID descriptor\cell }\pard \intbl \row \pard\plain \li240\sa0\sl240 \f2\fs20\lang1033 \par 
\pard\plain \s57\li-1770\ri30\sb280\sa250\sl-120\keepn\brdrb\brdrs\brdrw15\brdrcf2 \fs8\cf8\lang1033 \par 
\pard\plain \s254\li-1800\sb200\sa80\sl-440\keepn \b\f0\fs40\lang1033 HGM_GetAttributes\par 
\pard \plain \sa160\sl240 \fs21\lang1033 {\b NTSTATUS} {\b HGM_GetAttributes(}{\b IN PDRIVER_OBJECT} {\i DeviceObject}{\b , IN PIRP} {\i Irp}{\b ) }\par
\pard\plain \sa160\sl240 \fs21\lang1033 Respond to IOCTL_HID_GET_ATTRIBUTES, by filling 
the HID_DEVICE_ATTRIBUTES struct\par 
\pard\plain \sa160\sl240 \fs21\lang1033 Defined in: c:/ntddk/src/wdm/hid/hidgame/ioctl.c\par 
\pard\plain \s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 Parameters\par \pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\i DeviceObject}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Pointer to the driver object\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\i Irp}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Pointer to an I/O Request Packet.\par 
\pard\plain \s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 Return Codes\par
\trowd \trgaph72\trleft-72 \cellx3078\cellx7038 \pard\plain \intbl\s25\sa80\widctlpar\intbl \f4\fs21\lang1024 \sbasedon0\snext25 {\fs18 STATUS_SUCCESS\cell success\cell }\pard \intbl \row \pard\plain \intbl\s25\sa80\widctlpar\intbl \f4\fs21\lang1024 \sbasedon0\snext25 {\fs18 ???\cell ???\cell }\pard \intbl \row \pard\plain \li240\sa0\sl240 \f2\fs20\lang1033 \par 
\pard\plain \s57\li-1770\ri30\sb280\sa250\sl-120\keepn\brdrb\brdrs\brdrw15\brdrcf2 \fs8\cf8\lang1033 \par 
\pard\plain \s254\li-1800\sb200\sa80\sl-440\keepn \b\f0\fs40\lang1033 HGM_GetDeviceDescriptor\par 
\pard \plain \sa160\sl240 \fs21\lang1033 {\b NTSTATUS} {\b HGM_GetDeviceDescriptor(}{\b IN PDRIVER_OBJECT} {\i DeviceObject}{\b , IN PIRP} {\i Irp}{\b ) }\par
\pard\plain \sa160\sl240 \fs21\lang1033 Respond to HIDCLASS IOCTL_HID_GET_DEVICE_DESCRIPTOR 
by returning a device descriptor\par 
\pard\plain \sa160\sl240 \fs21\lang1033 Defined in: c:/ntddk/src/wdm/hid/hidgame/ioctl.c\par 
\pard\plain \s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 Parameters\par \pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\i DeviceObject}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Pointer to the driver object\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\i Irp}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Pointer to an I/O Request Packet.\par 
\pard\plain \s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 Return Codes\par
\trowd \trgaph72\trleft-72 \cellx3078\cellx7038 \pard\plain \intbl\s25\sa80\widctlpar\intbl \f4\fs21\lang1024 \sbasedon0\snext25 {\fs18 STATUS_SUCCESS\cell success\cell }\pard \intbl \row \pard\plain \intbl\s25\sa80\widctlpar\intbl \f4\fs21\lang1024 \sbasedon0\snext25 {\fs18 STATUS_BUFFER_TOO_SMALL\cell need more memory\cell }\pard \intbl \row \pard\plain \li240\sa0\sl240 \f2\fs20\lang1033 \par 
\pard\plain \s57\li-1770\ri30\sb280\sa250\sl-120\keepn\brdrb\brdrs\brdrw15\brdrcf2 \fs8\cf8\lang1033 \par 
\pard\plain \s254\li-1800\sb200\sa80\sl-440\keepn \b\f0\fs40\lang1033 HGM_GetReportDescriptor\par 
\pard \plain \sa160\sl240 \fs21\lang1033 {\b NTSTATUS} {\b HGM_GetReportDescriptor(}{\b IN PDRIVER_OBJECT} {\i DeviceObject}{\b , IN PIRP} {\i Irp}{\b ) }\par
\pard\plain \sa160\sl240 \fs21\lang1033 Respond to HIDCLASS IOCTL_HID_GET_REPORT_DESCRIPTOR 
by returning appropriate the report descriptor\par 
\pard\plain \sa160\sl240 \fs21\lang1033 Defined in: c:/ntddk/src/wdm/hid/hidgame/ioctl.c\par 
\pard\plain \s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 Parameters\par \pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\i DeviceObject}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Pointer to the driver object\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\i Irp}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Pointer to an I/O Request Packet.\par 
\pard\plain \s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 Return Codes\par
\trowd \trgaph72\trleft-72 \cellx3078\cellx7038 \pard\plain \intbl\s25\sa80\widctlpar\intbl \f4\fs21\lang1024 \sbasedon0\snext25 {\fs18 STATUS_SUCCESS\cell success\cell }\pard \intbl \row \pard\plain \intbl\s25\sa80\widctlpar\intbl \f4\fs21\lang1024 \sbasedon0\snext25 {\fs18 ???\cell ???\cell }\pard \intbl \row \pard\plain \li240\sa0\sl240 \f2\fs20\lang1033 \par 
\pard\plain \s57\li-1770\ri30\sb280\sa250\sl-120\keepn\brdrb\brdrs\brdrw15\brdrcf2 \fs8\cf8\lang1033 \par 
\pard\plain \s254\li-1800\sb200\sa80\sl-440\keepn \b\f0\fs40\lang1033 HGM_GetResources\par 
\pard \plain \sa160\sl240 \fs21\lang1033 {\b NTSTATUS} {\b HGM_GetResources(}{\b IN PDEVICE_OBJECT} {\i DeviceObject}{\b , IN PIRP} {\i Irp}{\b ) }\par
\pard\plain \sa160\sl240 \fs21\lang1033 Gets gameport resource information from the GameEnum driver\par 
\pard\plain \sa160\sl240 \fs21\lang1033 Defined in: c:/ntddk/src/wdm/hid/hidgame/pnp.c\par 
\pard\plain \s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 Parameters\par \pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\i DeviceObject}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Pointer to the device object.\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\i Irp}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Pointer to an I/O request packet.\par 
\pard\plain \s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 Return Codes\par
\trowd \trgaph72\trleft-72 \cellx3078\cellx7038 \pard\plain \intbl\s25\sa80\widctlpar\intbl \f4\fs21\lang1024 \sbasedon0\snext25 {\fs18 STATUS_SUCCESS\cell success\cell }\pard \intbl \row \pard\plain \intbl\s25\sa80\widctlpar\intbl \f4\fs21\lang1024 \sbasedon0\snext25 {\fs18 ???\cell Return from IoCallDriver()\cell }\pard \intbl \row \pard\plain \li240\sa0\sl240 \f2\fs20\lang1033 \par 
\pard\plain \s57\li-1770\ri30\sb280\sa250\sl-120\keepn\brdrb\brdrs\brdrw15\brdrcf2 \fs8\cf8\lang1033 \par 
\pard\plain \s254\li-1800\sb200\sa80\sl-440\keepn \b\f0\fs40\lang1033 HGM_InitAnalog\par 
\pard \plain \sa160\sl240 \fs21\lang1033 {\b NTSTATUS} {\b HGM_InitAnalog(}{\b IN PDEVICE_OBJECT} {\i DeviceObject}{\b ) }\par
\pard\plain \sa160\sl240 \fs21\lang1033 Check that the configuration is valid whilst there is still time 
to refuse it. 
\line Detect and validate sibling relationships and call 
HGM_JoystickConfig for the rest of the work.\par 
\pard\plain \sa160\sl240 \fs21\lang1033 Defined in: c:/ntddk/src/wdm/hid/hidgame/hidjoy.c\par 
\pard\plain \s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 Parameters\par \pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\i DeviceObject}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Pointer to the device object\par 
\pard\plain \s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 Return Codes\par
\trowd \trgaph72\trleft-72 \cellx3078\cellx7038 \pard\plain \intbl\s25\sa80\widctlpar\intbl \f4\fs21\lang1024 \sbasedon0\snext25 {\fs18 STATUS_SUCCESS\cell success\cell }\pard \intbl \row \pard\plain \intbl\s25\sa80\widctlpar\intbl \f4\fs21\lang1024 \sbasedon0\snext25 {\fs18 STATUS_DEVICE_CONFIGURATION_ERROR\cell Invalid configuration specified\cell }\pard \intbl \row \pard\plain \li240\sa0\sl240 \f2\fs20\lang1033 \par 
\pard\plain \s57\li-1770\ri30\sb280\sa250\sl-120\keepn\brdrb\brdrs\brdrw15\brdrcf2 \fs8\cf8\lang1033 \par 
\pard\plain \s254\li-1800\sb200\sa80\sl-440\keepn \b\f0\fs40\lang1033 HGM_InitDevice\par 
\pard \plain \sa160\sl240 \fs21\lang1033 {\b NTSTATUS} {\b HGM_InitDevice(}{\b IN PDEVICE_OBJECT} {\i DeviceObject}{\b , IN PIRP} {\i Irp}{\b ) }\par
\pard\plain \sa160\sl240 \fs21\lang1033 Get the device information and attempt to initialize a configuration 
for a device.  If we cannot identify this as a valid HID device or 
configure the device, our start device function is failed.\par 
\pard\plain \sa160\sl240 \fs21\lang1033 Defined in: c:/ntddk/src/wdm/hid/hidgame/pnp.c\par 
\pard\plain \s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 Parameters\par \pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\i DeviceObject}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Pointer to the device object.\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\i Irp}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Pointer to an I/O request packet.\par 
\pard\plain \s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 Return Codes\par
\trowd \trgaph72\trleft-72 \cellx3078\cellx7038 \pard\plain \intbl\s25\sa80\widctlpar\intbl \f4\fs21\lang1024 \sbasedon0\snext25 {\fs18 STATUS_SUCCESS\cell success\cell }\pard \intbl \row \pard\plain \intbl\s25\sa80\widctlpar\intbl \f4\fs21\lang1024 \sbasedon0\snext25 {\fs18 STATUS_DEVICE_CONFIGURATION_ERROR\cell Resources overlap\cell }\pard \intbl \row \pard\plain \intbl\s25\sa80\widctlpar\intbl \f4\fs21\lang1024 \sbasedon0\snext25 {\fs18 ???\cell Return from HGM_GetResources() or HGM_JoystickConfig()\cell }\pard \intbl \row \pard\plain \li240\sa0\sl240 \f2\fs20\lang1033 \par 
\pard\plain \s57\li-1770\ri30\sb280\sa250\sl-120\keepn\brdrb\brdrs\brdrw15\brdrcf2 \fs8\cf8\lang1033 \par 
\pard\plain \s254\li-1800\sb200\sa80\sl-440\keepn \b\f0\fs40\lang1033 HGM_InternalIoctl\par 
\pard \plain \sa160\sl240 \fs21\lang1033 {\b NTSTATUS} {\b HGM_InternalIoctl(}{\b IN PDRIVER_OBJECT} {\i DeviceObject}{\b , IN PIRP} {\i Irp}{\b ) }\par
\pard\plain \sa160\sl240 \fs21\lang1033 Process the Control IRPs sent to this device. 
\line This function cannot be pageable because reads/writes 
can be made at dispatch-level\par 
\pard\plain \sa160\sl240 \fs21\lang1033 Defined in: c:/ntddk/src/wdm/hid/hidgame/ioctl.c\par 
\pard\plain \s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 Parameters\par \pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\i DeviceObject}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Pointer to the driver object\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\i Irp}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Pointer to an I/O Request Packet.\par 
\pard\plain \s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 Return Codes\par
\trowd \trgaph72\trleft-72 \cellx3078\cellx7038 \pard\plain \intbl\s25\sa80\widctlpar\intbl \f4\fs21\lang1024 \sbasedon0\snext25 {\fs18 STATUS_SUCCESS\cell success\cell }\pard \intbl \row \pard\plain \intbl\s25\sa80\widctlpar\intbl \f4\fs21\lang1024 \sbasedon0\snext25 {\fs18 STATUS_NOT_SUPPORT\cell Irp function not supported\cell }\pard \intbl \row \pard\plain \intbl\s25\sa80\widctlpar\intbl \f4\fs21\lang1024 \sbasedon0\snext25 {\fs18 ???\cell ???\cell }\pard \intbl \row \pard\plain \li240\sa0\sl240 \f2\fs20\lang1033 \par 
\pard\plain \s57\li-1770\ri30\sb280\sa250\sl-120\keepn\brdrb\brdrs\brdrw15\brdrcf2 \fs8\cf8\lang1033 \par 
\pard\plain \s254\li-1800\sb200\sa80\sl-440\keepn \b\f0\fs40\lang1033 HGM_JoystickConfig\par 
\pard \plain \sa160\sl240 \fs21\lang1033 {\b NTSTATUS} {\b HGM_JoystickConfig(}{\b IN PDEVICE_OBJECT} {\i DeviceObject}{\b ) }\par
\pard\plain \sa160\sl240 \fs21\lang1033 Check that the configuration is valid whilst there is still time 
to refuse it. 
\line HGM_GenerateReport uses the results generated here if the 
settings are OK.\par 
\pard\plain \sa160\sl240 \fs21\lang1033 Defined in: c:/ntddk/src/wdm/hid/hidgame/hidjoy.c\par 
\pard\plain \s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 Parameters\par \pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\i DeviceObject}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Pointer to the device object\par 
\pard\plain \s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 Return Codes\par
\trowd \trgaph72\trleft-72 \cellx3078\cellx7038 \pard\plain \intbl\s25\sa80\widctlpar\intbl \f4\fs21\lang1024 \sbasedon0\snext25 {\fs18 STATUS_SUCCESS\cell success\cell }\pard \intbl \row \pard\plain \intbl\s25\sa80\widctlpar\intbl \f4\fs21\lang1024 \sbasedon0\snext25 {\fs18 STATUS_DEVICE_CONFIGURATION_ERROR\cell Invalid configuration specified\cell }\pard \intbl \row \pard\plain \li240\sa0\sl240 \f2\fs20\lang1033 \par 
\pard\plain \s57\li-1770\ri30\sb280\sa250\sl-120\keepn\brdrb\brdrs\brdrw15\brdrcf2 \fs8\cf8\lang1033 \par 
\pard\plain \s254\li-1800\sb200\sa80\sl-440\keepn \b\f0\fs40\lang1033 HGM_MapAxesFromDevExt\par 
\pard \plain \sa160\sl240 \fs21\lang1033 {\b NTSTATUS} {\b HGM_MapAxesFromDevExt(}{\b IN OUT PDEVICE_EXTENSION} {\i DeviceExtension}{\b ) }\par
\pard\plain \sa160\sl240 \fs21\lang1033 Use the flags in the DeviceExtension to generate mappings for each 
axis. 
\line This is called both from HGM_JoystickConfig to validate the 
configuration and HGM_GenerateReport to use the axis maps.\par 
\pard\plain \sa160\sl240 \fs21\lang1033 Defined in: c:/ntddk/src/wdm/hid/hidgame/hidjoy.c\par 
\pard\plain \s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 Parameters\par \pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\i DeviceExtension}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Pointer to the minidriver device extension\par 
\pard\plain \s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 Return Codes\par
\trowd \trgaph72\trleft-72 \cellx3078\cellx7038 \pard\plain \intbl\s25\sa80\widctlpar\intbl \f4\fs21\lang1024 \sbasedon0\snext25 {\fs18 STATUS_SUCCESS\cell success\cell }\pard \intbl \row \pard\plain \intbl\s25\sa80\widctlpar\intbl \f4\fs21\lang1024 \sbasedon0\snext25 {\fs18 STATUS_DEVICE_CONFIGURATION_ERROR\cell The configuration is invalid\cell }\pard \intbl \row \pard\plain \li240\sa0\sl240 \f2\fs20\lang1033 \par 
\pard\plain \s57\li-1770\ri30\sb280\sa250\sl-120\keepn\brdrb\brdrs\brdrw15\brdrcf2 \fs8\cf8\lang1033 \par 
\pard\plain \s254\li-1800\sb200\sa80\sl-440\keepn \b\f0\fs40\lang1033 HGM_PnP\par 
\pard \plain \sa160\sl240 \fs21\lang1033 {\b NTSTATUS} {\b HGM_PnP(}{\b IN PDEVICE_OBJECT} {\i DeviceObject}{\b , IN PIRP} {\i Irp}{\b ) }\par
\pard\plain \sa160\sl240 \fs21\lang1033 Plug and Play dispatch routine for this driver.\par 
\pard\plain \sa160\sl240 \fs21\lang1033 Defined in: c:/ntddk/src/wdm/hid/hidgame/pnp.c\par 
\pard\plain \s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 Parameters\par \pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\i DeviceObject}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Pointer to the device object.\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\i Irp}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Pointer to an I/O request packet.\par 
\pard\plain \s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 Return Codes\par
\trowd \trgaph72\trleft-72 \cellx3078\cellx7038 \pard\plain \intbl\s25\sa80\widctlpar\intbl \f4\fs21\lang1024 \sbasedon0\snext25 {\fs18 STATUS_SUCCESS\cell success\cell }\pard \intbl \row \pard\plain \intbl\s25\sa80\widctlpar\intbl \f4\fs21\lang1024 \sbasedon0\snext25 {\fs18 STATUS_DELETE_PENDING\cell PnP IRP received after device was removed\cell }\pard \intbl \row \pard\plain \intbl\s25\sa80\widctlpar\intbl \f4\fs21\lang1024 \sbasedon0\snext25 {\fs18 ???\cell Return from IoCallDriver() or HGM_InitDevice()\cell }\pard \intbl \row \pard\plain \li240\sa0\sl240 \f2\fs20\lang1033 \par 
\pard\plain \s57\li-1770\ri30\sb280\sa250\sl-120\keepn\brdrb\brdrs\brdrw15\brdrcf2 \fs8\cf8\lang1033 \par 
\pard\plain \s254\li-1800\sb200\sa80\sl-440\keepn \b\f0\fs40\lang1033 HGM_PnPComplete\par 
\pard \plain \sa160\sl240 \fs21\lang1033 {\b NTSTATUS} {\b HGM_PnPComplete(}{\b IN PDEVICE_OBJECT} {\i DeviceObject}{\b , IN PIRP} {\i Irp}{\b ) }\par
\pard\plain \sa160\sl240 \fs21\lang1033 Completion routine for PnP IRPs.\par 
\pard\plain \sa160\sl240 \fs21\lang1033 Defined in: c:/ntddk/src/wdm/hid/hidgame/pnp.c\par 
\pard\plain \s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 Parameters\par \pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\i DeviceObject}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Pointer to the device object.\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\i Irp}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Pointer to an I/O request packet.\par 
\pard\plain \s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 Return Codes\par
\trowd \trgaph72\trleft-72 \cellx3078\cellx7038 \pard\plain \intbl\s25\sa80\widctlpar\intbl \f4\fs21\lang1024 \sbasedon0\snext25 {\fs18 STATUS_MORE_PROCESSING_REQUIRED\cell We want the IRP back\cell }\pard \intbl \row \pard\plain \li240\sa0\sl240 \f2\fs20\lang1033 \par 
\pard\plain \s57\li-1770\ri30\sb280\sa250\sl-120\keepn\brdrb\brdrs\brdrw15\brdrcf2 \fs8\cf8\lang1033 \par 
\pard\plain \s254\li-1800\sb200\sa80\sl-440\keepn \b\f0\fs40\lang1033 HGM_Power\par 
\pard \plain \sa160\sl240 \fs21\lang1033 {\b NTSTATUS} {\b HGM_Power(}{\b IN PDEVICE_OBJECT} {\i DeviceObject}{\b , IN PIRP} {\i Irp}{\b ) }\par
\pard\plain \sa160\sl240 \fs21\lang1033 The power dispatch routine. 
\line This driver does not recognize power IRPS.  It merely sends them down, 
unmodified to the next device on the attachment stack. 
As this is a POWER irp, and therefore a special irp, special power irp 
handling is required. No completion routine is required.\par 
\pard\plain \sa160\sl240 \fs21\lang1033 Defined in: c:/ntddk/src/wdm/hid/hidgame/pnp.c\par 
\pard\plain \s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 Parameters\par \pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\i DeviceObject}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Pointer to the device object.\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\i Irp}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Pointer to an I/O request packet.\par 
\pard\plain \s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 Return Codes\par
\trowd \trgaph72\trleft-72 \cellx3078\cellx7038 \pard\plain \intbl\s25\sa80\widctlpar\intbl \f4\fs21\lang1024 \sbasedon0\snext25 {\fs18 STATUS_SUCCESS\cell success\cell }\pard \intbl \row \pard\plain \intbl\s25\sa80\widctlpar\intbl \f4\fs21\lang1024 \sbasedon0\snext25 {\fs18 ???\cell Return from PoCallDriver()\cell }\pard \intbl \row \pard\plain \li240\sa0\sl240 \f2\fs20\lang1033 \par 
\pard\plain \s57\li-1770\ri30\sb280\sa250\sl-120\keepn\brdrb\brdrs\brdrw15\brdrcf2 \fs8\cf8\lang1033 \par 
\pard\plain \s254\li-1800\sb200\sa80\sl-440\keepn \b\f0\fs40\lang1033 HGM_ReadReport\par 
\pard \plain \sa160\sl240 \fs21\lang1033 {\b NTSTATUS} {\b HGM_ReadReport(}{\b IN PDRIVER_OBJECT} {\i DeviceObject}{\b , IN PIRP} {\i Irp}{\b ) }\par
\pard\plain \sa160\sl240 \fs21\lang1033 Poll the gameport, remap the axis and button data and package 
into the defined HID report field. 
\line This routine cannot be pageable as HID can make reads at 
dispatch-level.\par 
\pard\plain \sa160\sl240 \fs21\lang1033 Defined in: c:/ntddk/src/wdm/hid/hidgame/ioctl.c\par 
\pard\plain \s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 Parameters\par \pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\i DeviceObject}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Pointer to the driver object\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\i Irp}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Pointer to an I/O Request Packet.\par 
\pard\plain \s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 Return Codes\par
\trowd \trgaph72\trleft-72 \cellx3078\cellx7038 \pard\plain \intbl\s25\sa80\widctlpar\intbl \f4\fs21\lang1024 \sbasedon0\snext25 {\fs18 STATUS_SUCCESS\cell success\cell }\pard \intbl \row \pard\plain \intbl\s25\sa80\widctlpar\intbl \f4\fs21\lang1024 \sbasedon0\snext25 {\fs18 STATUS_DEVICE_NOT_CONNECTED\cell Device Failed to Quiesce 
( not connected )\cell }\pard \intbl \row \pard\plain \intbl\s25\sa80\widctlpar\intbl \f4\fs21\lang1024 \sbasedon0\snext25 {\fs18 STATUS_TIMEOUT\cell Could not determine exact transition time for 
one or more axis but not a failure.\cell }\pard \intbl \row \pard\plain \li240\sa0\sl240 \f2\fs20\lang1033 \par 
\pard\plain \s57\li-1770\ri30\sb280\sa250\sl-120\keepn\brdrb\brdrs\brdrw15\brdrcf2 \fs8\cf8\lang1033 \par 
\pard\plain \s254\li-1800\sb200\sa80\sl-440\keepn \b\f0\fs40\lang1033 HGM_RemoveDevice\par 
\pard \plain \sa160\sl240 \fs21\lang1033 {\b VOID} {\b HGM_RemoveDevice(}{\b IN PDEVICE_EXTENSION} {\i DeviceExtension}{\b ) }\par
\pard\plain \sa160\sl240 \fs21\lang1033 FDO Remove routine\par 
\pard\plain \sa160\sl240 \fs21\lang1033 Defined in: c:/ntddk/src/wdm/hid/hidgame/pnp.c\par 
\pard\plain \s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 Parameters\par \pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\i DeviceExtension}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Pointer to the device extension.\par 
\pard\plain \s57\li-1770\ri30\sb280\sa250\sl-120\keepn\brdrb\brdrs\brdrw15\brdrcf2 \fs8\cf8\lang1033 \par 
\pard\plain \s254\li-1800\sb200\sa80\sl-440\keepn \b\f0\fs40\lang1033 HGM_SetupButtons\par 
\pard \plain \sa160\sl240 \fs21\lang1033 {\b NTSTATUS} {\b HGM_SetupButtons(}{\b IN OUT PDEVICE_EXTENSION} {\i DeviceExtension}{\b ) }\par
\pard\plain \sa160\sl240 \fs21\lang1033 Use the flags in the DeviceExtension to check and set up buttons. 
\line This is called both from HGM_JoystickConfig to validate the 
configuration and HGM_GenerateReport to prepare for polling.\par 
\pard\plain \sa160\sl240 \fs21\lang1033 Defined in: c:/ntddk/src/wdm/hid/hidgame/hidjoy.c\par 
\pard\plain \s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 Parameters\par \pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\i DeviceExtension}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Pointer to the minidriver device extension\par 
\pard\plain \s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 Return Codes\par
\trowd \trgaph72\trleft-72 \cellx3078\cellx7038 \pard\plain \intbl\s25\sa80\widctlpar\intbl \f4\fs21\lang1024 \sbasedon0\snext25 {\fs18 STATUS_SUCCESS\cell success\cell }\pard \intbl \row \pard\plain \intbl\s25\sa80\widctlpar\intbl \f4\fs21\lang1024 \sbasedon0\snext25 {\fs18 STATUS_DEVICE_CONFIGURATION_ERROR\cell The configuration is invalid\cell }\pard \intbl \row \pard\plain \li240\sa0\sl240 \f2\fs20\lang1033 \par 
\pard\plain \s57\li-1770\ri30\sb280\sa250\sl-120\keepn\brdrb\brdrs\brdrw15\brdrcf2 \fs8\cf8\lang1033 \par 
\pard\plain \s254\li-1800\sb200\sa80\sl-440\keepn \b\f0\fs40\lang1033 HGM_Unload\par 
\pard \plain \sa160\sl240 \fs21\lang1033 {\b void} {\b HGM_Unload(}{\b IN PDRIVER_OBJECT} {\i DeviceObject}{\b ) }\par
\pard\plain \sa160\sl240 \fs21\lang1033 Free all the allocated resources, etc.\par 
\pard\plain \sa160\sl240 \fs21\lang1033 Defined in: c:/ntddk/src/wdm/hid/hidgame/hidgame.c\par 
\pard\plain \s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 Parameters\par \pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\i DeviceObject}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Pointer to the driver object\par 
\pard\plain \s57\li-1770\ri30\sb280\sa250\sl-120\keepn\brdrb\brdrs\brdrw15\brdrcf2 \fs8\cf8\lang1033 \par 
\pard\plain \s254\li-1800\sb200\sa80\sl-440\keepn \b\f0\fs40\lang1033 HGM_UpdateLatestPollData\par 
\pard \plain \sa160\sl240 \fs21\lang1033 {\b NTSTATUS} {\b HGM_UpdateLatestPollData(}{\b IN  OUT PDEVICE_EXTENSION} {\i DeviceExtension}{\b ) }\par
\pard\plain \sa160\sl240 \fs21\lang1033 Do whatever polling is required and possible to update the 
LastGoodAxis and LastGoodButton arrays in the DeviceExtension. 
Handles synchronization and non-fatal errors. 
\line This routine cannot be pageable as HID can make reads at 
dispatch-level.\par 
\pard\plain \sa160\sl240 \fs21\lang1033 Defined in: c:/ntddk/src/wdm/hid/hidgame/poll.c\par 
\pard\plain \s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 Parameters\par \pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\i DeviceExtension}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Pointer to the device extension containing the data to be updated 
and the functions and to use.\par 
\pard\plain \s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 Return Codes\par
\trowd \trgaph72\trleft-72 \cellx3078\cellx7038 \pard\plain \intbl\s25\sa80\widctlpar\intbl \f4\fs21\lang1024 \sbasedon0\snext25 {\fs18 STATUS_SUCCESS\cell success\cell }\pard \intbl \row \pard\plain \intbl\s25\sa80\widctlpar\intbl \f4\fs21\lang1024 \sbasedon0\snext25 {\fs18 STATUS_DEVICE_CONFIGURATION_ERROR\cell Invalid configuration specified\cell }\pard \intbl \row \pard\plain \li240\sa0\sl240 \f2\fs20\lang1033 \par 
\pard\plain \s57\li-1770\ri30\sb280\sa250\sl-120\keepn\brdrb\brdrs\brdrw15\brdrcf2 \fs8\cf8\lang1033 \par 
\pard\plain \s254\li-1800\sb200\sa80\sl-440\keepn \b\f0\fs40\lang1033 HidAnalogPoll\par 
\pard \plain \sa160\sl240 \fs21\lang1033 {\b NTSTATUS} {\b HidAnalogPoll(}{\b IN PDEVICE_EXTENSION} {\i DeviceExtension}{\b , IN UCHAR} {\i resisitiveInputMask}{\b , IN BOOLEAN} {\i fApproximate}{\b , IN OUT ULONG} {\i Axis[MAX_AXES]}{\b , OUT UCHAR} {\i Button[PORT_BUTTONS]}{\b ) }\par
\pard\plain \sa160\sl240 \fs21\lang1033 Polling routine for analog joysticks. 
\line Polls the analog device for position and button information. 
The position  information in analog devices is conveyed by the 
duration of a pulse width. Each axis occupies one bit position. 
The read operation is started by writing a value to the joystick 
io address. Immediately thereafter we begin examing the values 
returned and the elapsed time.\par 

This sort of device has a few limitations:\par 

First, button information is not latched by the device, so if a 
button press which occurrs in between polls it will be lost. 
There is really no way to prevent this short of devoting 
the entire cpu to polling.  In reality this does not cause a problem.\par 

Second, since it is necessary to measure the duration of the axis pulse, 
the most accurate results would be obtained using the smallest possible 
sense loop and no interruptions of this loop. 
The typical range of pulse lengths is from around 10 uSecs to 1500 uSecs 
but depending on the joystick and gameport, this could extend to at least 
8000 uSecs.  Keeping interrupts disabled for this length of time causes 
many problems, like modems losing connections to sound break ups.\par 

Third, because each iteration of the poll loop requires an port read, the 
speed of the loop is largely constrained by the speed of the IO bus. 
This also means that when there is contention for the IO bus, the loop 
will be slowed down.  IO contention is usually caused by DMAs (or FDMAs) 
which result in a significant slow down.\par 

Forth, because of the previous two problems, the poll loop may be slowed 
down or interrupted at any time so an external time source is needed to 
measure the pulse width for each axis.  The only cross-platform high 
resolution timer is the read with KeQueryPerformanceCounter. 
Unfortunately the implementation of this often uses a 1.18MHz 8253 timer 
which requires 3 IO accesses to read, compounding the third problem and 
even then, the result may need to be reread if the counters were in the 
wrong state.  Current CPUs have on board counters that can be used to 
provide very accurate timing and more recent HAL implementations tend to 
use these to implement KeQueryPerformanceCounter so this will be a problem 
on less systems as time goes on.  In the majority of cases, a poor 
KeQueryPerformanceCounter implementation is made irrelevant by testing 
for the availability of a CPU time stamp counter on Intel architechtures 
and using it directly if it is available.\par 

The algorithm implemented here is not the most obvious but works as 
follows:\par 

Once started, the axes read a value of one until the completion of their 
pulse.  The axes are the four lower bits in the byte read from the port. 
The state of the axes in each iteration of the poll loop is therefore 
represented as a value between 0 and 15.  The important time for each 
axis is the time at which it changes from 1 to 0.  This is done by using 
the value representing the state of the axes to index an array into which 
time values are stored.  For each axis, the duration of its pulse width is 
the latest time stored in the array at an index with the bit for that axis 
set.  However since interrupts can occur at any time, it is not possible 
to simultaneously read the port value and record that time in an atomic 
operation the in each iteration, the current time is stored in two arrays, 
one using the index before the time was recorded and the other using the 
index after the time was recorded. 
Once all the axes being monitored have become 0, or a timeout value is 
reached, the data left in the arrays is analysed to find the best 
estimate for the transition time for each axis.  If the times before and 
after the transition differ by too much, it is judged that an interrupt 
must have occured so the last known good axis value is returned unless 
that falls outside the range in which it is known that the transition 
occured.\par 

This routine cannot be pageable as HID can make reads at dispatch-level.\par 
\pard\plain \sa160\sl240 \fs21\lang1033 Defined in: c:/ntddk/src/wdm/hid/hidgame/poll.c\par 
\pard\plain \s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 Parameters\par \pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\i DeviceExtension}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Pointer to the device extension.\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\i resisitiveInputMask}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Mask that describes the axes lines that are to be polled\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\i fApproximate}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Boolean value indicating if it is OK to approximate some 
value of the current axis state with the last axis state 
if polling was not successful (we took an interrput during polling)\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\i Axis[MAX_AXES]}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 The state of the axes. On entry the last axis state is passed 
into this routine. If the fApproximate flag is turned on, we can 
make use of the last axis state to "guess" the current axis state.\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\i Button[PORT_BUTTONS]}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Receives the state of the buttons. 0x0 specifies the button is not 
pressed and 0x1 indicates an armed button state.\par 
\pard\plain \s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 Return Codes\par
\trowd \trgaph72\trleft-72 \cellx3078\cellx7038 \pard\plain \intbl\s25\sa80\widctlpar\intbl \f4\fs21\lang1024 \sbasedon0\snext25 {\fs18 STATUS_SUCCESS\cell success\cell }\pard \intbl \row \pard\plain \intbl\s25\sa80\widctlpar\intbl \f4\fs21\lang1024 \sbasedon0\snext25 {\fs18 STATUS_DEVICE_NOT_CONNECTED\cell Device Failed to Quiesce 
( not connected ) This is a failure code.\cell }\pard \intbl \row \pard\plain \intbl\s25\sa80\widctlpar\intbl \f4\fs21\lang1024 \sbasedon0\snext25 {\fs18 STATUS_TIMEOUT\cell Could not determine exact transition time for 
one or more axis.  This is a success code.\cell }\pard \intbl \row \pard\plain \li240\sa0\sl240 \f2\fs20\lang1033 \par 
\pard\plain \s57\li-1770\ri30\sb280\sa250\sl-120\keepn\brdrb\brdrs\brdrw15\brdrcf2 \fs8\cf8\lang1033 \par 
\pard\plain \s254\li-1800\sb200\sa80\sl-440\keepn \b\f0\fs40\lang1033 ANALOG_DEVICE Structure\par 
\pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 typedef struct \{\par \pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 \tab USHORT nAxes;\par \pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 \tab USHORT nButtons;\par \pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 \tab HIDGAME_OEM_DATA HidGameOemData;\par \pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 \tab ULONG ScaledTimeout;\par \pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 \tab ULONG ScaledThreshold;\par \pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 \tab ULONG LastGoodAxis[MAX_AXES];\par \pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 \tab UCHAR LastGoodButton[PORT_BUTTONS];\par \pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 \tab int AxisMap[MAX_AXES];\par \pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 \tab int povMap;\par \pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 \tab UCHAR resistiveInputMask;\par \pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 \tab UCHAR bSiblingState;\par \pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 \tab BOOLEAN fSiblingFound;\par \pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 \} ANALOG_DEVICE;\par 
\pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 \par 

\pard\plain \sa160\sl240 \fs21\lang1033 Analog Device specific data.\par 
\pard\plain \sa160\sl240 \fs21\lang1033 Defined in: C:/NTDDK/SRC/WDM/HID/HIDGAME/ANALOG.H\par 
\pard\plain \s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 Members\par \pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\b nAxes}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Number of axis this device has.\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\b nButtons}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Number of buttons this device has.\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\b HidGameOemData}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 The OEM Data field ( Contains joy_hws_dwFlags, vid & pid )\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\b ScaledTimeout}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 The number value at which an axis is considered to be not present.\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\b ScaledThreshold}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 The minimum resolution of a polling cycle. 
This is used to detect if we've been 
pre-empted or interrupted during a polling loop.\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\b LastGoodAxis[MAX_AXES]}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Value of the axes on last good poll.\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\b LastGoodButton[PORT_BUTTONS]}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Value of the buttons on last good poll.\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\b AxisMap[MAX_AXES]}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Index of axes remapping.\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\b povMap}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Index of axis where POV is mapped.\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\b resistiveInputMask}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Resisitive Input mask.\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\b bSiblingState}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Indicates the state of an expose sibling\\remove self transition\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\b fSiblingFound}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Set to true if this device has a sibling.\par 
\pard\plain \s57\li-1770\ri30\sb280\sa250\sl-120\keepn\brdrb\brdrs\brdrw15\brdrcf2 \fs8\cf8\lang1033 \par 
\pard\plain \s254\li-1800\sb200\sa80\sl-440\keepn \b\f0\fs40\lang1033 DEVICE_EXTENSION Structure\par 
\pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 typedef struct \{\par \pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 \tab PGAMEENUM_READPORT ReadAccessor;\par \pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 \tab PGAMEENUM_WRITEPORT WriteAccessor;\par \pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 \tab PGAMEENUM_READPORT_DIGITAL ReadAccessorDigital;\par \pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 \tab PGAMEENUM_ACQUIRE_PORT AcquirePort;\par \pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 \tab PGAMEENUM_RELEASE_PORT ReleasePort;\par \pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 \tab PVOID GameContext;\par \pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 \tab PVOID PortContext;\par \pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 \tab LIST_ENTRY Link;\par \pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 \tab KEVENT RemoveEvent;\par \pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 \tab LONG RequestCount;\par \pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 \tab PDEVICE_OBJECT NextDeviceObject;\par \pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 \tab WORK_QUEUE_ITEM WorkItem;\par \pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 \tab ANALOG_DEVICE unnamed structure see ANALOG_DEVICE;\par \pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 \tab BOOLEAN fRemoved;\par \pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 \tab BOOLEAN fStarted;\par \pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 \tab BOOLEAN fSurpriseRemoved;\par \pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 \} DEVICE_EXTENSION;\par 
\pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 \par 

\pard\plain \sa160\sl240 \fs21\lang1033 Device specific data.\par 
\pard\plain \sa160\sl240 \fs21\lang1033 Defined in: C:/NTDDK/SRC/WDM/HID/HIDGAME/HIDGAME.H\par 
\pard\plain \s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 Members\par \pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\b ReadAccessor}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Read Accessor function for the gameport. Obtained in the return from 
IOCTL to the gameport.\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\b WriteAccessor}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Write Accessor function for the gameport. Obtained in the return from 
IOCTL to the gameport.\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\b ReadAccessorDigital}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Digital read accessor for the gameport. Obtained as part of return from 
IOCTL to the gameport\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\b AcquirePort}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Function to call before reading/writing to the port. Obtained as 
part of return from IOCTL to the gameport\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\b ReleasePort}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Function to call when done reading/writing to the port. Obtained as 
part of return from IOCTL to the gameport\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\b GameContext}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Token to read this game port. Obtained as part of the return from 
IOCTL to the gameport.\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\b PortContext}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Context to pass to AcquirePort and ReleasePort. Obtained as part 
of the return from IOCTL to the gameport.\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\b Link}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Link to other hidgame devices on the system.\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\b RemoveEvent}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 The remove plugplay request must use this event to make sure all 
other requests have completed before it deletes the device object.\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\b RequestCount}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Number of IRPs underway.\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\b NextDeviceObject}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 NOTE: Only present if CHANGE_DEVICE is defined\par 

DeviceObject to send self created IRPs down to\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\b WorkItem}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 NOTE: Only present if CHANGE_DEVICE is defined\par 

Work item used for expose sibling/remove self\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\b unnamed structure see ANALOG_DEVICE}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Structure containing analog device specific information.\par 

NOTE: this structure is placed after the DWORD aligned elements.\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\b fRemoved}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Set to true if the device has been removed => all requests should be failed\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\b fStarted}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Set to true is device has started.\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\b fSurpriseRemoved}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Set to true if the device has been surprise removed by PnPs device has started.\par 
\pard\plain \s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 See Also\par \pard\plain \sa160\sl240 \fs21\lang1033 {\b ANALOG_DEVICE}.\par 
\pard\plain \s57\li-1770\ri30\sb280\sa250\sl-120\keepn\brdrb\brdrs\brdrw15\brdrcf2 \fs8\cf8\lang1033 \par 
\pard\plain \s254\li-1800\sb200\sa80\sl-440\keepn \b\f0\fs40\lang1033 HIDGAME_GLOBAL Structure\par 
\pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 typedef struct \{\par \pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 \tab FAST_MUTEX Mutex;\par \pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 \tab LIST_ENTRY DeviceListHead;\par \pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 \tab KSPIN_LOCK SpinLock;\par \pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 \tab COUNTER_FUNCTION ReadCounter;\par \pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 \tab ULONG CounterScale;\par \pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 \} HIDGAME_GLOBAL;\par 
\pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 \par 

\pard\plain \sa160\sl240 \fs21\lang1033 Global struct to store driver wide data. 
Stuff we need to share across multiple instances of this driver.\par 
\pard\plain \sa160\sl240 \fs21\lang1033 Defined in: C:/NTDDK/SRC/WDM/HID/HIDGAME/HIDGAME.H\par 
\pard\plain \s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 Members\par \pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\b Mutex}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Mutex to synchronize access to the following list entry\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\b DeviceListHead}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Keeps a list of all devices.\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\b SpinLock}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Spinlock used to stop multiple processors polling gameports at 
once.  It would be better to keep a list of spinlocks, one for 
each gameport but then processors could contend for IO access 
and we'd have to maintain another list.\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\b ReadCounter}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Function to retrieve clock time\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\b CounterScale}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 The scale to be used.\par 
\pard\plain \s57\li-1770\ri30\sb280\sa250\sl-120\keepn\brdrb\brdrs\brdrw15\brdrcf2 \fs8\cf8\lang1033 \par 
\pard\plain \s254\li-1800\sb200\sa80\sl-440\keepn \b\f0\fs40\lang1033 HIDGAME_INPUT_DATA Structure\par 
\pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 typedef struct \{\par \pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 \tab ULONG Axis[MAX_AXES];\par \pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 \tab UCHAR hatswitch[2];\par \pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 \tab UCHAR Button[MAX_BUTTONS];\par \pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 \} HIDGAME_INPUT_DATA;\par 
\pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 \par 

\pard\plain \sa160\sl240 \fs21\lang1033 Our HID reports always have 4 axis values (one of which may be a 
polled POV), 2 digital POVs and 10 buttons. 
Depending on the HWS flags and number of buttons some of the 
fields will report constant data.\par 

Note, this structure should be byte aligned so that the 
sizeof(it) is the same as HID will calculate given the report 
descriptor.  (In this case it happens to be aligned anyway.)\par 
\pard\plain \sa160\sl240 \fs21\lang1033 Defined in: C:/NTDDK/SRC/WDM/HID/HIDGAME/ANALOG.H\par 
\pard\plain \s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 Members\par \pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\b Axis[MAX_AXES]}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Axes data values.\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\b hatswitch[2]}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 digital POVs (derived from button combos)\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\b Button[MAX_BUTTONS]}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Button data values.\par 
\pard\plain \s57\li-1770\ri30\sb280\sa250\sl-120\keepn\brdrb\brdrs\brdrw15\brdrcf2 \fs8\cf8\lang1033 \par 
\pard\plain \s254\li-1800\sb200\sa80\sl-440\keepn \b\f0\fs40\lang1033 OEMDATA Structure\par 
\pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 typedef struct \{\par \pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 \tab USHORT VID;\par \pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 \tab USHORT PID;\par \pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 \tab ULONG joy_hws_dwFlags;\par \pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 \tab ULONG Timeout;\par \pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 \tab ULONG Reserved;\par \pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 \} OEMDATA;\par 
\pard\plain \s28\sl-220\tx380\tx760\tx1140\tx1520\tx1900\tx2280\tx2660\tx3040\tx3420\tx3800 \f19\fs16\lang1033 \par 

\pard\plain \sa160\sl240 \fs21\lang1033 OEMData is send to gameEnum as a parameter to IOCTL_EXPOSE_HARDWARE. 
Defined as 8 DWORDS. We interpert them here\par 
\pard\plain \sa160\sl240 \fs21\lang1033 Defined in: C:/NTDDK/SRC/WDM/HID/HIDGAME/ANALOG.H\par 
\pard\plain \s46\sb20\sl-220\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f2\fs21\lang1033 Members\par \pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\b VID}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Vendor ID\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\b PID}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Product ID\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\b joy_hws_dwFlags}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 The dwFlags fields for the device ( Usually read from the registry )\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\b Timeout}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Global timeout for device polling in micro seconds\par 
\pard\plain \s50\sl-240\keepn \f0\fs21\lang1033 {\b Reserved}\par 
\pard\plain \s54\li280\sa80\sl-240 \f0\fs21\lang1033 Reserved for future use.\par 
}
