{\rtf1\ansi {\fonttbl{\f0\fswiss Arial;}{\f1\fmodern Courier New;}} {\colortbl;} \fs20
@{\footnote   Help Topics for Microsoft Installer Database Classes}
\page

#{\footnote Table_ArchiveFormat}
${\footnote Database Table Archive Format}
K{\footnote DATABASE; Archive; Format}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Installer Table Archive Format
\line\fs18\b0\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Database tables are normally maintained individually as text archive files
 of the format below with the default extension ".idt". The MsiDatabase object
 has {\uldb ExportTable}{\v MsiDatabase_ExportTable} and
 {\uldb ImportTable}{\v MsiDatabase_ImportTable} functions that transfer these
 file to and from the physical database.
\par\li0{\b File Format}\par\li500\fi-320
Lines composed of tab-delimited text fields, terminated with CR and LF.\line
1st line contains the columns names as stored in the database.\line
2nd line contains the column specifications as described below.\line
3rd line contains the table name and all the primary keys for the table.\line
Subsequent lines contain the data values for each row in the table.\line
Integer, datetime, and bit fields are all converted to integer text.\line
Control characters (CR,LF,Tab,Null) are remapped to avoid delimiter conflict.\line
Memo and BLOB fields stored as separate files, filename used as column data.\line
Memo filename: 1st 8 chars from row data + ".imd".\line
BLOB filename: 1st 8 chars from row data + ".ibd".\line
\par\fi0\li0{\b Datatype Codes}\par\li180
An upper case letter indicate that Null values are allowed in the column.
 The '?' indicates that the maximum width of the column must be specified.
\par\pard\li300\tx1000
b? \tab Binary bytes(not supported), SQL_BINARY\line
c? \tab Character array (1-255), SQL_CHAR\line
d6 \tab Date, SQL_DATE\line
d16\tab Datetime, SQL_TIMESTAMP\line
i0 \tab Boolean, SQL_BIT\line
i1 \tab Byte, SQL_TINYINT\line
i2 \tab Short, SQL_SMALLINT\line
i4 \tab Integer, SQL_INTEGER\line
k4 \tab Counter, SQL_INTEGER (SQL_AUTO_INCREMENT)\line
s0 \tab Memo, SQL_LONGVARCHAR\line
s? \tab String, variable length (n=1-255), SQL_VARCHAR\line
v0 \tab BLOB, SQL_LONGVARBINARY\line
v? \tab VarBinary (1-255), SQL_LONGBINARY (not supported)\line
\page

#{\footnote New_Table_ArchiveFormat}
${\footnote New Database Table Archive Format}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Installer Table Archive Format
\line\fs18\b0\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Database tables are normally maintained individually as text archive files
 of the format below with the default extension ".idt". The MsiDatabase object
 has {\uldb ExportTable}{\v MsiDatabase_ExportTable} and
 {\uldb ImportTable}{\v MsiDatabase_ImportTable} functions that transfer these
 file to and from the physical database. The format is designed to support
 both MSI and ODBC database specifications.
\par\li0{\b File Format}\par\li500\fi-320
Lines are composed of tab-delimited text fields, terminated with CR and LF.\line
The 1st line contains the table name followed by the columns names.\line
The 2nd line contains the primary key count followed by the column specifications.\line
Subsequent lines contain the data values for each row in the table.\line
The first data value contains the persistent row attributes, stored as characters.\line
Integer, datetime, and bit fields are all converted to integer text.\line
Control characters (CR,LF,Tab,Null) are remapped to avoid delimiter conflict.\line
Memo and BLOB fields stored as separate files; the filename used as column data.\line
Memo filename: 1st 8 chars from row data + ".imd".\line
BLOB filename: 1st 8 chars from row data + ".ibd".\line
Primary key columns must be specified first in priority order.\line

\par\fi0\li0{\b Row Status attribute specification}\par\li180
Upper case letters are use to indicate each attribute tat is in the True state.\line
\par\pard\li300\tx1000\tx3000
T \tab iraTemporary   \tab not persisted with table unless explicitly forced\line
P \tab iraProvisional \tab with T, persisted only when database state dumped\line
\tab \tab may be used alone by external client to mark row as incomplete\line
U \tab iraUserInfo    \tab for use by external client to mark rows\line
\tab \tab not used by database engine\line
R \tab iraReadOnly    \tab prevents rows from being updated\line

\par\fi0\li0{\b Datatype Column Specification}\par\li180
Lower case letters are used to indicate a non-nullable column.\line
Upper case letters would indicate that Null values are allowed in the column.\line
\par\pard\li180\tx1000
{\b Code\tab MSI type \tab SQL type}\line
{\f1 b0} \tab icdObject \tab binary stream, SQL_LONGVARBINARY\line
{\f1 d6} \tab icdShort \tab date, SQL_DATE\line
{\f1 d16}\tab icdLong \tab datetime, SQL_TIMESTAMP\line
{\f1 i0} \tab icdShort \tab boolean, SQL_BIT\line
{\f1 i1} \tab icdShort \tab byte, SQL_TINYINT\line
{\f1 i2} \tab icdShort \tab short, SQL_SMALLINT\line
{\f1 i4} \tab icdLong \tab integer, SQL_INTEGER\line
{\f1 s0} \tab icdString \tab memo, SQL_LONGVARCHAR\line
{\f1 s?} \tab icdString \tab string, variable length (?=1-255), SQL_VARCHAR\line
\page

#{\footnote MsiDatabase_Specifications}
${\footnote Installer Database Specifications}
K{\footnote DATABASE; Specifications}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Database Engine Overview and Features
\line\fs18\b0\tx3000\tab{\uldb MsiDatabase Object}{\v MsiDatabase_Object}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
The MSI database engine has been designed for small size, high query performance,
 and very compact persistent file size, as well as to support the special requirements
 of the installer such as object and stream datatypes, tree-walking cursors,
 merges and diffs, and temporary tables, columns, and rows.
 The engine supports two levels of access: Very high-performance direct table access via cursors,
 and high-level access via SQL queries. The persistent file format uses OLE structured storage,
 which is used to support the limited transaction capability.
 Due to the performance and size constraints, we do not purport to be a complete SQL DBMS.
 The implementation is identical between Win32 and Macintosh PPC, except for some minor differences
 at the OLE interface level.

\par\fi0\li0{\b Features}\par\li180
Tables are indexed by primary keys. Natural fetch order is by primary key.\line
Any column may be specified to accept or reject null values, including primary keys.\line
Tables may be linked as a tree through any column, and may be walked from any node.\line
Strings are pooled; only one copy of each unique string is kept and stored per database.\line
String columns are unsized and may hold strings up to 64K bytes.\line
Streams are persisted and are accessed via stream objects.\line
Databases may be opened from files, resources, and IStorage interfaces.
Columns may be dynamically added to tables, and may be non-persistent.\line
SummaryInformation stream properties are individually readable and writable.\line
The database engine is exposed as a set of COM objects that support OLE automation.\line
Rows may be marked non-persistent and/or read-only.\line
Row attibutes may be queried: inserted, modified, non-persistent, merge failure, locked.\line
Multiple update modes: Insert(new row), Update(existing row), Assign(force), Merge(insert or match).\line
Temporary tables may be created. Even a temporary database can be created.\line
Databases can be diffed, creating a transform file that can be applied to a database.\line
COM objects may be stored in tables in non-persistent columns.\line
Tables may optionally be locked in memory for increased performance.\line
Stream objects may be used in tables, and are persisted as streams.\line
A separate output database may be specified to avoid writing to original database.\line
SQL updates and sorts through joins are supported.\line
SQL parameterized queries can be re-executed with new parameters.\line
Access and SQL Server databases and ODBC data sources are supported through ODBCS.\line
Temporary tables may be use with ODBC databases and may be joined with SQL queries.\line
ODBC driver available to expose MSI database as an ODBC data source.\line
Table may be imported and exported to text archives by both MSI and ODBC databases.\line

\par\fi0\li0{\b Low-level interface}\par\li180
The low-level interface consists of two primary objects: MsiTable which handles the schema,
 and MsiCursor which handles external data transfer. The cursor object communicates to the
 table object at the row level such that table updates are performed on complete rows.
 String objects and stream objects are used to transfer non-integer data.
 Row filtering can be performed only by matching column values for equality.

\par\fi0\li0{\b High-level interface}\par\li180
The high-level interface is accessed through the MsiView object, which is constructed with
 a SQL SELECT statement. The statement can contain parameter markers, "?", literal column values,
 a predicate expression consisting of logical and comparison operators (including equi-joins),
 and an ORDER BY column list. Queries with ORDER BY that doesn't specify the primary key are
 slower to execute, as a temporary table must be constructed. Data is transferred using
 MsiRecord objects, which contain the set of values transferred. The values may be integers,
 strings, streams, or COM objects.

\par\fi0\li0{\b Persistent storage}\par\li180
OLE structured storage is used to persist the database. Each table, including catalog tables,
 is stored as a separate stream. Stream data values are also stored as unique streams.
 The standard \\005SummaryStream property values are supported for use by the database client.
 Transforms may be stored as substorages, typically to provide updates and language transformations.
 The persistent files are compatible between the Win32 and Macintosh database engine.
 Both direct and transaction modes are supported, and temporary rows may optionally be persisted.
 For archiving purposes, the database engine can import and export tables as tab-delimited text files,
 with stream data values exported as separate files.

\par\fi0\li0{\b SQL limitations}\par\li180
Currently only SELECT statements are supported.\line
Update and delete are performed following SELECT execution; positioned update and delete are supported.\line
Only equi-joins are supported, using equality comparison; subqueries are not supported.\line
Only logical and comparison predicate operators are supported, no functions, arithmetic operators, GROUP BY.\line

\par\fi0\li0{\b Schema limitations}\par\li180
Datatypes supported: string, short integer, long integer, stream, object(non-persistent).\line
Tables may contain from 1 to 32 columns. Tree-linked tables are limited to 64K rows and 256 nesting levels.\line
Primary keys columns must be defined first in their priority order, followed by any non-primary key columns.\line
Persistent columns must be defined before temporary columns.\line
Text collating sequence is undefined; however identical text values will always group together.\line
Table and column names are not contrained; however to export tables, their names must be unique in the first 8 characters.\line
 
\page

*{\footnote VBA}
#{\footnote MsiDatabase_Object}
${\footnote MsiDatabase Object}
K{\footnote MsiDatabase; MsiView}
+{\footnote Class:MsiDatabase}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
MsiDatabase Object
\line\fs18\b0\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
The database object accesses a particular database, which may be either
 an Access database file, a SQL Server database, an ODBC data source, or a
 Microsoft Installer database. A low-level database engine is provided by the
 {\uldb MsiTable}{\v MsiTable_Object} and {\uldb MsiCursor}{\v MsiCursor_Object}
 objects, providing the basis of the Installer database and also providing
 support for ODBC tables loaded into memory.
 Some of the capabilities of the internal engine are object storage, dynamic
 addition of temporary columns, high performance, and tree representation.
\par
In the Microsoft Installer database, strings are stored in a common pool as
 an array of MsiString objects.
 Database fields simply store indices to this private array of unique strings.
 Internally, string uses are reference counted as part of the string management.
 Functions are provided for converting string objects to and from string indices.
 A string that returns zero for its index does not exist in the current database.
\par
Persistent tables are normally loaded into memory when a table object is created
 and removed from memory when the last reference to the table object is released.
 The LockTable function is used to keep a frequently used table in memory
 independently of reference counts. As long as the lock calls are greater than
 the unlock calls, the table remains in memory until the database is closed.
\par
Before the MsiDatabase object that is created for update is destructed
 (by releasing all references), the {\uldb Persist}{\v MsiDatabase_Persist} method
 must be called to either record all changes or to back out all changes, else
 an implicit rollback is performed at object destruction. MSI, Access,
 and SQLServer all support transactions and require this call. Some ODBC
 data source may not support transactions, in which case changeds cannot be rolled back
 (most non-transaction data source do not support update, so this is moot point).

\par\li0{\b Properties}\par\li180
{\uldb UpdateState}{\v MsiDatabase_UpdateState}\line
{\uldb Storage}{\v MsiDatabase_Storage}\line
{\uldb TableState}{\v MsiDatabase_TableState}\line
{\uldb ANSICodePage}{\v MsiDatabase_ANSICodePage}\line
\par\li0{\b Methods}\par\li180
{\uldb OpenView}{\v MsiDatabase_OpenView}\line
{\uldb GetPrimaryKeys}{\v MsiDatabase_GetPrimaryKeys}\line
{\uldb ImportTable}{\v MsiDatabase_ImportTable}\line
{\uldb ExportTable}{\v MsiDatabase_ExportTable}\line
{\uldb DropTable}{\v MsiDatabase_DropTable}\line
{\uldb FindTable}{\v MsiDatabase_FindTable}\line
{\uldb LoadTable}{\v MsiDatabase_LoadTable}\line
{\uldb CreateTable}{\v MsiDatabase_CreateTable}\line
{\uldb LockTable}{\v MsiDatabase_LockTable}\line
{\uldb GetCatalogTable}{\v MsiDatabase_GetCatalogTable}\line
{\uldb EncodeString}{\v MsiDatabase_EncodeString}\line
{\uldb DecodeString}{\v MsiDatabase_DecodeString}\line
{\uldb CreateTempTableName}{\v MsiDatabase_CreateTempTableName}\line
{\uldb Commit}{\v MsiDatabase_Commit}\line
{\uldb CreateOutputDatabase}{\v MsiDatabase_CreateOutputDatabase}\line
{\uldb GenerateTransform}{\v MsiDatabase_GenerateTransform}\line
{\uldb SetTransform}{\v MsiDatabase_SetTransform}\line
{\uldb MergeDatabase}{\v MsiDatabase_MergeDatabase}
\par\li0{\b Query API Sequencing}\par\li500\fi-320
The normally course of data access is summarized below:
\line 1. The client obtains a database object ({\uldb MsiServices.CreateDatabase}{\v MsiServices_CreateDatabase}).
\line 2. OpenView is called, specifying the view name and intended actions.
\line 3. View.Excecute is called, supplying any parameters in an MsiRecord object.
\line 4. View.Fetch is called repeatedly, returns MsiRecord objects until exhausted.
\line 5. View.Close is called, which releases the query and unfetched records.
\line 6. Database.Persist is called to persist any database updates or to back out changes.
\page

*{\footnote CPP}
#{\footnote IMsiDatabase_Class}
${\footnote IMsiDatabase Class}
K{\footnote IMsiDatabase; IMsiView}
+{\footnote Class:IMsiDatabase}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
IMsiDatabase Object
\line\fs18\b0\tx3000\tab{\uldb Msi Classes}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
The database object accesses a particular database, which may be either
 an Access database file, a SQL Server database, an ODBC data source, or a
 Microsoft Installer database. A low-level database engine is provided by the
 {\uldb IMsiTable}{\v MsiTable_Object} and {\uldb IMsiCursor}{\v MsiCursor_Object}
 objects, providing the basis of the Installer database and also providing
 support for ODBC tables loaded into memory.
 Some of the capabilities of the internal engine are object storage, dynamic
 addition of temporary columns, high performance, and tree representation.
\par
In the Microsoft Installer database, strings are stored in a common pool as
 an array of IMsiString objects.
 Database fields simply store indices to this private array of unique strings.
 Internally, string uses are reference counted as part of the string management.
 Functions are provided for converting string objects to and from string indices.
 A string that returns zero for its index does not exist in the current database.
\par
Persistent tables are normally loaded into memory when a table object is created
 and removed from memory when the last reference to the table object is released.
 The LockTable function is used to keep a frequently used table in memory
 independently of reference counts. As long as the lock calls are greater than
 the unlock calls, the table remains in memory until the database is closed.
\par\li0{\b Methods}\par\li180
{\uldb OpenView}{\v MsiDatabase_OpenView}\line
{\uldb GetPrimaryKeys}{\v MsiDatabase_GetPrimaryKeys}\line
{\uldb ImportTable}{\v MsiDatabase_ImportTable}\line
{\uldb ExportTable}{\v MsiDatabase_ExportTable}\line
{\uldb DropTable}{\v MsiDatabase_DropTable}\line
{\uldb FindTable}{\v MsiDatabase_FindTable}\line
{\uldb LoadTable}{\v MsiDatabase_LoadTable}\line
{\uldb CreateTable}{\v MsiDatabase_CreateTable}\line
{\uldb LockTable}{\v MsiDatabase_LockTable}\line
{\uldb GetCatalogTable}{\v MsiDatabase_GetCatalogTable}\line
{\uldb EncodeString}{\v MsiDatabase_EncodeString}\line
{\uldb DecodeString}{\v MsiDatabase_DecodeString}\line
{\uldb CreateTempTableName}{\v MsiDatabase_CreateTempTableName}
\par\li0{\b Query API Sequencing}\par\li500\fi-320
The normally course of data access is summarized below:
\line 1. The client obtains a database object (IMsiServices::GetDatabase)
\line 2. OpenView is called, specifying the view name and intended actions.
\line 3. View->Excecute is called, supplying any parameters in an IMsiRecord.
\line 4. View->Fetch is called repeatedly, returns records until exhausted.
\line 5. View->Close is called, which releases the query and unfetched records.
\page

#{\footnote MsiDatabase_OpenView}
${\footnote MsiDatabase.OpenView}
+{\footnote MsiDatabase:OpenView}
K{\footnote OpenView}
K{\footnote ivcNoData;ivcFetch;ivcUpdate;ivcInsert;ivcDelete;}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
OpenView Method
\line\tx360\tab\fs18\b0{\uldb MsiDatabase Object}{\v MsiDatabase_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Returns an {\uldb MsiView}{\v MsiView_Object} object representing the query
 specified by a SQL string.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .OpenView({\i sql, intent})}
\par{\i object}\line
Required. The MsiDatabase object.
\par{\i\b sql}\line
Required. The SQL query string.
\par{\i\b intent}\line
Required. The combination of ALL operations intended on the MsiView object:
\line{\f1  ivcNoData   }- No data access, can get column information only.
\line{\f1  ivcFetch    }- Fetch data from rows into MsiRecord objects.
\line{\f1  ivcUpdate   }- Update rows from modified MsiRecord objects.
\line{\f1  ivcInsert   }- Insert rows using data in MsiRecord objects.
\line{\f1  ivcDelete   }- Delete rows using fetched MsiRecord objects.
\par\fi0\li0{\b SQL Syntax}\par\li500\fi-320
The SQL query strings are restricted to the format:\line
The {\b select} SQL query.\line
{\f1\b SELECT} [DISTINCT]\{column-list\} {\f1\b FROM} \{table-list\} [{\f1\b WHERE}
 \{operation-list\}] [{\f1\b ORDER BY} \{column-list\}].\line
\{table-list\} is a comma delimited list of one or more table names hereby refered to as \{table\} in the join. Table names 
that clash with SQL keywords need to be quoted within {\b ``}.\line
\{column-list\} is a comma delimited list of one or more table columns hereby refered to as \{column\} selected. Ambiguous columns may 
be further qualified as \{tablename.column\}. Column names that clash with SQL keywords need to be 
quoted within {\b ``}. In case the column is qualified as \{tablename.column\} and if there is a need 
to escape the identifier then the tablename and the column need to be individually escaped as 
\{`tablename`.`column`\}\line
\{operation-list\} clause is optional and is a grouping of operations to be used to filter the selection. The operations can be of the type -\line
\{column\} = \{column\}\line
\{column\} <> \{column\}\line
\{column\} > \{column\}\line
\{column\} < \{column\}\line
\{column\} >= \{column\}\line
\{column\} <= \{column\}\line
\{column\} = \{constant\}\line
\{column\} <> \{constant\}\line
\{column\} > \{constant\}\line
\{column\} < \{constant\}\line
\{column\} >= \{constant\}\line
\{column\} <= \{constant\}\line
\{column\} is null\line
\{column\} is not null\line
individual operations can be grouped be {\b AND} or {\b OR} operators. Ordering can be imposed by use of {\b()}\line
\{constant\} is either a string or an integer. A string has to be quoted within {\b''}.\line
The {\bORDER BY} clause is optional and will cause an initial delay during sorting.\line
The {\b DISTINCT} clause is optional and will not repeat identical records in the return result set.\line
 The table and column names are case sensitive, even if ODBC databases are used.
 However, SQL keywords are case-insensitive.
 Only inner joins are supported, specified by a comparison of columns from different tables.\line
The {\b delete} SQL query.\line
{\f1\b DELETE FROM} \{table\} [{\f1\b WHERE} \{operation-list\}].\line
The {\b update} SQL query.\line
{\f1\b UPDATE} \{table-list\} {\f1\b SET} \{column\}{\f1\b =} \{constant\} 
[{\f1\b ,} \{column\}{\f1\b =} \{constant\}]* [{\f1\b WHERE} \{operation-list\}].\line
The {\b insert} SQL query.\line
{\f1\b INSERT INTO} \{table\} \{{\b (}column-list{\b )}\} {\f1\b VALUES} 
\{{\b (}constant-list{\b )}\}.\line
The * implies 0 or more repitition.\line
The {\b create} SQL query.\line
{\f1\b CREATE TABLE} \{table\} {\f1\b (} \{column\} [{\f1\b CHAR} [{\f1\b (} \{size\} {\f1\b )}] | {\f1\b CHARACTER} [{\f1\b (} \{size\} {\f1\b )}] | {\f1\b LONGCHAR}  | {\f1\b SHORT} | {\f1\b INT} | {\f1\b INTEGER} | {\f1\b LONG} | {\f1\b OBJECT} ]  [{\f1\b NOT NULL}] [{\f1\b TEMPORARY}] [, {column}...]* {\f1\b PRIMARY KEY } {column} [, {column}]* {\f1\b )}.\line
The * implies 0 or more repitition.\line
The {\b alter} SQL query.\line
{\f1\b ALTER TABLE} \{table\} {\f1\b ADD } \{column\} [{\f1\b CHAR} [{\f1\b (} \{size\} {\f1\b )}] | {\f1\b CHARACTER} [{\f1\b (} \{size\} {\f1\b )}] | {\f1\b LONGCHAR}  | {\f1\b SHORT} | {\f1\b INT} | {\f1\b INTEGER} | {\f1\b LONG} | {\f1\b OBJECT} ]  [{\f1\b NOT NULL}] [{\f1\b TEMPORARY}].\line
\page

#{\footnote MsiDatabase_GetPrimaryKeys}
${\footnote MsiDatabase.GetPrimaryKeys}
+{\footnote MsiDatabase:GetPrimaryKeys}
K{\footnote GetPrimaryKeys}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
GetPrimaryKeys Method
\line\tx360\tab\fs18\b0{\uldb MsiDatabase Object}{\v MsiDatabase_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Returns a MsiRecord object containing table name in Field(0) and the
 columns names comprising the primary keys in succeeding fields,
 corresponding their column numbers. The field count of the record
 is the count of primary key columns.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .GetPrimaryKeys {\i table}}
\par{\i object}\line
Required. The MsiDatabase object.
\par{\i\b table}\line
Required. Name of an existing table. An error is generated if the table does
 not exist.
\page

#{\footnote MsiDatabase_ImportTable}
${\footnote MsiDatabase.ImportTable}
+{\footnote MsiDatabase:ImportTable}
K{\footnote ImportTable; Import}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
ImportTable Method
\line\tx360\tab\fs18\b0{\uldb MsiDatabase Object}{\v MsiDatabase_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Imports a database table from a text archive file, dropping any existing table.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .ImportTable {\i path, file}}
\par{\i object}\line
Required. The MsiDatabase object.
\par{\i\b path}\line
Required. An MsiPath object set to the folder where the text file is present.
\par{\i\b file}\line
Required. The name of the file to be imported. This does not include the folder,
 as that must be set in the path object. The table name is specified within the file.
\par\fi0\li0{\b\uldb Archive File Format}{\v Table_ArchiveFormat}
\par\fi0\li0{\b SummaryInformation Stream}\par\li180
For .MSI databases only, not ODBC, a special stream "\005SummaryInformation" is written
 containing standardized properties defined by OLE and browsable by the Explorer.
 If the table name in the text archive file is named exactly "_SummaryInformation",
 the table rows consisting of pairs of Property Id numbers with corresponding data values
 will be written to the property stream. For ODBC databases, a normal table will be created.
 If the data value is a valid integer, it is taken to be an integer property. Else if it
 can be parsed as a date or date/time value (consisting of digits separated by slashes) it
 is taken to be a data/time value. Otherwise it is assumed to be a string value. Date values
 may have two formats: yyyy/mm/dd  (time is entered as 0) or yyyy/mm/dd/hh/mm/ss (24 hr. time).
 The summary information is customarily generated for new files by the release build process.
\page

#{\footnote MsiDatabase_ExportTable}
${\footnote MsiDatabase.ExportTable}
+{\footnote MsiDatabase:ExportTable}
K{\footnote ExportTable; Export}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
ExportTable Method
\line\tx360\tab\fs18\b0{\uldb MsiDatabase Object}{\v MsiDatabase_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Copies the structure and data from a specified table to a text archive file.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .ExportTable {\i table, path, file}}
\par{\i object}\line
Required. The MsiDatabase object.
\par{\i\b table}\line
Required. The name of the database table, case-sensitive if MSI database.
\par{\i\b path}\line
Required. An MsiPath object set to the folder where the text file will be placed.
\par{\i\b file}\line
Required. The name of the file to be created. This does not include the folder,
 as that must be set in the path object. Keep to the 8.3 format if SLM is used.
\par\fi0\li0{\b\uldb Archive File Format}{\v Table_ArchiveFormat}
\page

#{\footnote MsiDatabase_LoadTable}
${\footnote MsiDatabase_LoadTable}
+{\footnote MsiDatabase:LoadTable}
K{\footnote LoadTable}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
LoadTable Method
\line\tx360\tab\fs18\b0{\uldb MsiDatabase Object}{\v MsiDatabase_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
The LoadTable method creates and returns a database table object in memory by
 reading a table from the persistent database. Additional temporary columns may
 be added if desired using the {\uldb CreateColumn}{\v MsiTable_CreateColumn}
 of the created table. This table remains in memory as long as there are
 outstanding references to the MsiTable object, or outstanding locks from the
 LockTable method. If an Access, SQL Server, or ODBC table is specified,
 database operations will be performed on the in-memory table, and any update
 operations on persistent columns will be replicated in the persistent table.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .LoadTable({\i table, addColumns})}
\par{\i object}\line
Required. The MsiDatabase object.
\par{\i\b table}\line
Required. Name of an existing table. An error is generated if the table does
 not exist in the current database.
\par{\b\i addColumns}\line
Optional. The anticipated number of columns that will be added
 after the data is loaded. This is for optimization only. Columns may be
 added beyond this number, but will require reallocation of the data rows.
\par\fi0\li0{\b Remarks}\par\li180
If the requested table is already loaded into memory, a reference to
 that table will be returned. When processing SQL queries on an Msi database,
 tables will be loaded if necessary during the processing of the query, and
 will remain loaded until the MsiView object is released. If a table is known
 to be accessed repeatedly, {\uldb LockTable}{\v MsiDatabase_LockTable} may
 be called to hold the table in memory once loaded.
\par
A table loaded from an ODBC database must have a primary key defined and the
 composite columns must specified in order as the first columns in the table.
 (In the future the column order to be altered when loaded into memory.)
\page

#{\footnote MsiDatabase_CreateTable}
${\footnote MsiDatabase.CreateTable}
+{\footnote MsiDatabase:CreateTable}
K{\footnote CreateTable}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
CreateTable Method
\line\tx360\tab\fs18\b0{\uldb MsiDatabase Object}{\v MsiDatabase_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Creates a temporary, in-memory table, and returns it as a
 {\uldb MsiTable}{\v MsiTable_Object} object.
 If columns are marked as persistent, the table will be created in the persistent
 database when the database is closed.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .CreateTable({\i table, initRows})}
\par{\i object}\line
Required. The MsiDatabase object.
\par{\i\b table}\line
Required. Name to be given to table. An error will be generated if a table
 by that name already exists in the current database.
\par{\b\i rowCount}\line
Optional. The suggested number of rows to allocate initially.
 This is an optimization only. If this argument is omitted or has a value of zero,
 the default number of rows will be initially allocated.
 The data array will grow as required as more rows are inserted.
\page

#{\footnote MsiDatabase_LockTable}
${\footnote MsiDatabase.LockTable}
+{\footnote MsiDatabase:LockTable}
K{\footnote LockTable}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
LockTable Method
\line\tx360\tab\fs18\b0{\uldb MsiDatabase Object}{\v MsiDatabase_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
The LockTable method will lock a specified table in memory once it is loaded,
 or will release a lock on a table that has been locked. When all locks are released and there
 are no outstanding references to the table object, it will be released from memory.
 Any outstanding locks will be removed when the database object is destroyed.
 The method returns a boolean indicating whether the lock operation succeeded.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .LockTable({\i table, lock})}
\par{\i object}\line
Required. The MsiDatabase object.
\par{\i\b table}\line
Required. The name of the table to lock.
\par{\i\b lock}\line
Required. Boolean value, TRUE to lock, FALSE to unlock.
\par\fi0\li0{\b Remarks}\par\li180
Locking a table that is not loaded into memory will not attempt to load that
 table into memory, but will hold it in memory once loaded. Locks are cumulative,
 and the loaded table is held in memory until the lock count returns to zero.
 Locking is a performance hint to the database engine and may not always be honored.
\page

#{\footnote MsiDatabase_DropTable}
${\footnote MsiDatabase.DropTable}
+{\footnote MsiDatabase:DropTable}
K{\footnote DropTable}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
 DropTable Method
\line\tx360\tab\fs18\b0{\uldb MsiDatabase Object}{\v MsiDatabase_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Removes a table from the persistent database along with its data.
 This method will fail if the table does not exist or if the database is not
 an MSI database and the table is in use. Dropping an MSI database table that
 is in use will remove it from the system catalogs, but the now-anonymous MsiTable
 object will remain until all references are released.
 Temporary tables, created with CreateTable, cannot be dropped, but will
 be destroyed when all references are released. ODBC databases generally do not
 perform Drop Table within the transaction, preventing this operation from being rolled back.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .DropTable {\i table}}
\par{\i object}\line
Required. The MsiDatabase object.
\par{\i\b table}\line
Required. The name of the database table, case-sensitive if MSI database.
\page

#{\footnote MsiDatabase_FindTable}
${\footnote MsiDatabase.FindTable}
+{\footnote MsiDatabase:FindTable}
K{\footnote FindTable}
K{\footnote itsUnknown;itsTemporary;itsUnloaded;itsLoaded}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
 FindTable Method
\line\tx360\tab\fs18\b0{\uldb MsiDatabase Object}{\v MsiDatabase_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Returns the status of a table in this database, one of the enum itsEnum:
\line{\f1  itsUnknown   = 0 } named table is not in database
\line{\f1  itsTemporary = 1 } table is temporary, not persistent !!marked obsolete
\line{\f1  itsUnloaded  = 2 } table exists in database but is not loaded
\line{\f1  itsLoaded    = 3 } table is loaded into memory from database
\line{\f1  itsOutput    = 6 } table copied to output database (itsUnloaded + 4)
\line{\f1  itsSaveError = 7 } unable to write table to storage (itsLoaded + 4) !!marked obsolete
\line{\f1  itsTransform = 10} table need to have tranform applied when loaded !!marked obsolete
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .FindTable {\i table}}
\par{\i object}\line
Required. The MsiDatabase object.
\par{\i\b table}\line
Required. The name of the database table, case-sensitive.
\page

#{\footnote MsiDatabase_TableState}
${\footnote MsiDatabase.TableState}
+{\footnote MsiDatabase:TableState}
K{\footnote TableState}
K{\footnote itsUnknown;itsTemporary;itsUnloaded;itsLoaded}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
TableState Property
\line\tx360\tab\fs18\b0{\uldb MsiDatabase Object}{\v MsiDatabase_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Returns a selected attribute of a table in this database. Read-only.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .TableState({\i table, state})}
\par{\i object}\line
Required. The MsiDatabase object.
\par{\i\b table}\line
Required. The name of the database table, case-sensitive.
\par{\i\b state}\line
Required. The particular attribute to be queried, one of the enum itsEnum:
\line{\f1  itsPermanent   = 0 }  table has persistent columns
\line{\f1  itsTemporary   = 1 }  temporary table, no persistent columns
\line{\f1  itsTableExists = 2 }  table currently defined in system catalog
\line{\f1  itsDataLoaded  = 3 }  table currently present in memory
\line{\f1  itsUserClear   = 4 }  user state flag reset, not used internally
\line{\f1  itsUserSet     = 5 }  user state flag set, not used internally
\line{\f1  itsOutputDb    = 6 }  persistence transferred to output database
\line{\f1  itsSaveError   = 7 }  error saving table, will retry at Commit
\line{\f1  itsUnlockTable = 8 }  table is not locked in memory
\line{\f1  itsLockTable   = 9 }  table locked in memory
\line{\f1  itsTransform   = 10}  table needs to be transformed when loaded
\page

#{\footnote MsiDatabase_GetCatalogTable}
${\footnote MsiDatabase.GetCatalogTable}
+{\footnote MsiDatabase:GetCatalogTable}
K{\footnote GetCatalogTable}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
GetCatalogTable Method
\line\tx360\tab\fs18\b0{\uldb MsiDatabase Object}{\v MsiDatabase_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Returns one of the MsiTable objects maintained by the MsiDatabase object that
 contain the table definitions for the database.
 The returned MsiTable object is read-only, and its data can be queried by
 creating an MsiCursor object on the table. The table structures are given below.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .GetCatalogTable({\i table})}
\par{\i object}\line
Required. The MsiDatabase object.
\par{\i\b table}\line
Required. Table to access: 0 = {\uldb _Tables}{\v _msi__Tables_Table@msi.hlp}, 1 = {\uldb _Columns}{\v _msi__Columns_Table@msi.hlp}.
\par\fi0\li0{\b Tables Catalog Table Definition}
\line   1 - Table name, primary key for this catalog table
\line   2 - MsiTable object, only if table is loaded into memory
\par\fi0\li0{\b Columns Catalog Table Definition}
\line   1 - Table name, 1st column of primary key for this catalog table
\line   2 - Column number, remainder of primary key
\line   3 - Column name, may be Null
\line   4 - Column type, integer containing packed size and type information
\par\fi0\li0{\b Remarks}\par\li180
These tables are maintained for ODBC databases as well as MSI databases,
 and will also contain definitions for any temporary tables created.
\page

#{\footnote MsiDatabase_DecodeString}
${\footnote MsiDatabase.DecodeString}
+{\footnote MsiDatabase:DecodeString}
K{\footnote DecodeString}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
DecodeString Method
\line\tx360\tab\fs18\b0{\uldb MsiDatabase Object}{\v MsiDatabase_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
This function converts a database string index into its referenced string.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .DecodeString({\i index})}
\par{\i object}\line
Required. The MsiDatabase object.
\par{\i\b index}\line
Required. The database string index, 0 is always the null string.
\page

#{\footnote MsiDatabase_EncodeString}
${\footnote MsiDatabase.EncodeString}
+{\footnote MsiDatabase:EncodeString}
K{\footnote EncodeString}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
EncodeString Method
\line\tx360\tab\fs18\b0{\uldb MsiDatabase Object}{\v MsiDatabase_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
This function converts a string into its corresponding database string index.
 If the string is not used in the database the value 0 will be returned.
 An empty string is treated as a Null in the database and not stored.
 Consequently, this functions returns 0 for an empty string.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .EncodeString({\i text})}
\par{\i object}\line
Required. The MsiDatabase object.
\par{\i\b text}\line
Required. The string for which the string index is requested.
\page

#{\footnote MsiDatabase_CreateTempTableName}
${\footnote MsiDatabase.CreateTempTableName}
+{\footnote MsiDatabase:CreateTempTableName}
K{\footnote CreateTempTableName}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
CreateTempTableName Method
\line\tx360\tab\fs18\b0{\uldb MsiDatabase Object}{\v MsiDatabase_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Returns a unique table name that can be used for a temporary database table
 using the {\uldb CreateTable method}{\v MsiDatabase_CreateTable}.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .CreateTempTableName}
\par{\i object}\line
Required. The MsiDatabase object.
\page

#{\footnote MsiDatabase_Persist}
${\footnote MsiDatabase.Persist}
+{\footnote MsiDatabase:Persist}
K{\footnote Persist}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Persist Method
\line\tx360\tab\fs18\b0{\uldb MsiDatabase Object}{\v MsiDatabase_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
 {\b --This method is OBSOLETE.--} use {\uldb Commit}{\v MsiDatabase_Commit} instead.
 Finalizes the persistent form of the database. Depending upon the action specified,
 changes made to the database since it was opened can be committed or rolled back,
 or the database can be physically deleted when the current object is destructed.
 If the MsiDatabase object has been created read-only, this method will have no effect
 and no error will be generated. If the
 {\uldb CreateOutputDatabase}{\v MsiDatabase_CreateOutputDatabase} method has be called,
 any unloaded input database tables will be transferred to the output database.
 This method is normally called prior to shutdown when all database changes have been finalized.
 If this method is never explicitly called, the database will be rolled back when the Database object is destructed,
 with {\i\b action} set to {\f1 idpRollback}.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .Persist {\i action}}
\par{\i object}\line
Required. The MsiDatabase object.
\par{\i\b action}\line
Required. The action to be taken on the persistent format, on of the enum idpEnum:
\line{\f1  idpRollback  = 0 = FALSE } NO-OP (rollback performed at database destruction)
\line{\f1  idpCommit    = 1 = TRUE  } current updates committed, further updates allowed
\line{\f1  idpDelete    = 2         } file is to be deleted when all references released
\line{\f1  idpSave      = 3         } NOT SUPPORTED
\page

#{\footnote MsiDatabase_Commit}
${\footnote MsiDatabase.Commit}
+{\footnote MsiDatabase:Commit}
K{\footnote Commit}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Commit Method
\line\tx360\tab\fs18\b0{\uldb MsiDatabase Object}{\v MsiDatabase_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Finalizes the persistent form of the database. All persistent data will be written
 to the writable database. No temporary columns or rows are written. This method has
 no effect on a database opened read-only. This method can be call multiple times to
 save the current state of tables loaded into memory. When the database is finally
 closed, any changes made subsequent to the last Commit will be rolled back.
 If the {\uldb CreateOutputDatabase}{\v MsiDatabase_CreateOutputDatabase} method has be called,
 any unloaded input database tables will be transferred to the output database, applying transforms as required..
 This method is normally called prior to shutdown when all database changes have been finalized.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .Commit}
\par{\i object}\line
Required. The MsiDatabase object.
\page

#{\footnote MsiDatabase_CreateOutputDatabase}
${\footnote MsiDatabase.CreateOutputDatabase}
+{\footnote MsiDatabase:CreateOutputDatabase}
K{\footnote CreateOutputDatabase}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
CreateOutputDatabase Method
\line\tx360\tab\fs18\b0{\uldb MsiDatabase Object}{\v MsiDatabase_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Specifies the name of the output database to be created that will contain the
 original database as modified by all update operations. This method will
 fail if called after any modifications have been written to the original database.
 This does not apply to changes made to tables loaded into memory, as the changes
 are not written to the persistent database until the tables are released from memory.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .CreateOutputDatabase {\i file, saveTempRows}}
\par{\i object}\line
Required. The MsiDatabase object.
\par{\i\b file}\line
Required. The name of the database to be created. Only .msi database format is currently supported.
\par{\i\b saveTempRows}\line
Optional. True to persist temporary table rows, False to drop them from persistent storage.
\par\fi0\li0{\b Remarks}\par\li180
The method in provided to avoid unnecessary copying of the database.
 Often the final location of the updated database is not known without processing the
 information in the database itself, and the database could be significantly updated.
 If this method is used, the original database can be opened read-only, and thus may reside
 on a CD or a read-only server. This method must be called before the first update to the
 persistent database, i.e. released a modified table from memory, or performing a update on a
 non-loaded table using any of the update methods of the MsiView object.
 When this MsiDatabase object is released, all unmodified tables, along with associated binary stream data,
 will be copied to the output database.
\page

#{\footnote MsiDatabase_GenerateTransform}
${\footnote MsiDatabase.GenerateTransform}
+{\footnote MsiDatabase:GenerateTransform}
K{\footnote GenerateTransform}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
GenerateTransform Method
\line\tx360\tab\fs18\b0{\uldb MsiDatabase Object}{\v MsiDatabase_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\par}\li180
Creates a transform which, when applied to the {\i object} database, will
 result in the {\i reference} database. The transform is stored in the
 {\i storage} object.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .GenerateTransform({\i reference, storage, long errorConditions, long validation})}
\par{\i object}\line
Required. The MsiDatabase object.
\par{\i\b reference}\line
Required. The reference MsiDatabase object.
\par{\i\b storage}\line
Required. The MsiStorage object where the transform is to be stored.
\par{\i\b errorConditions}\line
Required. The conditions that should be ignored as errors when
 the transform is applied.\line
Choose either:
\line{\f1  iteNone                }- None of the following conditions.
\line Or combine one or more of the following:
\line{\f1  iteAddExistingRow      }- Adding a row that already exists.
\line{\f1  iteDelNonExistingRow   }- Deleting a row that doesn't exist.
\line{\f1  iteAddExistingTable    }- Adding a table that already exists.
\line{\f1  iteDelNonExistingTable }- Deleting a table that doesn't exist.
\line{\f1  iteUpdNonExistingRow   }- Updating a row that doesn't exist.
\par{\i\b validation}\line
Required. When the transform is applied to a database, which properties should
 be validated to verify that this transform can be applied to the database.
 The properties are all contained in the
 {\uldb Summary Information}{\v Summary_Overview} stream.
\line{\f1  itvNone           }- Validate no properties.
\line Or combine one or more of the following
\line{\f1  itvLanguage       }- Default language must match base database.
\line{\f1  itvProduct        }- Product must match base database.
\line{\f1  itvPlatform       }- Platform must match base database.
\line To validate product version, first choose one or more of these
 three flags to indicate how much of the version is to be verified.
\line{\f1  itvMajVer         }- Check major version only.
\line{\f1  itvMinVer         }- Check major and minor version only.
\line{\f1  itvUpdVer         }- Check major, minor, and update version.
\line Then choose one of the following to indicate the required
 relationship between the product version of the database the transform
 is being applied to, and that of the base database.
\line{\f1  itvLess           }- Applied db version <  base db version
\line{\f1  itvLessOrEqual    }- Applied db version <= base db version
\line{\f1  itvEqual          }- Applied db version =  base db version
\line{\f1  itvGreaterOrEqual }- Applied db version >= base db version
\line{\f1  itvGreater        }- Applied db version >  base db version
\par\fi0\li0{\b Remarks}\par\li180
!! The error and validation conditions may or may not work !!\line\line	
For tables that exist in both databases, the only difference between the two
 schemas that is allowed is the addition of columns to the {\b end} of the 
 reference table. This means that you cannot add primary key columns to a
 table or change the order or names or column definitions of the existng columns
 as defined in the base table.  Therefore, the reference table must contain the
 exact same table schema, but it can have some additional/extra columns.  These
 columns must come after the columns defined in the base table though.  In other words,
 if neither table contained data and the extra columns were removed from the reference
 table, the resulting refernce table would be identifcal to the base table.  No deletion
 of columns, addition of primary keys, or changing of column definitions is allowed.
\page

#{\footnote MsiDatabase_SetTransform}
${\footnote MsiDatabase.SetTransform}
+{\footnote MsiDatabase:SetTransform}
K{\footnote SetTransform}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
SetTransform Method
\line\tx360\tab\fs18\b0{\uldb MsiDatabase Object}{\v MsiDatabase_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\par}\li180
SetTransform will apply the given transform to this database.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .SetTransform({\i storage}, {\i errorConditions})}
\par{\i object}\line
Required. The MsiDatabase object.
\par{\i\b storage}\line
Required. The MsiStorage object containing the transform.
\par{\i\b treatAsError}\line
Required. The conditions that should be ignored as errors, specified as an
 integer combination of the values below.
\line{\f1  iteAddExistingRow       } Adding a row that already exists.
\line{\f1  iteDelNonExistingRow    } Deleting a row that doesn't exist.
\line{\f1  iteAddExistingTable     } Adding a table that already exists.
\line{\f1  iteDelNonExistingTable  } Deleting a table that doesn't exist.
\line{\f1  iteUpdNonExistingRow    } Updating a row that doesn't exist.
\par\fi0\li0{\b Remarks}\par\li180
SetTransform delays transforming tables until the last possible moment.  The steps
 taken in SetTransform are to immediately transform the table and column catalogs
 for the database.  The table and column catalogs are updating according to what
 table is added or deleted and what column is added (no deletion of columns is
 allowed).  If a table is currently loaded in memory and needs to be transformed,
 it will be transformed then.  Else, the table's state will be set to that requiring
 a transform so that when it is loaded or when the database is committed the transform
 will be applied.  Transform in this instance means that the actual data (row data) of
 the table is added, deleted, or updated.
\par
If SetTransform is called when tables have already been saved
 to storage, an error will occur.
\page

#{\footnote MsiDatabase_MergeDatabase}
${\footnote MsiDatabase.MergeDatabase}
+{\footnote MsiDatabase:MergeDatabase}
K{\footnote MergeDatabase}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
MergeDatabase Method
\line\tx360\tab\fs18\b0{\uldb MsiDatabase Object}{\v MsiDatabase_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\par}\li180
MergeDatabase will merge the reference database in with the base database.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .MergeDatabase({\i reference}, {\i errorTable})}
\par{\i object}\line
Required. The MsiDatabase object.
\par{\i\b reference}\line
Required. The MsiDatabase object to be merged into the base.
\par{\i\b errorTable}\line
Optional. A table object to contain the names of the tables containing
 merge conflicts, the number of conflicting rows within the table, and a
 reference to the table with the merge conflict.
\par\fi0\li0{\b Remarks}\par\li180	
If no table is provided, the general error message provides the number of
 tables containing merge conflicts.  Any table can be passed in, but all other
 columns must be nullable as the operation to update the error table will fail
 if a column is not nullable.  A newly created table can be passed in as well
 since the MergeDatabase method will automatically create the columns it uses if
 merge conflicts are found.  Three columns are used for presenting merge conflicts.
  The first column is the table's name.  It's also the primary key column.  Column
 two is the number of rows of that table that had merge failures.  Column three is
 a temporary column that is not persisted/saved.  It contains the reference to the table
 that can be obtained by cursor.ObjectData on that column and then asking for the iidMsiTable
 interface.  This reference enables one to go through the table and output those rows where
 merge failures occurred [using iraMergeFailed bit.]  If this is not done, that bit for that
 row will be cleared, as the iraMergeFailed bit is not a persistent bit.  It should be noted
 that Column three is not a persistent column, so upon commitance of the database that contains
 this table, only column one and column two will remain.
 \par
If tables of the same name in both databases do not match in the number of
 primary keys, the column types, the number of columns, or the column names, 
 the MergeDatabase method will fail, and will post an error message pertaining to which mismatch 
 occurred.
 \par
For the error table to remain, the error handler must commit the database to which the error table 
 belongs.  However, this commit should be done after using the third column to obtain the references 
 to those tables where merge conflicts occurred.  When the database is committed, the third column will 
 be lost as it is not a persistent column since it temporarily stores an object [the reference to 
 the table].
\page


#{\footnote MsiDatabase_UpdateState}
${\footnote MsiDatabase.UpdateState}
+{\footnote MsiDatabase:UpdateState}
K{\footnote UpdateState}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
UpdateState Property
\line\tx360\tab\fs18\b0{\uldb MsiDatabase Object}{\v MsiDatabase_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Returns the current persistence state of the database, as one of enum idsEnum:
\line{\f1  idsRead     = 0} database open read-only, changes are not saved
\line{\f1  idsWrite    = 1} database fully operational for read and write
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .UpdateState}
\par{\i object}\line
Required. The MsiDatabase object.
\page

#{\footnote MsiDatabase_ANSICodePage}
${\footnote MsiDatabase.ANSICodePage}
+{\footnote MsiDatabase:ANSICodePage}
K{\footnote ANSICodePage; codepage}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
ANSICodePage Property
\line\tx360\tab\fs18\b0{\uldb MsiDatabase Object}{\v MsiDatabase_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Returns the ANSI codepage of the current database, 0 if language neutral
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .ANSICodePage}
\par{\i object}\line
Required. The MsiDatabase object.
\par\fi0\li0{\b Remarks}\par\li180	
The string data in a persisted database is stored in a single codepage,
 in order to support Win9x and to optimize storage. If the strings have no extended
 characters, then the codepage is defaulted to 0, language-neutral. Table import,
 merge, or transform operations will set a neutral database to any non-neutral merged data,
 and will be rejected if a codepage conflict occurs.
\page

#{\footnote MsiDatabase_Storage}
${\footnote MsiDatabase.Storage}
+{\footnote MsiDatabase:Storage}
K{\footnote Storage}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Storage Property
\line\tx360\tab\fs18\b0{\uldb MsiDatabase Object}{\v MsiDatabase_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Returns the designated MsiStorage object if present, else returns an empty (Nothing) object,
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .Storage({\i index})}
\par{\i object}\line
Required. The MsiDatabase object.
\par{\i\b index}\line
Required. An integer designating which storage to return.
\line{\f1  0} The output database storage if
  {\uldb CreateOutputDatabase}{\v MsiDatabase_CreateOutputDatabase} succeeded.
\line{\f1  1} The original storage if the database was created from an MsiStorage
 or from an MSI database file.
\line{\f1 >1} Auxiliary storages used for transforms (not implemented yet).
\page

#{\footnote MsiView_Object}
${\footnote MsiView Object}
K{\footnote MsiView; MsiDatabase}
+{\footnote Class:MsiView}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
MsiView Object
\line\fs18\b0\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
This object represents a result set obtained processing a query using the
 MsiDatabase method {\uldb OpenView}{\v MsiDatabase_OpenView}.
 Before any data can be transferred the query must be executed
 using the {\uldb Execute}{\v MsiView_Execute} method, passing to it
 all replaceable parameters designated within the SQL query string.
 The query may be reexecuted, with different parameters if desired,
 but only after freeing the result set either by fetching all the
 records or by calling the {\uldb Close}{\v MsiView_Close} method.
 The data transfer methods will fail if the corresponding intent flags
 were not specified in the {\uldb OpenView}{\v MsiDatabase_OpenView} call.  
\par\li0{\b Methods}\par\li180
{\uldb Execute}{\v MsiView_Execute}\line
{\uldb Fetch}{\v MsiView_Fetch}\line
{\uldb GetColumnNames}{\v MsiView_GetColumnNames}\line
{\uldb GetColumnTypes}{\v MsiView_GetColumnTypes}\line
{\uldb Update}{\v MsiView_Update}\line
{\uldb Insert}{\v MsiView_Insert}\line
{\uldb Delete}{\v MsiView_Delete}\line
{\uldb Modify}{\v MsiView_Modify}\line
{\uldb Close}{\v MsiView_Close}\line
{\uldb GetError}{\v MsiView_GetError}\line
\par\li0{\b Properties}\par\li180
{\uldb FieldCount}{\v MsiView_FieldCount}\line
{\uldb RowCount}{\v MsiView_RowCount}\line
{\uldb State}{\v MsiView_State}\line
\page

#{\footnote MsiView_Execute}
${\footnote MsiView.Execute}
+{\footnote MsiView:Execute}
K{\footnote Execute}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Execute Method
\line\tx360\tab\fs18\b0{\uldb MsiView Object}{\v MsiView_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Accepts replaceable query parameters and executes the database query,
 producing a result set that can be fetched or updated.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .Execute {\i record}}
\par{\i object}\line
Required. The MsiView object.
\par{\i\b record}\line
Optional. MsiRecord objects containing values to replace parameter markers,
 "?", in the SQL query.
\par\fi0\li0{\b Remarks}\par\li180
This method must be called before any calls to {\uldb Fetch}{\v MsiView_Fetch}.
 If the SQL query specifies values in the predicate expression with parameter
 markers (question marks), then a record must be supplied containing all of
 the replacement values in the exact order and of compatible data types.
\page

#{\footnote MsiView_FieldCount}
${\footnote MsiView.FieldCount}
+{\footnote MsiView:FieldCount}
K{\footnote FieldCount}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
FieldCount Property
\line\tx360\tab\fs18\b0{\uldb MsiView Object}{\v MsiView_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
A long indicating the number of columns the will be fetched into MsiRecord fields.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .FieldCount}
\par{\i object}\line
Required. The MsiView object.
\page

#{\footnote MsiView_RowCount}
${\footnote MsiView.RowCount}
+{\footnote MsiView:RowCount}
K{\footnote RowCount}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
RowCount Property
\line\tx360\tab\fs18\b0{\uldb MsiView Object}{\v MsiView_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
A long indicating the number of rows affected by MsiView.Execute.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .RowCount}
\par{\i object}\line
Required. The MsiView object.
\par\fi0\li0{\b Remarks}\par\li180
Should be called only after the MsiView.Execute and before a MsiView.Close.
Would return error otherwise
\page

#{\footnote MsiView_State}
${\footnote MsiView.State}
+{\footnote MsiView:State}
K{\footnote State}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
State Property
\line\tx360\tab\fs18\b0{\uldb MsiView Object}{\v MsiView_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
A long indicating the current cursor state for the MsiView object. Is one of \line
{\b dvcsClosed}\line
The MsiView object is currently in the state closed.\line
{\b dvcsPrepared}\line
The MsiView object has been prepared i.e. the SQL query has been parsed. \line
{\b dvcsExecuted}\line 
Internal use only.\line 
{\b dvcsBound}\line 
Parameters to the SQL query, if any have been bound to the SQL query. 
This is the state before the first Fetch. (The MsiView::Execute() function has been executed).\line
{\b dvcsFetched}\line 
Atleast one record has been successfully fetched from the MsiView object (via the MsiView::Fetch() function).\line
{\b dvcsDestructor}\line
Internal use only.\line 

\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .RowCount}
\par{\i object}\line
Required. The MsiView object.
\par\fi0\li0{\b Remarks}\par\li180
\page

#{\footnote MsiView_Fetch}
${\footnote MsiView.Fetch}
+{\footnote MsiView:Fetch}
K{\footnote Fetch}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Fetch Method
\line\tx360\tab\fs18\b0{\uldb MsiView Object}{\v MsiView_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Returns an MsiRecord object containing the requested column data if more rows
 are available in the result set, else returns an object of value Nothing.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .Fetch}
\par{\i object}\line
Required. The MsiView object.
\par\fi0\li0{\b Remarks}\par\li180
This method must be called after {\uldb Execute}{\v MsiView_Execute}.
 For maximum performance, the same record object should be used for all fetches,
 or else it should be released by going out of scope. The returned record can
 be tested for the end of the result set using the syntax:
 "If FetchRecord Is Nothing".
\page

#{\footnote MsiView_GetColumnNames}
${\footnote MsiView.GetColumnNames}
+{\footnote MsiView:GetColumnNames}
K{\footnote GetColumnNames}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
GetColumnNames Method
\line\tx360\tab\fs18\b0{\uldb MsiView Object}{\v MsiView_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Returns an MsiRecord object containing the columns names corresponding to the fetched record fields.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .GetColumnNames}
\par{\i object}\line
Required. The MsiView object.
\page

#{\footnote MsiView_GetColumnTypes}
${\footnote MsiView.GetColumnTypes}
+{\footnote MsiView:GetColumnTypes}
K{\footnote GetColumnTypes}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
GetColumnTypes Method
\line\tx360\tab\fs18\b0{\uldb MsiView Object}{\v MsiView_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Returns an MsiRecord objects with text fields containing the data types of
 the corresponding database columns, in the 
 {\b\uldb Archive File Format}{\v Table_ArchiveFormat} used by ExportTable.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .GetColumnTypes}
\par{\i object}\line
Required. The MsiView object.
\par\fi0\li0{\b Remarks}\par\li180
\page

#{\footnote MsiView_Update}
${\footnote MsiView.Update}
+{\footnote MsiView:Update}
K{\footnote Update}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Update Method
\line\tx360\tab\fs18\b0{\uldb MsiView Object}{\v MsiView_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Updates a database row with a modified MsiRecord object obtained by the Fetch method.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .Update {\i record}}
\par{\i object}\line
Required. The MsiView object.
\par{\i\b record}\line
Required. The MsiRecord object obtained by the Fetch method, with modified field data.
\par\fi0\li0{\b Remarks}\par\li180
Only the record fields that have been updated will be written to the database.
 Thus multiple threads can update the same rows independently as long as they
 have modified different database columns.
\page

#{\footnote MsiView_Insert}
${\footnote MsiView.Insert}
+{\footnote MsiView:Insert}
K{\footnote Insert}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Insert Method
\line\tx360\tab\fs18\b0{\uldb MsiView Object}{\v MsiView_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Inserts a new row into the database with values in an MsiRecord object.
 This method will fail if the primary key columns contain any Null
 values or as a group match any existing row in the table.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .Insert {\i record}}
\par{\i object}\line
Required. The MsiView object.
\par{\i\b record}\line
Required. An MsiRecord object containing values for a new database row.
\par\fi0\li0{\b Remarks}\par\li180
The values in the record fields must match the query specification in sequence
 and in data types (same as would be obtained by the Fetch method). Null values
 may be supplied in the record fields as long as they are not part of the primary key.
\page

#{\footnote MsiView_Delete}
${\footnote MsiView.Delete}
+{\footnote MsiView:Delete}
K{\footnote Delete}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Delete Method
\line\tx360\tab\fs18\b0{\uldb MsiView Object}{\v MsiView_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Removes the row corresponding the MsiRecord just obtained with the Fetch method.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .Delete {\i record}}
\par{\i object}\line
Required. The MsiView object.
\par{\i\b record}\line
Required. The MsiRecord object obtained by the Fetch method.
\par\fi0\li0{\b Remarks}\par\li180
This method will fail if the primary key fields are modified, or if the primary
 key no longer exists in the database.
\page

#{\footnote MsiView_Modify}
${\footnote MsiView.Modify}
+{\footnote MsiView:Modify}
K{\footnote Modify}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Modify Method
\line\tx360\tab\fs18\b0{\uldb MsiView Object}{\v MsiView_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Modifies a database row with a modified MsiRecord object obtained by the Fetch method.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .Modify {\i record} {\i action}}
\par{\i object}\line
Required. The MsiView object.
\par{\i\b record}\line
Required. The MsiRecord object obtained by the Fetch method, with modified field data.
\par{\i\b action}\line
Required. Indicates the action to be performed on the database row. The operation map on to one with the modification 
operation that can be performed on the {\uldb MsiCursor}{\v MsiCursor_Object} object. Is one of - \line
\line
{\b irmSeek}\line
Completes the record data.  Seek requires that the primary key fields be filled in and then fills in the rest of the data,
 allowing one to seek to a particular entry in the table (instead of having to fetch and compare).  The record must contain
 all columns of the table.  Corresponds to the {\uldb MsiCursor.Seek}{\v MsiCursor_Seek} operation.  One can Insert/Update/Delete
 the record after seeking.\line
{\b irmInsert}\line
Inserts the information into the database table. The operation does not require a {\uldb MsiView.Fetch}{\v MsiView_Fetch} to have been 
performed before its calling. The function will fail if a row with the same primary key(s) exist in the table. 
Corresponds to the {\uldb MsiCursor.Insert}{\v MsiCursor_Insert} operation.  The database must be open for modification. \line
{\b irmInsertTemporary}\line
Temporarily inserts the information into the database table. The operation does not require a {\uldb MsiView.Fetch}{\v MsiView_Fetch} to have been 
performed before its calling and the database does not have to be open for modification. The function will fail if a row with the same primary key(s) exist in the table. 
Corresponds to the {\uldb MsiCursor.InsertTemporary}{\v MsiCursor_InsertTemporary} operation \line
{\b irmUpdate}\line
Updates the information already existing in the database allowing modification of non-primary keys only. The operation does not require a {\uldb MsiView.Fetch}{\v MsiView_Fetch}  to have been 
performed before its calling and has to be called with the same record as that returned by the fetch. The function will fail if the row has been deleted from the table. 
Corresponds to the {\uldb MsiCursor.Update}{\v MsiCursor_Update} operation.  Requires that the database be open for modification. Update can occur on a fetched,
 inserted, or deleted record.\line
{\b irmDelete}\line
Deletes the information already existing in the database (that is open for modification). The operation does not require a {\uldb MsiView.Fetch}{\v MsiView_Fetch}  to have been 
performed before its calling and has to be called with the same record as that returned by the fetch. The function will fail if the row has been deleted from the table. 
Corresponds to the {\uldb MsiCursor.Delete}{\v MsiCursor_Delete} operation.  Delete can be done on a fetched, inserted, or seeked record. \line
{\b irmRefresh}\line
Refreshes the information in the record from the database. The operation requires a {\uldb MsiView.Fetch}{\v MsiView_Fetch}  to have been 
performed before its calling and has to be called with the same record as that returned by the fetch. The function will fail if the row has been deleted from the table. 
Corresponds to the {\uldb MsiCursor.Refresh}{\v MsiCursor_Refresh} operation \line
{\b irmAssign}\line
Inserts/updates the information into the database table. The operation does not require a {\uldb MsiView.Fetch}{\v MsiView_Fetch} to have been 
performed before its calling.  An update operation takes place if primary keys match an existing row. An insert operation takes place if primary 
keys do not match any row. In either case the current data in the cursor are written to a table row. 
Corresponds to the {\uldb MsiCursor.Assign}{\v MsiCursor_Assign} operation. Requires that the database be open for modification.\line
{\b irmMerge}\line
Inserts/validates the information into the database table. The operation does not require a {\uldb MsiView.Fetch}{\v MsiView_Fetch} to have been 
performed before its calling. An insert operation takes place if primary keys do not match any row. A validation operation takes place if primary 
keys match an existing row. The operation fails if the record data does not match the data in the table. Corresponds to the {\uldb MsiCursor.Merge}{\v MsiCursor_Merge} operation.
Requires that the database be open for modification. \line
{\b irmReplace}\line
Updates/Delete-Inserts the information into the database table. The operation requires a {\uldb MsiView.Fetch}{\v MsiView_Fetch} to have been 
performed before its calling and has to be called with the same record as that returned by the fetch. If the primary key(s) have not been 
changed then an update of the table row occurs. If the primary key(s) have been changed the old table row is deleted and a new row corresponding 
to the record is inserted. Corresponds to the {\uldb MsiCursor.Replace} operation.  Requires that the database be open for modification. \line
{\b irmValidate}\line
Validates a record.  Will not validate across joins. The operation requires a {\uldb MsiView.Fetch}{\v MsiView_Fetch} performed before its calling and has to be called with
 the same record as that returned by the fetch.  Validation errors can be obtained by subsequent callings to {\uldb MsiView.GetError}{\ MsiView_GetError}.
 Corresponds to the {\uldb MsiCursor.Validate}{\v MsiCursor_Validate} operation passing in 0 as the value for iCol.\line
{\b irmValidateNew}\line
Validates a record as a new record.  Requires the database to be open for modification. Will not validate across joins. This differs from irmValidate in that it checks for duplicate keys.  The operation requires that
 {\uldb MsiDatabase.OpenView}{\v MsiDatabase_OpenView} be called with a modify value.  Validation errors can be obtained by
 subsequent callings to {\uldb MsiView.GetError}{\v MsiView_GetError}.  Corresponds to the {\uldb MsiCursor.Validate}{\v MsiCursor_Validate}
 operation passing in -1 as the value for iCol.\line
{\b irmValidateField}\line
Validates a field(s) of a fetched or new record.  Will not validate across joins. The validation depends upon the number of fields in the record.  If only one field exists,
 it will validate the one field.  It can also validate more fields.  It should be used when the fetched/new record does not represent every
 column of the table. Makes repeated calls to {\uldb MsiCursor.Validate}{\v MsiCursor_Validate} depending upon the number of fields in the record.\line
{\b irmValidateDelete}\line
Validates a fetched record.  Will not validate across joins. The validation depends upon the _Validation table and in particular the 'KeyTable' and 'KeyColumn'
 columns of the table.  Validate delete returns an error if a row in the same table or another table explicitly references the primary
 key(s) of the row to be deleted.  It requires that the database be open for modification and the operation requires a {\uldb MsiView.Fetch}{\v MsiView_Fetch} performed before its calling and has to be called with
 the same record as that returned by the fetch. Corresponds to the {\uldb MsiCursor.Validate}{\v MsiCursor_Validate} operation passing in a -2 as the value for iCol.\line
\par\fi0\li0{\b Remarks}\par\li180
\page

#{\footnote MsiView_Close}
${\footnote MsiView.Close}
+{\footnote MsiView:Close}
K{\footnote Close}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Close Method
\line\tx360\tab\fs18\b0{\uldb MsiView Object}{\v MsiView_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Terminates query execution and releases database resources.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .Close}
\par{\i object}\line
Required. The MsiView object.
\par\fi0\li0{\b Remarks}\par\li180
This method must be called before the Execute method is called again on the
 MsiView object, unless all rows of the result set have been obtained with the
 Fetch method. It will be called internally when the view is destroyed.
\page

#{\footnote MsiView_GetError}
${\footnote MsiView.GetError}
+{\footnote MsiView:GetError}
K{\footnote GetError}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
GetError Method
\line\tx360\tab\fs18\b0{\uldb MsiView Object}{\v MsiView_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Returns the Validation error and the column name for which the error occured.  In automation,
 the return is a string of the form ColumnName,Error.  It returns the first error it finds in
 the view's error array.  So, once a return of ColumnName,0 [zero does not show up in automation],
 no more errors exist.  See {\uldb MsiCursor_Validate}{\v MsiCursor_Validate} for error enums.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .GetError}
\par{\i object}\line
Required. The MsiView object.
\par\fi0\li0{\b Remarks}\par\li180
\page

#{\footnote MsiTable_Object}
${\footnote MsiTable Object}
K{\footnote MsiTable}
+{\footnote Class:MsiTable}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
MsiTable Object
\par}\li180
This object represents a database table loaded into memory and is accessed by a
 very efficient internal query engine. The table may be an image of a persistent
 table with option temporary columns added, or may be totally composed of
 temporary columns. If column names are not supplied, they are not accessible for
 joins or by SQL. To access table data, an {\uldb MsiCursor}{\v MsiCursor_Object}
 object is created that can be positioned sequentially or can seek to a particular
 set of data values. The cursor seek operation will be slower when the search values
 do not include the primary key columns. When a cursor object is created or when its Reset
 method is called, it will be logically positioned just before the first table row.
 The Next method always moves forward from the current cursor position. If a
 table is linked as a tree, a tree-walking cursor can be created that will advance 
 to the next node in a depth-first traversal.
\par Persistent tables are normally loaded into memory when a table object is created
 and removed from memory when the last reference to the table object is released.
 The LockTable function is used to keep a frequently used table in memory
 independently of reference counts. As long as the lock calls are greater than
 the unlock calls, the table remains in memory until the database is closed.
\par For performance reasons, strings are not stored in the table data. Rather,
 integer indices are stored which reference a common string pool maintained by
 the database. Internally, string uses are reference counted as part of the string
 management. Functions are provided in the {\uldb MsiDatabase}{\v MsiDatabase_Object}
 object to convert strings to and from string indices. A string index of 0 indicates
 a Null string value.
\par\li0{\b Properties}\par\li180
{\uldb Database}{\v MsiTable_Database}\line
{\uldb RowCount}{\v MsiTable_RowCount}\line
{\uldb ColumnCount}{\v MsiTable_ColumnCount}\line
{\uldb PrimaryKeyCount}{\v MsiTable_PrimaryKeyCount}\line
{\uldb ReadOnly}{\v MsiTable_ReadOnly}\line
{\uldb ColumnName}{\v MsiTable_ColumnName}\line
{\uldb ColumnType}{\v MsiTable_ColumnType}\line
\par\li0{\b Methods}\par\li180
{\uldb GetColumnIndex}{\v MsiTable_GetColumnIndex}\line
{\uldb CreateColumn}{\v MsiTable_CreateColumn}\line
{\uldb CreateCursor}{\v MsiTable_CreateCursor}\line
{\uldb LinkTree}{\v MsiTable_LinkTree}\line
\page

#{\footnote MsiTable_Database}
${\footnote MsiTable.Database}
+{\footnote MsiTable:Database}
K{\footnote DATABASE}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Database Property
\line\tx360\tab\fs18\b0{\uldb MsiTable Object}{\v MsiTable_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Returns the {\uldb MsiDatabase object}{\v MsiDatabase_Object} that owns this table.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .Database}
\par{\i object}\line
Required. The MsiTable object.
\page

#{\footnote MsiTable_RowCount}
${\footnote MsiTable.RowCount}
+{\footnote MsiTable:RowCount}
K{\footnote RowCount}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
RowCount Property
\line\tx360\tab\fs18\b0{\uldb MsiTable Object}{\v MsiTable_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Returns the number of rows that are currently contained in the table.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .RowCount}
\par{\i object}\line
Required. The MsiTable object.
\page

#{\footnote MsiTable_ColumnCount}
${\footnote MsiTable.ColumnCount}
+{\footnote MsiTable:ColumnCount}
K{\footnote ColumnCount}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
ColumnCount Property
\line\tx360\tab\fs18\b0{\uldb MsiTable Object}{\v MsiTable_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Returns the number of columns defined in the table.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .ColumnCount}
\par{\i object}\line
Required. The MsiTable object.
\page

#{\footnote MsiTable_PrimaryKeyCount}
${\footnote MsiTable.PrimaryKeyCount}
+{\footnote MsiTable:PrimaryKeyCount}
K{\footnote PrimaryKeyCount}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
PrimaryKeyCount Property
\line\tx360\tab\fs18\b0{\uldb MsiTable Object}{\v MsiTable_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Returns the number of columns that comprise the primary key for the table.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .PrimaryKeyCount}
\par{\i object}\line
Required. The MsiTable object.
\page

#{\footnote MsiTable_ReadOnly}
${\footnote MsiTable.ReadOnly}
+{\footnote MsiTable:ReadOnly}
K{\footnote ReadOnly}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
ReadOnly Property
\line\tx360\tab\fs18\b0{\uldb MsiTable Object}{\v MsiTable_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Returns a boolean, True if table is not updatable, False if
 the table can be updated provided the database is not read-only.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .ReadOnly({column})}
\par{\i object}\line
Required. The MsiTable object.
\page

#{\footnote MsiTable_ColumnName}
${\footnote MsiTable.ColumnName}
+{\footnote MsiTable:ColumnName}
K{\footnote ColumnName}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
ColumnName Property
\line\tx360\tab\fs18\b0{\uldb MsiTable Object}{\v MsiTable_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Returns the string index for the name of the designated column,
 or 0 if the column does not exist or if it has no name.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .ColumnName({column})}
\par{\i object}\line
Required. The MsiTable object.
\par{\i\b column}\line
Required. Column index, 1-based.
\par\fi0\li0{\b Remarks}\par\li180
The string index may be converted to the corresponding string using the
 {\b MsiDatabase} method {\uldb DecodeString}{\v MsiDatabase_DecodeString}.
\page

#{\footnote MsiTable_ColumnType}
${\footnote MsiTable.ColumnType}
+{\footnote MsiTable:ColumnType}
K{\footnote ColumnType}
K{\footnote itdShort;itdLong;itdObject;itdString}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
ColumnType Property
\line\tx360\tab\fs18\b0{\uldb MsiTable Object}{\v MsiTable_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Returns the column definition for the designated column, as an integer containing bit flags:
\line{\f1  icdObject     } some type of object if 1, else integer if 0
\line{\f1  icdShort      } if icdObject: 1=string, 0=other object; else 1=16-bit integer, 0=32-bit integer
\line{\f1  icdPersistent } persistent column if 1 (objects are streams), temporary if 0
\line{\f1  icdNullable   } if 1, column will accept null values
\line{\f1  icdPrimaryKey } if 1, column comprises part of primary key
\line The SQL data width for persistent columns is returned in the lower 8 bits (AND with 255).
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .ColumnType({\i column})}
\par{\i object}\line
Required. The MsiTable object.
\par{\i\b column}\line
Required. Column index, 1-based.
\par\fi0\li0{\b Remarks}\par\li180
Three types of objects, all derived from MsiData, can be stored:
\line  Strings stored as indices into the string pool, icdObject+icdShort
\line  Persistent stream objects, accessible via MsiCursor.StreamData, icdObject+icdPersistent
\line  Other objects derived from MsiData, accessible via MsiCursor.ObjectData, icdObject
\page

#{\footnote MsiTable_GetColumnIndex}
${\footnote MsiTable.GetColumnIndex}
+{\footnote MsiTable:GetColumnIndex}
K{\footnote GetColumnIndex}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
GetColumnIndex Method
\line\tx360\tab\fs18\b0{\uldb MsiTable Object}{\v MsiTable_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Returns the column number for a column name supplied as a string index.
 Returns 0 if the column name does not exist for the table.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .GetColumnIndex({\i nameIndex})}
\par{\i object}\line
Required. The MsiTable object.
\par{\i\b nameIndex}\line
Required. The database string index for column name.
\par\fi0\li0{\b Remarks}\par\li180
Use the MsiDatabase method {\uldb EncodeString}{\v MsiDatabase_EncodeString}
 to convert a string into a string index. This method returns 0 if the column
 name does not exist in the table, or if the string index is 0.
\page

#{\footnote MsiTable_CreateColumn}
${\footnote MsiTable.CreateColumn}
+{\footnote MsiTable:CreateColumn}
K{\footnote CreateColumn}
K{\footnote itdShort;itdLong;itdObject;itdString}
K{\footnote itcPrimaryKey;itcNullable;itcNoNulls}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
CreateColumn Method
\line\tx360\tab\fs18\b0{\uldb MsiTable Object}{\v MsiTable_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
 Defines column parameters for a new column for an MsiTable object created with
 {\uldb CreateTable}{\v MsiDatabase_CreateTable} or
 {\uldb LoadTable}{\v MsiDatabase_LoadTable}.
 Returns the column number for the created column if successful.
 Fails if the column could not be created or if the a column by the same name already exists.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .CreateColumn({\i columnDef, name})}
\par{\i object}\line
Required. The MsiTable object.
\par{\i\b columnDef}\line
Required. The column attributes, an integer combination of the values below.
\line The datatype of the column, comprising the bit flags icdObject and icdShort:
\line{\f1  icdLong     } 32-bit integer value (icdLong = 0, for readability only)
\line{\f1  icdShort    } 16-bit integer value, for persistent integer columns
\line{\f1  icdObject   } MsiData object (non-persistent), MsiStream (persistent)
\line{\f1  icdString   } string, stored as index to database string cache (icdObject+icdShort)
\line Column characteristics:
\line{\f1  icdPrimaryKey   } column is part of primary key
\line{\f1  icdNullable     } column will accept null values
\line{\f1  icdNoNulls      } value required (icdNoNulls = 0, for readability only)
\line Persistence:
\line{\f1  icdPersistent   } column saved in persistent database
\line{\f1  icdTemporary    } temporary column (icdTemporary = 0, for readability only)
\line SQL column width in bytes, a number between 0 and 255, persistent columns only
\par{\i\b name}\line
Optional. Column name, unique within the table. Persistent columns must be
 given a name. Anonymous columns cannot be accessed via SQL queries.
\par\fi0\li0{\b Remarks}\par\li180
All persistent columns must be defined before any non-persistent columns.
 At least one column must be designated as the primary key column,
 and the primary key columns must be the first columns in the table,
 with the most-significant columns first.
 Persistent columns cannot contain object references, but may contain binary streams.
 Avoid 32-bit integers when possible for persistent columns, as the storage is inefficient.
 Use 32-bit integers for termporary columns, as there is no bounds checking.
 Persistent primary key columns cannot accept the icdNullable attribute.
 Each row in the table must have a unique set of primary key values.
 A maximum of 32 columns may be defined for a database table.
 The number of rows is limited by the available memory.
\page

#{\footnote MsiTable_CreateCursor}
${\footnote MsiTable.CreateCursor}
+{\footnote MsiTable:CreateCursor}
K{\footnote CreateCursor}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
CreateCursor Method
\line\tx360\tab\fs18\b0{\uldb MsiTable Object}{\v MsiTable_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Returns an {\uldb MsiCursor}{\v MsiCursor_Object} object that is in the reset state.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .CreateCursor({\i tree})}
\par{\i object}\line
Required. The MsiTable object.
\par{\b\i tree}\line
Optional. Boolean indicating whether to create a tree-walking cursor. A True value
 will create a cursor that will walk a tree-linked table in tree traversal order,
 whereas a False, or missing, value will create a normal cursor that will advance by row order.
 The two types behave identically if the table is not tree-linked.
\par\fi0\li0{\b Remarks}\par\li180
To avoid excessive processing, mimimize the number of active cursors on a table
 that is subject to frequent row insertions and deletions.
\page

#{\footnote MsiTable_LinkTree}
${\footnote MsiTable.LinkTree}
+{\footnote MsiTable:LinkTree}
K{\footnote LinkTree}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
LinkTree Method
\line\tx360\tab\fs18\b0{\uldb MsiTable Object}{\v MsiTable_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Links the table in depth-first tree-traveral order to support a tree-walking cursor.
 If the tree cannot be fully resolved the method will fail, returning -1.
 If the method succeeds, the number of tree roots will be returned (a return value of
 0 indicates that the table is empty). A row parented to itself or having a Null parent
 indicates a root node.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .LinkTree({\i parentColumn})}
\par{\i object}\line
Required. The MsiTable object.
\par{\b\i parentColumn}\line
Required. The column number specifying the tree parent data. This column
 must contain values referencing the single primary key column of the table.
\par\fi0\li0{\b Remarks}\par\li180
 This method requires that the primary key be composed of a single column.
 The method will fail if any of the values in the specified column do not match
 a primary key value currently in the table. Once the table is linked, only leaf
 node rows may be deleted (those that are not the parent of another row). Rows
 may be inserted, provided that their parent values are present in the table.
 Specifying a parentColumn value of zero will unlink the table, and all cursors
 will then advance sequentially through the rows.
\page

#{\footnote MsiCursor_Object}
${\footnote MsiCursor Object}
K{\footnote MsiCursor}
+{\footnote Class:MsiCursor}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
MsiCursor Object
\par}\li180
To access table data, an MsiCursor object is created that can be positioned
 sequentially or can seek to a particular set of data values. The cursor
 seek operation will be slower when table's primary key columns are not specified.
 When a cursor object is created or when its Reset method is called,
 or when the Next method fails to find a qualifying row, it will be
 logically positioned just before the first table row. The Next method always
 moves forward from the current cursor position. If a table is linked as a tree,
 a cursor can be created that advances to the next node in a depth-first traversal.
\par
The cursor contains a snapshot of a table row, and its data is transferred
 to and from the table as an atomic operation. On update, only columns with
 changed data will be transferred, thus allowing other columns to be updated
 via other cursor objects.
\par\li0{\b Properties}\par\li180
{\uldb Table}{\v MsiCursor_Table}\line
{\uldb Filter}{\v MsiCursor_Filter}\line
{\uldb IntegerData}{\v MsiCursor_IntegerData}\line
{\uldb StringData}{\v MsiCursor_StringData}\line
{\uldb DateData}{\v MsiCursor_DateData}\line
{\uldb ObjectData}{\v MsiCursor_ObjectData}\line
{\uldb StreamData}{\v MsiCursor_StreamData}\line
{\uldb RowState}{\v MsiCursor_RowState}\line
{\uldb Moniker}{\v MsiCursor_Moniker}\line
\par\li0{\b Methods}\par\li180
{\uldb PutNull}{\v MsiCursor_PutNull}\line
{\uldb Reset}{\v MsiCursor_Reset}\line
{\uldb Next}{\v MsiCursor_Next}\line
{\uldb Update}{\v MsiCursor_Update}\line
{\uldb Insert}{\v MsiCursor_Insert}\line
{\uldb InsertTemporary}{\v MsiCursor_InsertTemporary}\line
{\uldb Assign}{\v MsiCursor_Assign}\line
{\uldb Replace}{\v MsiCursor_Replace}\line
{\uldb Merge}{\v MsiCursor_Merge}\line
{\uldb Refresh}{\v MsiCursor_Refresh}\line
{\uldb Delete}{\v MsiCursor_Delete}\line
{\uldb Seek}{\v MsiCursor_Seek}\line
{\uldb Validate}{\v MsiCursor_Validate}\line
\page

#{\footnote MsiCursor_IntegerData}
${\footnote MsiCursor.IntegerData}
+{\footnote MsiCursor:IntegerData}
K{\footnote IntegerData}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
IntegerData Property
\line\tx360\tab\fs18\b0{\uldb MsiCursor Object}{\v MsiCursor_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Transfers integer data to or from a column value in the cursor object. Read-write.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .IntegerData({\i column})}
\par{\i object}\line
Required. The MsiCursor object.
\par{\i\b column}\line
Required. Column index, 1-based.
\par\fi0\li0{\b Remarks}\par\li180
A null value in an integer column will be returned as the defined constant {\f1 iMsiNullInteger}.
 If the column is designated as a primary key or a non-null column, attempting
 to set its value to {\f1 iMsiNullInteger} will produce an error.
\par The IntegerData property will transfer data of all types as integers.
 This method will fail if the column is type itdShort and the integers is outside the 16-bit range.
 String data will be transferred using the database string index, and object data
 will transferred as an integer containing the actual address of the object. Care must
 exercised when passing objects as integers, as no validation can be done at this
 low level. The integer returned for an object is not reference counted, but when an
 object is set into the cursor using an integer, its AddRef method is called because
 the cursor, and ultimately the database table, is keeping a copy of that pointer.
 A null value for a non-integer column returned as an integer will be zero.
\page

#{\footnote MsiCursor_StringData}
${\footnote MsiCursor.StringData}
+{\footnote MsiCursor:StringData}
K{\footnote StringData}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
StringData Property
\line\tx360\tab\fs18\b0{\uldb MsiCursor Object}{\v MsiCursor_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Transfers string data to or from a string column value in the cursor object. Read-write.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .StringData({\i column})}
\par{\i object}\line
Required. The MsiCursor object.
\par{\i\b column}\line
Required. Column index, 1-based.
\par\fi0\li0{\b Remarks}\par\li180
Setting StringData property on a non-string column will fail.
 Returning the property on a non-string column will return an empty string.
\page

#{\footnote MsiCursor_DateData}
${\footnote MsiCursor.DateData}
+{\footnote MsiCursor:DateData}
K{\footnote DateData}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
DateData Property
\line\tx360\tab\fs18\b0{\uldb MsiCursor Object}{\v MsiCursor_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Transfers date/time data to or from a string or long integer column value in the
 cursor object. Read-write.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .DateData({\i column})}
\par{\i object}\line
Required. The MsiCursor object.
\par{\i\b column}\line
Required. Column index, 1-based.
\par\fi0\li0{\b Remarks}\par\li180
Returning the property on a non-date value may fail or return an invalid date.
\page

#{\footnote MsiCursor_ObjectData}
${\footnote MsiCursor.ObjectData}
+{\footnote MsiCursor:ObjectData}
K{\footnote ObjectData}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
ObjectData Property
\line\tx360\tab\fs18\b0{\uldb MsiCursor Object}{\v MsiCursor_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Transfers object references to or from a column value in the cursor object. Read-write.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .ObjectData({\i column})}
\par{\i object}\line
Required. The MsiCursor object.
\par{\i\b column}\line
Required. Column index, 1-based.
\par\fi0\li0{\b Remarks}\par\li180
Objects stored in the database tables must be derived from the MsiData base object
 and cannot be stored in persistent columns. A Null value for an object has pointer
 value of zero, but is set and tested in BASIC using the {\f1\b1 Missing} keyword.
 If the column is designated as a primary key or a non-null column, attempting
 to set its value to a null object will produce an error. Objects are reference
 counted when stored in the MsiCursor and the MsiTable objects.
\page

#{\footnote MsiCursor_StreamData}
${\footnote MsiCursor.StreamData}
+{\footnote MsiCursor:StreamData}
K{\footnote StreamData}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
StreamData Property
\line\tx360\tab\fs18\b0{\uldb MsiCursor Object}{\v MsiCursor_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Transfers MsiStream objects to or from a column value in the cursor object. Read-write.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .StreamData({\i column})}
\par{\i object}\line
Required. The MsiCursor object.
\par{\i\b column}\line
Required. Column index, 1-based.
\par\fi0\li0{\b Remarks}\par\li180
This property may only be used with persistent columns typed as icdObject.
\page

#{\footnote MsiCursor_Table}
${\footnote MsiCursor.Table}
+{\footnote MsiCursor:Table}
K{\footnote Table}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Table Property
\line\tx360\tab\fs18\b0{\uldb MsiCursor Object}{\v MsiCursor_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Returns the {\uldb MsiTable object}{\v MsiTable_Object} that owns this cursor object.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .Table}
\par{\i object}\line
Required. The MsiCursor object.
\page

#{\footnote MsiCursor_Reset}
${\footnote MsiCursor.Reset}
+{\footnote MsiCursor:Reset}
K{\footnote Reset}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Reset Method
\line\tx360\tab\fs18\b0{\uldb MsiCursor Object}{\v MsiCursor_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Positions cursor before first row, and clears all data to Null.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .Reset}
\par{\i object}\line
Required. The MsiCursor object.
\par\fi0\li0{\b Remarks}\par\li180
Because the {\b Next} method always progresses forward
 through the data rows, {\b Reset} must be called first to insure
 that all rows are found. When inserting new rows, {\b Reset} may   
 be called on the cursor to clear any existing data 
 if the cursor is not in the reset state.
\page

#{\footnote MsiCursor_PutNull}
${\footnote MsiCursor.PutNull}
+{\footnote MsiCursor:PutNull}
K{\footnote PutNull}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
PutNull Method
\line\tx360\tab\fs18\b0{\uldb MsiCursor Object}{\v MsiCursor_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Sets the designated column value to the Null value appropriate for the data type.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .PutNull {\i column}}
\par{\i object}\line
Required. The MsiCursor object.
\par{\i\b column}\line
Required. Column index, 1-based.
\par\fi0\li0{\b Remarks}\par\li180
This method will fail unless the column has the icdNullable attribute.
\page

#{\footnote MsiCursor_Next}
${\footnote MsiCursor.Next}
+{\footnote MsiCursor:Next}
K{\footnote Next}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Next Method
\line\tx360\tab\fs18\b0{\uldb MsiCursor Object}{\v MsiCursor_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Positions this cursor to next database record in the table that matches the specified
 filter values. If not filter columns are designated, the next sequential record
 in primary key order will be returned. If the table is linked as a tree and a
 tree-walking cursor has been created, the cursor will advance in tree traveral order.
 Returns 0 if no more qualifying rows exist in the table, else returns the
 tree level of the new row, 1 if the table is not linked as a tree.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .Next}
\par{\i object}\line
Required. The MsiCursor object.
\par\fi0\li0{\b Remarks}\par\li180
The filter mask, set by the {\uldb Filter}{\v MsiCursor_Filter} property,
 designates columns in the cursor that contains values that must be matched.
 If the mask is non-zero, rows will be skipped if the designated columns
 contain data that does not match the values in the cursor.
\page

#{\footnote MsiCursor_Filter}
${\footnote MsiCursor.Filter}
+{\footnote MsiCursor:Filter}
K{\footnote Filter}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Filter Property
\line\tx360\tab\fs18\b0{\uldb MsiCursor Object}{\v MsiCursor_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
A long integer containing bit flags for all defined columns.
 Marks data columns in the MsiCursor object to be used to match corresponding
 data in the database table. Each bit in the filter corresponds to a database
 column, with the low order bit (value=1) corresponding to the first column.
 A value of zero removes all filter attributes from the columns. Read-write.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .Filter}
\par{\i object}\line
Required. The MsiCursor object.
\par\fi0\li0{\b Remarks}\par\li180
The Next method will skip over rows where the columns designated
 by the filter mask do not match those in the cursor. If the filter includes
 primary key columns, the search will be vastly improved because the
 table rows are sorted by primary key. If the cursor was created as a
 tree-walking cursor, it will advance to matching records in tree order, and
 it will be optimized if the filter includes the primary key.
\par\fi0\li0{\b Usage}\par\li180
In order to selectively filter rows in a table, the values to match must be set
 into the corresponding columns in the MsiCursor object. The corresponding bits
 must also be set in the filter mask to prevent fetching data into those columns.
 When the cursor is reset, or reaches the end of the table, all data is cleared,
 including the filter data, but the filter mask is not affected. To remove the
 filter mask, this property value must be set to zero.
\page

#{\footnote MsiCursor_RowState}
${\footnote MsiCursor.RowState}
+{\footnote MsiCursor:RowState}
K{\footnote RowState}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
RowState Property
\line\tx360\tab\fs18\b0{\uldb MsiCursor Object}{\v MsiCursor_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Allows individual row attributes in a table row to read read or set.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .RowState({\i attribute})}
\par{\i object}\line
Required. The MsiCursor object.
\par{\i\b attribute}\line
Required. The row attribute to be read or set, one of iraEnum.
\par{\i object}\line
\par\fi0\li0{\b Row attributes}\par\li180
!!Not finished!!
\par\fi0\li0{\b Remarks}\par\li180
!!Not finished!!
\page

#{\footnote MsiCursor_Update}
${\footnote MsiCursor.Update}
+{\footnote MsiCursor:Update}
K{\footnote Update}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Update Method
\line\tx360\tab\fs18\b0{\uldb MsiCursor Object}{\v MsiCursor_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Updates changed cursor data to the corresponding table row.
 Returns True if the row was successfully updated.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .Update}
\par{\i object}\line
Required. The MsiCursor object.
\par\fi0\li0{\b Remarks}\par\li180
The table row to update is determined by set of primary key values.
 If the primary key values to not match any existing row, the
 function will fail and return False.
\page

#{\footnote MsiCursor_Insert}
${\footnote MsiCursor.Insert}
+{\footnote MsiCursor:Insert}
K{\footnote Insert}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Insert Method
\line\tx360\tab\fs18\b0{\uldb MsiCursor Object}{\v MsiCursor_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Inserts a new table row using the current cursor data.
 The table must be writable for this method to succeed.
 Returns True if the row was successfully inserted.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .Insert}
\par{\i object}\line
Required. The MsiCursor object.
\par\fi0\li0{\b Remarks}\par\li180
The table row position is determined by the primary key values.
 If the primary key columns contain any Null values, or if the
 set of primary key values matches an existing row, the method
 will fail and return False. If the table is tree-linked, the inserted
 row will be linked into the tree as a leaf node under the row specified
 by its parent column (the column specified by {\uldb LinkTree}{\v MsiTable_LinkTree}).
\page

#{\footnote MsiCursor_InsertTemporary}
${\footnote MsiCursor.InsertTemporary}
+{\footnote MsiCursor:InsertTemporary}
K{\footnote InsertTemporary}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
InsertTemporary Method
\line\tx360\tab\fs18\b0{\uldb MsiCursor Object}{\v MsiCursor_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Inserts a new non-persistent table row using the current cursor data.
 This method may be called on tables loaded from a read-only database.
 Returns True if the row was successfully inserted.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .InsertTemporary}
\par{\i object}\line
Required. The MsiCursor object.
\par\fi0\li0{\b Remarks}\par\li180
See {\b Remarks} under {\uldb MsiCursor.Insert}{\v MsiCursor_Insert}
\page

#{\footnote MsiCursor_Assign}
${\footnote MsiCursor.Assign}
+{\footnote MsiCursor:Assign}
K{\footnote Assign}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Assign Method
\line\tx360\tab\fs18\b0{\uldb MsiCursor Object}{\v MsiCursor_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Either updates an existing table row or inserts a new table row 
 using the current cursor data.
 Returns True if either an update or an insert was successful.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .Assign}
\par{\i object}\line
Required. The MsiCursor object.
\par\fi0\li0{\b Remarks}\par\li180
The table row position is determined by the primary key values.
 An update operation takes place if primary keys match an existing row.
 An insert operation takes place if primary keys do not match any row.
 In either case the current data in the cursor are written to a table row.
 If any of the primary key values are Null, the method will fail and return False.
\page

#{\footnote MsiCursor_Replace}
${\footnote MsiCursor.Replace}
+{\footnote MsiCursor:Replace}
K{\footnote Replace}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Replace Method
\line\tx360\tab\fs18\b0{\uldb MsiCursor Object}{\v MsiCursor_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Updates a fetched row using current cursor data, allowing primary key changes.
 Returns True if either an update or an insert+delete was successful.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .Replace}
\par{\i object}\line
Required. The MsiCursor object.
\par\fi0\li0{\b Remarks}\par\li180
The table row position is determined by the primary key values.
 An update operation takes place if primary keys match an existing row.
 An insert operation takes place if primary keys do not match any row,
 in which case the row referenced by the previous key value will be delete (if not already deleted).
 If any of the primary key values are Null, the method will fail and return False.
\page

#{\footnote MsiCursor_Merge}
${\footnote MsiCursor.Merge}
+{\footnote MsiCursor:Merge}
K{\footnote Merge}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Merge Method
\line\tx360\tab\fs18\b0{\uldb MsiCursor Object}{\v MsiCursor_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Either inserts a new record into the table, or insures that an existing record is identical. 
 Returns True if the insert was successful, or an existing record with the same key is completely matched.
 If an existing record is not identical, the row attribute bit iraMergeFailed is set.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .Merge}
\par{\i object}\line
Required. The MsiCursor object.
\par\fi0\li0{\b Remarks}\par\li180
The table row position is determined by the primary key values.
 An insert operation takes place if primary keys do not match any row.
 A validation operation takes place if primary keys match an existing row.
 Since matched rows are never replaced, they may be marked as read-only.
\page

#{\footnote MsiCursor_Refresh}
${\footnote MsiCursor.Refresh}
+{\footnote MsiCursor:Refresh}
K{\footnote Refresh}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Refresh Method
\line\tx360\tab\fs18\b0{\uldb MsiCursor Object}{\v MsiCursor_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Reloads the cursor with data from the current table row, replacing any changes
 made to the cursor data and updating data that has been update via other cursors.
 If the row has been deleted, all data will be set to null and the method will return False.
 False will also be returned if the cursor is not positioned on a row, i.e. in a Reset state.
 Returns True if the row is still present.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .Refresh}
\par{\i object}\line
Required. The MsiCursor object.
\page

#{\footnote MsiCursor_Delete}
${\footnote MsiCursor.Delete}
+{\footnote MsiCursor:Delete}
K{\footnote Delete}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Delete Method
\line\tx360\tab\fs18\b0{\uldb MsiCursor Object}{\v MsiCursor_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Deletes current cursor row from table. The row to be deleted is determined
 by the primary key data, not by the current position in the table. Returns
 True if successful, else False if the row could not be deleted.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .Delete}
\par{\i object}\line
Required. The MsiCursor object.
\par\fi0\li0{\b Remarks}\par\li180
The delete will fail if the any of the primary key fields in the cursor
 are null, or if the primary key does not exist in the table, or if a non-leaf
 node is specified in a tree-linked table.
 In this cursor and any other MsiCursor objects positioned at the deleted row,
 all non-updated data fields will be refreshed with Null values. The logical
 positions of such cursors will be maintained such that the Next method will
 advance to the next row following the deleted row. An attempt to call Delete
 a second time without advancing the cursor will fail and return False.
\page

#{\footnote MsiCursor_Seek}
${\footnote MsiCursor.Seek}
+{\footnote MsiCursor:Seek}
K{\footnote Seek}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Seek Method
\line\tx360\tab\fs18\b0{\uldb MsiCursor Object}{\v MsiCursor_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Positions the cursor to the table row corresponding the the current primary key values.
 If the row is not present, the method will return False.
 Returns True if the row is present, and reloads the cursor with data from the table row.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .Seek}
\par{\i object}\line
Required. The MsiCursor object.
\page

#{\footnote MsiCursor_Validate}
${\footnote MsiCursor.Validate}
+{\footnote MsiCursor:Validate}
K{\footnote Validate}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Validate Method
\line\tx360\tab\fs18\b0{\uldb MsiCursor Object}{\v MsiCursor_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Returns an MsiRecord object where each field represents a column of the table.  All invalid
 fields will contain the iveEnum associated describing the invalid data.  For valid data,
 it returns an object of Nothing.  For invalid data, the zeroeth (0th) field of the record
 will contain the number of columns that were invalid.  If however the cursor was in a bad
 state (set to be deleted or reset if you aren't validating a new row), the zeroeth (0th)
 field will be null.  
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .Validate({\i Table, Cursor, Column})}
\par{\i object}\line
Required. The MsiCursor object.
\par{\b\i Table}\line
Required. The Validation table object.
\par{\b\i Cursor}\line
Required.  The Validation table cursor object.
\par{\b\i Column}\line
Required.  -2 = Delete row, -1 = New row, 0 = row, or column number.
\par\fi0\li0{\b Remarks}\par\li180
Delete validation ensures that no row is explicitly referencing the row to be deleted.  This means that it ensures that
 any column with the foreign key to the table of the row to be deleted (data obtained from the 'KeyTable' column of the
 _Validation table) reference the primary key(s) of the row to be deleted.  This validation is however limited and does
 not include checking for properties referencing the row to be deleted nor for the delimited list of tables value allowed
 in the 'KeyTable' column of the _Validation table.  In this instance, those strings (delimited list ones) are ignored. New row validation should be done prior to insertion.  This will ensure that no duplicate
 primary keys exist.  Row validation validates the entire row. Field validation validates
 the particular field, but field/column validation does not permit validation of foreign
 key fields.  If an invalid field is found, its field in the data record will contain the
 iveEnum describing the error.  Valid columns will be null.  The size of the record object
 is determined by the number of columns in the table to which the cursor belongs.
\par\fi0\lio{\b iveEnum}\par\li180
{\f1 \b iveNoError: 0} {\i Valid data}\line
{\f1 \b iveDuplicateKey: 1} {\i Duplicate Primary Key}\line 
{\f1 \b iveRequired: 2} {\i Not a nullable column}\line 
{\f1 \b iveBadLink: 3} {\i Not a valid foreign key}\line 
{\f1 \b iveOverFlow: 4} {\i Value exceeds MaxValue}\line 
{\f1 \b iveUnderFlow: 5} {\i Value below MinValue}\line 
{\f1 \b iveNotInSet: 6}  {\i Not member of set}\line 
{\f1 \b iveBadVersion: 7} {\i Invalid version string}\line 
{\f1 \b iveBadCase: 8} {\i Invalid case, must be all upper or all lower case}\line 
{\f1 \b iveBadGuid: 9} {\i Invalid GUID}\line 
{\f1 \b iveBadWildCard: 10} {\i Invalid wildcard or wildcard usage}\line 
{\f1 \b iveBadIdentifier: 11} {\i Invalid identifier}\line 
{\f1 \b iveBadLanguage: 12} {\i Invalid LangId}\line 
{\f1 \b iveBadFilename: 13} {\i Invalid filename}\line 
{\f1 \b iveBadPath: 14} {\i Invalid path}\line 
{\f1 \b iveBadCondition: 15} {\i Invalid condition string}\line 
{\f1 \b iveBadFormatted: 16} {\i Invalid format string}\line 
{\f1 \b iveBadTemplate: 17} {\i Invalid template string}\line 
{\f1 \b iveBadDefaultDir: 18} {\i Invalid DefaultDir string (special for Directory table)}\line 
{\f1 \b iveBadRegPath: 19} {\i Invalid registry path (Key col in Registry table for example)}\line
{\f1 \b iveBadCustomSource: 20} {\i Invalid CustomSource string (special for CustomAction table)}\line 
{\f1 \b iveBadProperty: 21} {\i Bad property string}\line 
{\f1 \b iveMissingData: 22} {\i Validation table: missing data}\line 
{\f1 \b iveMissingTable: 23} {\i NO LONGER USED!!}\line
{\f1 \b iveBadCategory: 24} {\i Validation table: invalid category string}\line 
{\f1 \b iveBadKeyTable: 25} {\i Validation table: bad key table name [table could not be loaded]}\line 
{\f1 \b iveBadMaxMinValues: 26} {\i Validation table:  case where value in Max col is < value in Min col}\line 
{\f1 \b iveNonExistingCol: 27} {\i NO LONGER USED!!}\line
{\f1 \b iveBadCabinet: 28} {\i Bad cabinet string, special for Media.Cabinet column}\line
{\f1 \b iveBadShortcut: 29} {\i Bad shortcut target string, special for Shortcut.Target column}\line
{\f1 \b iveStringOverflow: 30} {\i String overflow, length of string greater than size allowed by col def}\line
\page

#{\footnote MsiCursor_Moniker}
${\footnote MsiCursor.Moniker}
+{\footnote MsiCursor:Moniker}
K{\footnote Moniker}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Moniker Property
\line\tx360\tab\fs18\b0{\uldb MsiCursor Object}{\v MsiCursor_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Returns the unique identifier for the current row of the cursor.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .GetMoniker()}
\par{\i object}\line
Required. The MsiCursor object.
\par\fi0\li0{\b Remarks}\par\li180
Identifier in form of table.key1(.key2 ...etc).  If cursor is not on a row, will get
 the name of the table to which the cursor belongs.
\page

#{\footnote MsiStorage_Object}
${\footnote MsiStorage Object}
K{\footnote MsiStorage}
+{\footnote Class:MsiStorage}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
MsiStorage Object
\par}\li180
The MsiStorage object represents a persistent storage unit, typically a file,
 but may also be implemented on memory or a resource, or as child of a parent storage.
 The current implementation is a thin layer on top of OLE structured storage. The same
 data format is used for Win32 and PPCMAC, with integers stored little-endian. All data
 access is via MsiStream objects, with byte-swapping required for the PPCMAC performed
 by the MsiStream integer access functions. Special handling is provided to generate and
 read the SummaryInformation stream, where standardized document properties are stored.
\par\li0{\b Properties}\par\li180
{\uldb Class}{\v MsiStorage_Class}\line
{\uldb Name}{\v MsiStorage_Name}\line

\par\li0{\b Methods}\par\li180
{\uldb OpenStream}{\v MsiStorage_OpenStream}\line
{\uldb OpenStorage}{\v MsiStorage_OpenStorage}\line
{\uldb Streams}{\v MsiStorage_Streams}\line
{\uldb Storages}{\v MsiStorage_Storages}\line
{\uldb RemoveElement}{\v MsiStorage_RemoveElement}\line
{\uldb Commit}{\v MsiStorage_Commit}\line
{\uldb Rollback}{\v MsiStorage_Rollback}\line
{\uldb DeleteOnRelease}{\v MsiStorage_DeleteOnRelease}\line
{\uldb CreateSummaryInfo}{\v MsiStorage_CreateSummaryInfo}\line
{\uldb CopyTo}{\v MsiStorage_CopyTo}\line
\page

#{\footnote MsiStorage_Class}
${\footnote MsiStorage.Class}
+{\footnote MsiStorage:Class}
K{\footnote Class}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Class Property
\line\tx360\tab\fs18\b0{\uldb MsiStorage Object}{\v MsiStorage_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Read/write. The class ID (CLSID) associated with this storage,
 represented as the string form of a GUID.
 Return an empty value if the storage has no class ID.
 Generates an error if attempting to set an invalid GUID string.
 This is a thin wrapper on the OLE methods: IStorage::SetClass and IStorage::Stat.
 Microsoft Installer uses this for identification of the storage usage.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .Class}
\par{\i object}\line
Required. The MsiStorage object.
\page

#{\footnote MsiStorage_Name}
${\footnote MsiStorage.Name}
+{\footnote MsiStorage:Name}
K{\footnote Name}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Name Property
\line\tx360\tab\fs18\b0{\uldb MsiStorage Object}{\v MsiStorage_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Read-only. The name of the storage. This is a thin wrapper on the OLE method: IStorage::Stat.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .Name}
\par{\i object}\line
Required. The MsiStorage object.
\page

#{\footnote MsiStorage_OpenStream}
${\footnote MsiStorage.OpenStream}
+{\footnote MsiStorage:OpenStream}
K{\footnote OpenStream}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
OpenStream Method
\line\tx360\tab\fs18\b0{\uldb MsiStorage Object}{\v MsiStorage_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Creates and returns an {\uldb MsiStream}{\v MsiStream_Object} object that allows data to be read or written to the storage.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .OpenStream({\i name, fWrite})}
\par{\i object}\line
Required. The MsiStorage object.
\par{\b\i name}\line
Required. The name of the stream as it is known in the storage. If fWrite is set
 to True, the stream will be created if it does not already exist.
\par{\b\i fWrite}\line
Required. True to create a writable stream, which will overwrite any existing stream.
 False to read a read-only stream.
\par\fi0\li0{\b Remarks}\par\li180
The stream object must be released in order to flush all changes to the storage.
\page

#{\footnote MsiStorage_OpenStorage}
${\footnote MsiStorage.OpenStorage}
+{\footnote MsiStorage:OpenStorage}
K{\footnote OpenStorage}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
OpenStorage Method
\line\tx360\tab\fs18\b0{\uldb MsiStorage Object}{\v MsiStorage_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Creates and returns an MsiStorage object represents a child storage under this storage.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .OpenStorage({\i name, openMode})}
\par{\i object}\line
Required. The MsiStorage object.
\par{\b\i name}\line
Required. The name of the storage as it is known in the storage, or a unique name if it is to be created.
 to True, the stream will be created if it does not already exist.
\par{\b\i openMode}\line
Required. Mode in which to create or open, see {\uldb CreateStorage}{\v MsiServices_CreateStorage}.
\par\fi0\li0{\b Remarks}\par\li180
The child storage object must be released and/or committed in order to flush all changes to the parent storage.
\page

#{\footnote MsiStorage_Streams}
${\footnote MsiStorage.Streams}
+{\footnote MsiStorage:Streams}
K{\footnote Streams}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Streams Method
\line\tx360\tab\fs18\b0{\uldb MsiStorage Object}{\v MsiStorage_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Returns a collection of strings containing the names of all streams in this storage object.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .Streams}
\par{\i object}\line
Required. The MsiStorage object.
\page

#{\footnote MsiStorage_Storages}
${\footnote MsiStorage.Storages}
+{\footnote MsiStorage:Storages}
K{\footnote Storages}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Storages Method
\line\tx360\tab\fs18\b0{\uldb MsiStorage Object}{\v MsiStorage_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Returns a collection of strings containing the names of all child storages in this storage object.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .Storages}
\par{\i object}\line
Required. The MsiStorage object.
\page

#{\footnote MsiStorage_RemoveElement}
${\footnote MsiStorage.RemoveElement}
+{\footnote MsiStorage:RemoveElement}
K{\footnote RemoveElement}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
RemoveElement Method
\line\tx360\tab\fs18\b0{\uldb MsiStorage Object}{\v MsiStorage_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Removes a stream or child storage matching the supplied name.
 This method will fail if the name is not found or if the storage is opened read-only.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .RemoveElement {\i name, fStorage}}
\par{\i object}\line
Required. The MsiStorage object.
\par{\b\i name}\line
Required. The name of the stream or child storage.
\par{\b\i fStorage}\line
Optional. True if a storage, False if a stream. Defaults to False.
\page

#{\footnote MsiStorage_RenameElement}
${\footnote MsiStorage.RenameElement}
+{\footnote MsiStorage:RenameElement}
K{\footnote RenameElement}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
RenameElement Method
\line\tx360\tab\fs18\b0{\uldb MsiStorage Object}{\v MsiStorage_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Renames a stream or child storage from the supplied old name to a new name.
 This method will fail if the old name is not found or if the storage is opened read-only.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .RenameElement {\i oldName, newName, fStorage}}
\par{\i object}\line
Required. The MsiStorage object.
\par{\b\i oldName}\line
Required. The original name of the stream or child storage.
\par{\b\i newName}\line
Required. The new name of the stream or child storage.
\par{\b\i fStorage}\line
Optional. True if a storage, False if a stream. Defaults to False.
\page

#{\footnote MsiStorage_Commit}
${\footnote MsiStorage.Commit}
+{\footnote MsiStorage:Commit}
K{\footnote Commit}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Commit Method
\line\tx360\tab\fs18\b0{\uldb MsiStorage Object}{\v MsiStorage_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Forces all persistent data to be written to the persistent storage.
 No action is taken if the storage is opened read-only (ismReadOnly).
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .Commit}
\par{\i object}\line
Required. The MsiStorage object.
\page

#{\footnote MsiStorage_Rollback}
${\footnote MsiStorage.Rollback}
+{\footnote MsiStorage:Rollback}
K{\footnote Rollback}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Rollback Method
\line\tx360\tab\fs18\b0{\uldb MsiStorage Object}{\v MsiStorage_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Backs out any changes made to the storage since the MsiStorage object was created or last committed..
 This method only succeeds if the MsiStorage object was created in transacted mode using ismTransact;
 otherwise an error will be generated.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .Rollback}
\par{\i object}\line
Required. The MsiStorage object.
\page

#{\footnote MsiStorage_DeleteOnRelease}
${\footnote MsiStorage.DeleteOnRelease}
+{\footnote MsiStorage:DeleteOnRelease}
K{\footnote DeleteOnRelease}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
DeleteOnRelease Method
\line\tx360\tab\fs18\b0{\uldb MsiStorage Object}{\v MsiStorage_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Forces the storage to be physically removed after all the references to the MsiStorage
 object are released. Fails if the storage is opened read-only, or if the storage
 was created from an existing IStorage interface (rather than from Msi services).
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .DeleteOnRelease}
\par{\i object}\line
Required. The MsiStorage object.
\page

#{\footnote MsiStorage_CreateSummaryInfo}
${\footnote MsiStorage.CreateSummaryInfo}
+{\footnote MsiStorage:CreateSummaryInfo}
K{\footnote CreateSummaryInfo}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
CreateSummaryInfo Method
\line\tx360\tab\fs18\b0{\uldb MsiStorage Object}{\v MsiStorage_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Returns a MsiCreateSummaryInfo object that can be used examine, update,
 and add properties to the SummaryInformation stream.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .CreateSummaryInfo({\i maxProperties})}
\par{\i object}\line
Required. The MsiStorage object.
\par{\b\i maxProperties}\line
Required. The maximum number of properties to be added or modified, used solely to allocate
 sufficent working memory during the stream generation. It is not required to actually
 store this number of properties. A value of zero prevents the stream from being updated.
\par\fi0\li0{\b Remarks}\par\li180
If the MsiStorage object is opened read-only, no properties may be added or updated.
\page

#{\footnote MsiStorage_CopyTo}
${\footnote MsiStorage.CopyTo}
+{\footnote MsiStorage:CopyTo}
K{\footnote CopyTo}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
CopyTo Method
\line\tx360\tab\fs18\b0{\uldb MsiStorage Object}{\v MsiStorage_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Copies the contents of the storage to another storage, optionally excluding 
some streams or substorages from the copy.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .CopyTo({\i destStorage}, {\i excludedElements})}
\par{\i object}\line
Required. The MsiStorage object to which the contents of the current object should be copied.
\par{\b\i destStorage}\line
Required. The destination storage for the copy.
 \par{\b\i excludedElements}\line
Optional. A recording containing the names of elements (streams or storages) that
 should not be copied.
\par\fi0\li0{\b Remarks}\par\li180
\page


#{\footnote MsiStream_Object}
${\footnote MsiStream Object}
K{\footnote MsiStream}
+{\footnote Class:MsiStream}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
MsiStream Object
\par}\li180
The MsiStream object is used to transfer table data and large binary objects (BLOB)
 to and from the persistent database. The use of streams to manage loading and saving
 of table data is wholely managed by the database. However large binary data items are
 not loaded into memory when their table is loaded, but only on demand when the
 {\uldb StreamData property}{\v MsiCursor_StreamData} is requested for the data item,
 which returns a read-only MsiStream object which is used to access the data sequentially.
\par
When transferring data to and from stream that may be shared between Windows and PPCMAC,
 use the integer tranfer routines which automatically take care of the byte-swapping issues.
\par\li0{\b Properties}\par\li180
{\uldb Length}{\v MsiStream_Length}\line
{\uldb Remaining}{\v MsiStream_Remaining}\line
{\uldb Error}{\v MsiStream_Error}\line
\par\li0{\b Methods}\par\li180
{\uldb GetData}{\v MsiStream_GetData}\line
{\uldb PutData}{\v MsiStream_PutData}\line
{\uldb GetInt16}{\v MsiStream_GetInt16}\line
{\uldb GetInt32}{\v MsiStream_GetInt32}\line
{\uldb PutInt16}{\v MsiStream_PutInt16}\line
{\uldb PutInt32}{\v MsiStream_PutInt32}\line
{\uldb Seek}{\v MsiStream_Seek}\line
{\uldb Reset}{\v MsiStream_Reset}\line
{\uldb Clone}{\v MsiStream_Clone}\line
\page

#{\footnote MsiStream_Length}
${\footnote MsiStream.Length}
+{\footnote MsiStream:Length}
K{\footnote Length}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Length Property
\line\tx360\tab\fs18\b0{\uldb MsiStream Object}{\v MsiStream_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Returns the current length of the stream in bytes.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .Length}
\par{\i object}\line
Required. The MsiStream object.
\page

#{\footnote MsiStream_Remaining}
${\footnote MsiStream.Remaining}
+{\footnote MsiStream:Remaining}
K{\footnote Remaining}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Remaining Property
\line\tx360\tab\fs18\b0{\uldb MsiStream Object}{\v MsiStream_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Returns the remaining length of the stream in bytes.
 When writing to the stream, this value will be zero.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .Remaining}
\par{\i object}\line
Required. The MsiStream object.
\page

#{\footnote MsiStream_Error}
${\footnote MsiStream.Error}
+{\footnote MsiStream:Error}
K{\footnote Error}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Error Property
\line\tx360\tab\fs18\b0{\uldb MsiStream Object}{\v MsiStream_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Returns a boolean indicating when any transfer error occurred when reading or
 writing to the stream. The error state is then cleared in the stream.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .Error}
\par{\i object}\line
Required. The MsiStream object.
\page

#{\footnote MsiStream_GetData}
${\footnote MsiStream.GetData}
+{\footnote MsiStream:GetData}
K{\footnote GetData}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
GetData Method
\line\tx360\tab\fs18\b0{\uldb MsiStream Object}{\v MsiStream_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Copies the indicated number of bytes from the stream into a buffer. For automation,
 the bytes are returned as a string, with the length equal to the byte count copied.
 If the end of the stream is reached before the requested number of bytes, the stream
 error state is set and a smaller string is returned. On DBCS-enabled systems, byte values
 corresponding to lead byte characters may be lost due to the intermediate Unicode translation.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .GetData({\i count})}
\par{\i object}\line
Required. The MsiStream object.
\par{\b\i count}\line
Required. The number of bytes to copy from the stream
\page

#{\footnote MsiStream_PutData}
${\footnote MsiStream.PutData}
+{\footnote MsiStream:PutData}
K{\footnote PutData}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
PutData Method
\line\tx360\tab\fs18\b0{\uldb MsiStream Object}{\v MsiStream_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Copies the indicated number of bytes from the supplied buffer to the stream.
 For automation, a string is passed in containing the bytes. The size of the string
 is used for the count of bytes to write to the stream. The string may contain any
 binary byte values, including null. On DBCS-enabled systems, byte values corresponding
 to lead byte characters may be lost due to the intermediate Unicode translation.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .PutData({\i buffer})}
\par{\i object}\line
Required. The MsiStream object.
\par{\b\i buffer}\line
Required. String containing the bytes to copy. The string length is used for the count.
\page

#{\footnote MsiStream_GetInt16}
${\footnote MsiStream.GetInt16}
+{\footnote MsiStream:GetInt16}
K{\footnote GetInt16}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
GetInt16 Method
\line\tx360\tab\fs18\b0{\uldb MsiStream Object}{\v MsiStream_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Returns the next two bytes from the stream as a 16-bit integer,
 the first byte becoming the low-order byte of the integer.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .GetInt16}
\par{\i object}\line
Required. The MsiStream object.
\page

#{\footnote MsiStream_GetInt32}
${\footnote MsiStream.GetInt32}
+{\footnote MsiStream:GetInt32}
K{\footnote GetInt32}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
GetInt32 Method
\line\tx360\tab\fs18\b0{\uldb MsiStream Object}{\v MsiStream_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Returns the next four bytes from the stream as a 32-bit integer,
 the first byte becoming the low-order byte of the integer.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .GetInt32}
\par{\i object}\line
Required. The MsiStream object.
\page

#{\footnote MsiStream_PutInt16}
${\footnote MsiStream.PutInt16}
+{\footnote MsiStream:PutInt16}
K{\footnote PutInt16}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
PutInt16 Method
\line\tx360\tab\fs18\b0{\uldb MsiStream Object}{\v MsiStream_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Writes a 16-bit integer to the stream, low-order byte first.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .PutInt16({\i value})}
\par{\i object}\line
Required. The MsiStream object.
\par{\b\i value}\line
Required. The short integer to be written to the stream.
\page

#{\footnote MsiStream_Seek}
${\footnote MsiStream.Seek}
+{\footnote MsiStream:Seek}
K{\footnote Seek}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Seek Method
\line\tx360\tab\fs18\b0{\uldb MsiStream Object}{\v MsiStream_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Moves the stream pointer to a new position in the stream.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .Seek({\i position})}
\par{\i object}\line
Required. The MsiStream object.
\par{\b\i position}\line
Required. The new position in the stream, relative to the beginning of the stream.
\page

#{\footnote MsiStream_PutInt32}
${\footnote MsiStream.PutInt32}
+{\footnote MsiStream:PutInt32}
K{\footnote PutInt32}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
PutInt32 Method
\line\tx360\tab\fs18\b0{\uldb MsiStream Object}{\v MsiStream_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Writes a 32-bit integer to the stream, low-order byte first.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .PutInt32({\i value})}
\par{\i object}\line
Required. The MsiStream object.
\par{\b\i value}\line
Required. The long integer to be written to the stream.
\page

#{\footnote MsiStream_Reset}
${\footnote MsiStream.Reset}
+{\footnote MsiStream:Reset}
K{\footnote Reset}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Reset Method
\line\tx360\tab\fs18\b0{\uldb MsiStream Object}{\v MsiStream_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Resets the stream to the beginning, allow it to be read or written again. Using this
 method before writing simply replaces previous data, but does not remove old data
 beyond what is newly written. To completely replace a stream, simply reopen the stream.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .Reset}
\par{\i object}\line
Required. The MsiStream object.
\page

#{\footnote MsiStream_Clone}
${\footnote MsiStream.Clone}
+{\footnote MsiStream:Clone}
K{\footnote Clone}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Clone Method
\line\tx360\tab\fs18\b0{\uldb MsiStream Object}{\v MsiStream_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Creates and returns an {\uldb MsiStream}{\v MsiStream_Object} object that accesses the
 same data as the current object, but which has an independent seek pointer.
 The new stream object will be in the reset state, i.e. seek pointer at the beginning.
 Any clones used for writing must be kept positioned further than streams that are
 current reading to avoid errors. More than one close currently writing (not recommended)
 produces system-defined behavior; for file streams all writes will be appended to the end
 of the stream. For storage streams, the behavior is dependent upon the OLE implementation.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .Clone}
\par{\i object}\line
Required. The MsiStream object.
\page

#{\footnote MsiSummaryInfo_Object}
${\footnote MsiSummaryInfo Object}
K{\footnote MsiSummaryInfo}
+{\footnote Class:MsiSummaryInfo}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
MsiSummaryInfo Object
\par}\li180
The MsiSummaryInfo object is used to read, create, and update
 document properties from the SummaryInformation stream of the storage object.
\par\li0{\b Properties}\par\li180
{\uldb Property}{\v MsiSummaryInfo_Property}\line
{\uldb PropertyCount}{\v MsiSummaryInfo_PropertyCount}\line
{\uldb PropertyType}{\v MsiSummaryInfo_PropertyType}\line
\par\li0{\b Methods}\par\li180
{\uldb WritePropertyStream}{\v MsiSummaryInfo_WritePropertyStream}\line
\page

#{\footnote MsiSummaryInfo_PropertyCount}
${\footnote MsiSummaryInfo.PropertyCount}
+{\footnote MsiSummaryInfo:PropertyCount}
K{\footnote GetPropertyCount}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
PropertyCount Property
\line\tx360\tab\fs18\b0{\uldb MsiSummaryInfo Object}{\v MsiSummaryInfo_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
The current number of property values in the summary information object.
 This takes into account properties that have been added, deleted, or replaced. Read-only.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .PropertyCount}
\par{\i object}\line
Required. The MsiSummaryInfo object.
\page

#{\footnote MsiSummaryInfo_PropertyType}
${\footnote MsiSummaryInfo.PropertyType}
+{\footnote MsiSummaryInfo:PropertyType}
K{\footnote GetPropertyType}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
PropertyType Property
\line\tx360\tab\fs18\b0{\uldb MsiSummaryInfo Object}{\v MsiSummaryInfo_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Returns an integer containing the property type for the supplied property ID.
 If the property does not exist, the value 0 (VT_EMPTY) is returned.
 Standard property types are listed in {\uldb MsiSummaryInfo.Property}{\v MsiSummaryInfo_Property}.
 Read-only.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .PropertyType({\i pid})}
\par{\i object}\line
Required. The MsiSummaryInfo object.
\par{\b\i pid}\line
Required. The property ID of one of the summary properties.
\page

#{\footnote MsiSummaryInfo_Property}
${\footnote MsiSummaryInfo.Property}
+{\footnote MsiSummaryInfo:Property}
K{\footnote Property}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Property Property
\line\tx360\tab\fs18\b0{\uldb MsiSummaryInfo Object}{\v MsiSummaryInfo_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Sets or gets the value for the specified property in the summary information stream.
 The properties are read when the MsiSummaryInfo object is created, but they are not
 written until {\uldb WritePropertyStream}{\v MsiSummaryInfo_WritePropertyStream} is called.   
 Setting a property to Empty will cause its removal; likewise requesting a non-existent
 property will return an Empty value. Otherwise values may be transferred as strings,
 integers, or date (datetime) types.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .Property({\i pid})}
\par{\i object}\line
Required. The MsiSummaryInfo object.
\par{\b\i pid}\line
Required. The property ID of one of the summary properties.
\par\fi0\li0{\b Standard Summary Property IDs} (not an enumeration)
\line{\f1  PID_DICTIONARY    0 } special format, not support by MsiSummaryInfo
\line{\f1  PID_CODEPAGE      1 } VT_I2
\line{\f1  PID_TITLE         2 } VT_LPSTR
\line{\f1  PID_SUBJECT       3 } VT_LPSTR
\line{\f1  PID_AUTHOR        4 } VT_LPSTR
\line{\f1  PID_KEYWORDS      5 } VT_LPSTR
\line{\f1  PID_COMMENTS      6 } VT_LPSTR
\line{\f1  PID_TEMPLATE      7 } VT_LPSTR
\line{\f1  PID_LASTAUTHOR    8 } VT_LPSTR
\line{\f1  PID_REVNUMBER     9 } VT_LPSTR
\line{\f1  PID_EDITTIME     10 } VT_FILETIME
\line{\f1  PID_LASTPRINTED  11 } VT_FILETIME
\line{\f1  PID_CREATE_DTM   12 } VT_FILETIME
\line{\f1  PID_LASTSAVE_DTM 13 } VT_FILETIME
\line{\f1  PID_PAGECOUNT    14 } VT_I4
\line{\f1  PID_WORDCOUNT    15 } VT_I4
\line{\f1  PID_CHARCOUNT    16 } VT_I4
\line{\f1  PID_THUMBNAIL    17 } VT_CF  (not supported)
\line{\f1  PID_APPNAME      18 } VT_LPSTR
\line{\f1  PID_SECURITY     19 } VT_I4
\par\fi0\li0{\b MSI-specific Summary Property IDs}
\line{\f1  PID_MSITAG       30 } VT_LPSTR  MSI FileType
\line{\f1  PID_MSIPID       31 } VT_LPSTR  MSI Product ID
\line{\f1  PID_MSIUSER      32 } VT_LPSTR  MSI Registered User
\line{\f1  PID_MSIORG       33 } VT_LPSTR  MSI Organization
\line{\f1  PID_MSICHECK     34 } VT_LPSTR  MSI Checksum
\par\fi0\li0{\b Property Data Types} (not an enumeration)
\line{\f1  VT_I2        2 } 16-bit integer
\line{\f1  VT_I4        3 } 32-bit integer
\line{\f1  VT_LPSTR    30 } string
\line{\f1  VT_FILETIME 64 } date/time (FILETIME, converted to Variant time)
\line{\f1  VT_CF       71 } clipboard format + data, not handled by MsiSummaryInfo
\page

#{\footnote MsiSummaryInfo_WritePropertyStream}
${\footnote MsiSummaryInfo.WritePropertyStream}
+{\footnote MsiSummaryInfo:WritePropertyStream}
K{\footnote WritePropertyStream}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
WritePropertyStream Method
\line\tx360\tab\fs18\b0{\uldb MsiSummaryInfo Object}{\v MsiSummaryInfo_Object}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
Formats and writes the previously stored properties into the standard SummaryInformation stream.
 Generates an error if the stream could not be successfully written. This method may only
 be called once, after all the property values have been set. Properties may still be read
 after the stream is written.
\par\li0{\b Syntax}\par\li500\fi-320
{\i object}{\b .WritePropertyStream}
\par{\i object}\line
Required. The MsiSummaryInfo object.
\page

}
