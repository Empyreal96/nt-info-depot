{\rtf1\ansi {\fonttbl{\f0\fswiss Arial;}{\f1\fmodern Courier New;}} {\colortbl;} \fs20

#{\footnote MsiAutoContents}
${\footnote Msi Automation Contents}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Microsoft Installer Help Contents
\par}\li180
NOTE: If you see this topic initially instead of the outline content view, 
make sure that msiauto.cnt is in the same directory as msiauto.hlp the 
first time you run help.
\par\li0{\b\uldb Objects}{\v Msi_Objects}
\par\li0{\b\uldb Properties}{\v Property_Contents}
\par\li0{\b\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par\li0{\b\uldb Actions}{\v _msi_Installation_Database_Actions_List@msi.hlp}

\par\li0{\uldb Installer Components}{\v Installer_Components}
\par\li0{\uldb Released Components}{\v Release_Components}
\par\li0{\uldb Command Line Options}{\v CommandLine_Options}
\par\li0{\uldb REGMSI.EXE Tool}{\v RegMsi_Tool}
\par\li0{\uldb MSIALTER.EXE Tool}{\v MsiAlter_Tool}
\par\li0{\uldb MSIVAL.EXE Tool}{\v MsiVal_Tool}
\par\li0{\uldb MSIDB.EXE Tool}{\v MsiTable_Tool}
\par\li0{\uldb MSIINFO.EXE Tool}{\v MsiInfo_Tool}
\par\li0{\uldb MSITRAN.EXE Tool}{\v MsiTran_Tool}
\par\li0{\uldb MSIMERG.EXE Tool}{\v MsiMerge_Tool}
\par\li0{\uldb Automating C++ method}{\v Coding_AutomateMethod}
\par\li0{\uldb Help File Syntax}{\v Coding_HelpFile}
\line\line
{\b Obsolete tools}\line
\par\li0{\uldb MSIDBVAL.EXE Tool}{\v MsiDbVal_Tool}
\par\li0{\uldb MSITABLE.EXE Tool}{\v MsiDb_Tool}
\page

#{\footnote NoHelp}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Under Construction
\line\tx360\tab\fs18\b0{\uldb Automation Overview}{\v MsiAutoOverview}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
No help is available for this topic yet.
\page

#{\footnote Msi_Obsolete}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Obsolete Method or Property
\line\tx360\tab\fs18\b0{\uldb Automation Overview}{\v MsiAutoOverview}
\tx3000\tab{\uldb Msi Objects}{\v Msi_Objects}
\tx5000\tab{\uldb Database Tables}{\v _msi_Installation_Database_Tables_List@msi.hlp}
\par}\li180
This method or property has been replaced.
 It is retained temporarily until code and tests are updated.
\page

#{\footnote What_Is}
${\footnote What Is The Microsoft Installer?}
K{\footnote Microsoft Installer}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
What Is The Microsoft Installer?
\par}\li180
The  Microsoft Installer is an all new installation technology designed from the
 ground up using COM and relational database principles; targeting the Windows 95,
 Windows NT, and PowerMac platforms (32-bit only).  Utilizing relational database
 principles frees the Microsoft Installer from the myriad parsers previously
 required to interpret an Acme STF, making the code smaller and faster.  In addition,
 databases are easily merged.  Components can be added to an existing installation
 and be supported as if they were authored here at Microsoft.
\par\li0{\b Reduced Overhead}\par\li180
The Microsoft Installer's components are shared system
 components.  In the near term Microsoft Installer components will still need to be
 shipped, but they may not be installed.  Even if installed, there is only ever
 one copy as opposed to the per product copies of Acme which tend to litter a user's
 computer over time.  Eventually, Darwin components should make their way into the
 operating system, freeing product groups from having to ship them at all.
\par\li180
Regarding speed, the Microsoft Installer uses pre-defined queries.  Two substantial
 advantages result from this design: processing is file based rather than in memory
 and no parsing is required.  Acme uses an in memory model, meaning an entire STF
 is read into memory for processing.  Therefore, the memory footprint is proportional
 to the complexity of a product's installation.  The Microsoft Installer, on the other
 hand, loads into memory only those database tables required for the task at hand.
 So the memory footprint is greatly reduced.  Rather than the multitude of parsers
 Acme supports for all its different actions, the Microsoft Installer uses pre-defined
 queries and fetching.  Very little overhead and faster processing are the result.
\par\li180
Perceived performance is also improved by performing background searching and costing.
 While a user navigates through the interface, the Microsoft Installer is searching
 for previously installed products, compliant products (i.e., CCP), etc.  Also in the
 background the Microsoft Installer is adjusting initial costing estimates,
 accounting for files being replaced to improve disk space calculations.  Performing
 these tasks in the background alleviates the need to make users explicitly wait.
\par\li0{\b Easier Authoring}\par\li180
A multitude of schemes exist throughout Microsoft to facilitate Acme authoring.  These
 were born out of the inherent complexities of the Acme STF as well as the pronounced
 lack of formal support.  The Microsoft Installer addresses these by providing an
 integrated authoring environment, code named Scopes.  Scopes is a separate yet
 parallel effort with a similar time frame as the installer.  Two of the major
 goals for Scopes are to provide a clear migration path from Acme and to support
 buttom up authoring.  A semi-interactive conversion utility between Acme's *.STF and the
 Microsoft Installer's *.MSI is provided.  Because of the radically different paradigms
 used by these two products, the process does not achieve 100 percent conversion.  But
 all of the content of an *.STF (i.e., files, registry entries, shortcuts, etc.)
 gets converted as well as some of the logic.  In bottom up authoring, a component
 such as Graph can be authored and tested independently.  Once completed, the Graph
 component can be imported into a larger authoring effort such as Excel.  Additional
 authoring is required to wire up the dependencies between Graph and other components,
 but the logic for installing Graph does not change.
\par\li0{\b Upgrading}\par\li180
In order to reduce the pain associated with upgrading, the Microsoft Installer provides
 support for moving files and folders as well as reading and propagating registry
 settings.  REcognizing that locations of product components change over time, the Microsoft
 Installer facilitates keeping up.  User settings files (e.g., *.ACL, *.FAV) and template
 folder hierarchies are two examples.  Similarly, registry organization changes
 over time.  Registry based settings made in the past should be preserved when upgrading.
 For these reasons, the Microsoft Installer provides support for detecting and propagating
 registry settings to preserve behavior.
\par\li0{\b Administration}\par\li180
Like the Office business unit, many business units within Microsoft are facing
 previous versions of their own products as their largest competitor.  Though an
 envious position to be in, it has its problems.  Maintaining a steady revenue
 stream in such a situation requires establishing some form of annuity model where
 customers pay a periodic fee to Microsoft for products and services.  This is
 particularly true for corporate sales; whether small, medium, or large corporations.
 The Microsoft Installer addresses this new market landscape by providing a host of
 administration features like an integrated Network Installation Wizard for creating
 network installations, an Installation Script Wizard for creating one or more
 department specific scripts to be run from a network installation, the ability
 to add corporate specific templates to an existing network installation and have
 them managed like intrinsic components, silent installations, tight integration with
 SMS, and more.
\par\li0{\b Wizard User Interface}\par\li180
Though authorable, the default user interface is a wizard.  Users may go back and
 forth through a consistent set of dialogs any number of times, making changes along
 the way or viewing what the Microsoft Installer has chosen.  Not until the "Install
 Now" button is clicked are a user's choices cast in stone.  Special emphasis has been
 placed on providing both novice and advanced paths through the user interface.  For
 novice users, the novice path is easier than Acme while advanced users have more
 flexibility when taking the advanced path.
\par\li0{\b Pre-Installation}\par\li180
OEM pre-installation of Microsoft products is an over growing business and one which
 Acme does not address very well.  Coincidentally, many corporations have a centralized
 purchasing and deployment center which employs similar techniques as OEMs to get new
 machiens pre-configured and tested before rolling out to end users.  Both of these
 scenarios are addressed by the Microsoft Installer's build int pre-installation
 support.  This support creates an image directly, without having to take before
 and after snapshots of a reference machine to derive file and registry differences.
\par\li0{\b Intra(er)net}\par\li180
The Internet offers a pervasive low cost infrastructure for distributing product updates
 as well as content.  The Microsoft Installer, because of its database underpinnings,
 allows for the modification of existing components or the addition of new components
 without distruption.  Once modified or introduced, these components behave as if they
 were authored and shipped with theoriginal product.  This capability dramatically
 simplifies and reduces the cost of letter releases.  Plus, a new vehicle is
 created for disseminating product content not mainstream enough to make the CD
 content bar.
\par\li180
Distribution via the Internet can be accomplished with the Microsoft Installer using
 a general concept known as launchers.  Launchers are executables responsible for
 bootstrapping Microsoft Installer compnents.  One way to package up an Internet
 installation is to stuff into the resource section of a launcher a table file
 containing authored installation logic, a cabinet file, and properties to set
 conditions.  The Microsoft Installer then runs directly out of the launcher's
 resource section.  IN this way, a single file can be downloaded from the Internet
 then an installation can be invoked.
\par\li0{\b OLE Automation}\par\li180
For the ultimate in flexibility, the Microsoft Installer provides an OLE automation
 wrapper for all of its COM interfaces.  While quite useful inside Microsoft for
 testing purposes, the automation layer also offers corporations with advanced IS
 departments a framework around which they cna build even more sophisticated
 deployment schemes than the Microsoft Installer will ever consider.
\page


#{\footnote Supported_Platforms}
${\footnote Supported Platforms}
K{\footnote Supported Platforms}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Supported Platforms
\par}\li180
The Microsoft Installer is a core code application.  This is accomplished by centralizing
 all platform specific code in the Services component where low level file and operating
 system functionality resides.  Above that layer in the Services component, the rest of
 the Microsoft Installer's code is platform independent.  Using this approach, the
 platforms support by the Microsoft Installer include the following 32-bit only platforms:
\par
\line {\b Windows 95}
\line {\b Windows 98}
\line {\b Windows NT 4.0}\tab (x86, Alpha)
\line {\b Windows NT 5.0}\tab (x86, Alpha)
\page

#{\footnote Localize}
${\footnote Localization}
K{\footnote Localization}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Localization
\par}\li180
None of the Microsoft Installer's components contain any resources requiring localization.
 The user interface is authored as part of a Microsoft Installer installation
 database, so visible text resides in the database.  Error strings also reside
 in the installation database.  In addition to abstracting out all strings form
 within the Installer's components, the Microsoft Installer is also DBCS enabled.
 As the Microsoft Installer loads it checks the operating system to see if DBCS is
 turned on.  If it is then it loads code to handle double byte characters as part
 of its string object.  However, if a user's system is not DBCS enabled then the
 Microsoft Installer does not incur the performance penalty of loading double byte
 character handling code.
\page

#{\footnote Installer_Components}
${\footnote Installer Components}
K{\footnote Components}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Microsoft Installer Components
\par}\li180
Microsoft Installer has been developed as a set of shared components: 
 {\uldb Automation}{\v Automate_Info},
 {\uldb Engine}{\v ENGINE_Info}, {\uldb Handler}{\v HANDLER_Info},
 {\uldb Services}{\v SERVICES_Info}.
 These components are DLLs that expose COM objects.  These objects are accessible
 from a simple bootstrapper executable known as a {\uldb Launcher}{\v Launcher_Info},
 from C++ programs, or from VBA applications using the OLE automation facility. All
 of the functionality within the Microsoft Installer is exposed as a rich set of
 objects exposing only abstract COM interfaces. These interfaces are operating
 system independent; operating system dependencies are encapsulated within the
 implementation.
\page

#{\footnote Installer_Installer}
${\footnote Installer Installer}
K{\footnote Installer}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Active Installation Manager Installer
\par}\li180
For cases where the Installer is not delivered with the operating system,
 it is supplied as a separate self-installing executable that unregisters
 old components and installs and registers new Installer components. The
 location of this installer package is specified by the
 {\uldb INSTALLER}{\v Property_INSTALLER} property in the launcher, and may be a URL.
 If the installer package is a relative path, it will be copied during an admin install.
\page

#{\footnote Launcher_Info}
${\footnote Launcher}
K{\footnote Launcher}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Launcher (INSTALL.EXE)
\par}\li180
Because the Installer components all live in shared DLLs, an executable
 module is required to load the rest of the components.
 The basic launcher is very small, containing only enough code
 to handle any startup errors occurring before the components are initialized.
 In addition, its resources can be configured to
 set any number of initial property values, most importantly the names of the 
 component libraries and the installation database to use. Also configurable is
 the icon to use and the name of the launcher so that multiple specific use
 launchers can be created.  For instance, the distribution media might contain
 a launcher with an installation type icon and a name like "Install".  However,
 on a user's machine after installation, a launcher may be created with a
 modification type icon and a name like "Change Installation". Or in a corporate
 world an administrator might create a launcher named "Install Finance Templates"
 containing properties to install only a set of internally developed financial
 templates.
\par
The launcher is responsible for loading the
 various Installer COM components. It loads each DLL, calls the public entry point
 to obtain a class factory for the desired object, the calls the entry point to
 create an instance. The also reads property values from its resources
 parses the command line for additional property settings.
 Command line data can consist of either option flags followed by a data value
 if appropriate or property names with associated values, separated by an equals sign.
 This module is not used when an installation is controlled by OLE Automation (VBA).
 The automation wrapper DLL is used to load components instead.
\page

#{\footnote Automate_Info}
${\footnote Automation}
K{\footnote Automation}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Automation (MSIAUTO.DLL)
\par}\li180
Each of the objects exposed by the various Microsoft Installer components is
 exposed to OLE automation by using a shadow object which contains the COM 
 object pointer and dispatches calls through that pointer. The automation
 translation code is contained in a separate DLL to permit the use of highly
 shared code, and because this capability is not required for most shipping
 products. The main uses for the automation include testing and custom install
 controllers employed by many corporate customers. The automation code for
 each function has been kept as small as possible, mostly specifying the
 arguments to pass and testing for error returns.
\page

#{\footnote ENGINE_Info}
${\footnote ENGINE}
K{\footnote ENGINE}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Engine (MSIENG.DLL)
\par}\li180
The Engine object controls the installation process, relying on the
 {\uldb Services}{\v SERVICES_Info} object to perform all of the operating
 system functions. It opens the installation database containing the
 installation logic and data as well as passes error handling on to the
 {\uldb Handler}{\v HANDLER_Info} object. The Engine object is associated
 with a standard set of {\uldb Actions}{\v _msi_Installation_Database_Actions_List@msi.hlp}, each of which
 performs a particular operation on data from one or more action specific
 table. Additional Custom Actions may be added for
 particular product installations requiring functionality not provided natively.
 The basic Engine functionality is that of a sequencer which is driven by 
 data authored into a designated "sequence" table (such as 
 {\uldb InstallSequence}{\v _msi_InstallSequence_Table@msi.hlp}) in the installation
 database. In addition, the Engine manages the source and destination directory
 layout, the product selection tree, and cost calculations.
\page

#{\footnote HANDLER_Info}
${\footnote HANDLER}
K{\footnote HANDLER}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Handler (MSIHND.DLL)
\par}\li180
The Handler module is a replaceable component which processes all interactions
 with users or a controlling applications. The interface provides two
 functions, one of which handles messages of several kinds: warnings, errors, 
 and progress notifications. The other function is a request to
 perform a particular action. The action is normally used to invoke a particular
 dialog or wizard sequence, but can also be implemented as code functionality.
 The standard implementation utilizes its own database tables to store the structure
 and sequencing of all the dialogs. However, an alternate implementation of the
 Handler module could operate completely silently or even remotely.
\page

#{\footnote SERVICES_Info}
${\footnote SERVICES}
K{\footnote SERVICES}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Services (MSISRV.DLL)
\par}\li180
The Services component provides wrappers for several operating system functions
 as well as higher level functionality appropriate to the installation process.
 Some services are implemented as objects, as they have a lifetime beyond a single
 method call, while others are simple function calls. Examples of some of the services
 include:
\par
\line 1. String handling - Common string handling objects to avoid the use of buffers and to minimize string copying.
\line 2. Record management - Generalized mechanism for passing sets of values, used for database access and error handling.
\line 3. Property management - Centralized global install property table management.
\line 4. Volumes - Management of the characteristics of the various drive types, including floppy, hard, CD-ROM, and network servers.
\line 5. File paths - Performs all file and folder operations used by install, provides path parsing, concatenation, and validation.
\line 6. File copy - Copies compressed and uncompressed files, handles resource copying on Mac.
\line 7. Registry - Handles all registry and INI file operations, including key cleanup on uninstall.
\line 8. Program groups and shortcuts - Creating linkes on the Start menu or anywhere else in a user's file system.
\line 9. Hardware and OS detection - Setting the appropriate property values that can be tested elsewhere.
\page

#{\footnote Shipped_Components}
${\footnote Shipped Components}
K{\footnote Shipped Components}
+{\footnote Shipped:Components}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Shipped Components
\par}\li180
The following components are shipped with each product installed using the Microsoft Installer.
 Microsoft Installer components are included in this list because in
 a majority of the scenarios, they need to be shipped even if they are not
 installed or used.  Major releases of a product must contain Microsoft Installer
 components because you cannot assume a user has them already.  However, for
 letter upgrades, patches, Web content releases, etc. you can assume user's have
 these components.  Consequently, they need not be shipped.
\par
{\f1\line\uldb INSTALL.EXE}{\v Launcher_Info}{ } Launcher that loads the Installer's components.
{\f1\line\uldb MSIENG.DLL}{\v ENGINE_Info}{   } Installer engine responsible for sequencing actions in the Action table.
{\f1\line\uldb MSIHND.DLL}{\v HANDLER_Info}{   } UI handler which constructs dialogs and processes errors.
{\f1\line\uldb MSISRV.DLL}{\v SERVICES_Info}{   } Operating system and database services available to the rest of the Installer.
{\f1\line\b <{\i app}>.MSI}{     } A product specific installation database containing install logic and data.
{\f1\line\b <{\i app}>.CAB}{     } One or more cabinet files containing compressed files to be installed.
\page

#{\footnote Release_Components}
${\footnote Released Components}
K{\footnote ReleasedComponents}
+{\footnote Released:Components}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Released Components
\par}\li180
The following components are delivered with each retail build of the Microsoft Installer.
 Because the Microsoft Installer is a cross platform application, separate sets
 of components are produced for each platform.
\par
{\f1\line\b ERROR.IDT}{       } Table of parameterized Microsoft Installer error messages.
{\f1\line\uldb INSTALL.EXE}{\v Launcher_Info}{   } Launcher that loads the Installer's components.
{\f1\line\b MSIALTER.EXE}{ } Tool to load or display properties and resources into(in) a launcher.
{\f1\line\b MSI.ODL}{           } Type library used for VBA object browsing .
{\f1\line\b MSIAUTO.CNT}{   } WinHelp contents file used to organize information about the Microsoft Installer.
{\f1\line\uldb MSIAUTO.DLL}{\v Automate_Info}{   } OLE automation layer and loader for use with VBA.
{\f1\line\b MSIAUTO.HLP}{   } WinHelp file containing on-line help information for the Microsoft Installer.
{\f1\line\uldb MSIENG.DLL}{\v ENGINE_Info}{     } Installer engine responsible for sequencing actions in the Action table.
{\f1\line\uldb MSIHND.DLL}{\v HANDLER_Info}{     } UI handler which constructs dialogs and processes errors.
{\f1\line\uldb MSISRV.DLL}{\v SERVICES_Info}{     } Operating system and database services available to the rest of the Installer.
{\f1\line\b MSIDB.EXE}{ } Tool to import from and export to a text based archive format for tables.
{\f1\line\b REGMSI.EXE}{   } Tool to self-register and unregister installer components as OLE objects.
{\f1\line\b MSIVAL.EXE}{ } Tool to validate an authored database.
{\f1\line\b TESTDB.MDB}{     } Test database containing the basic tables and examples of data.
\par\par
In addition, debug builds of the Microsoft Installer deliver the following additional components:
\par
{\f1\line\b  INSTALLD.EXE  } Launcher stub with properties set to use debug components
{\f1\line\b  MSIAUTOD.DLL,MSIAUTOD.PDB,MSIAUTOD.BSC,MSIAUTOD.MAP} Automation, debug components
{\f1\line\b  MSIENGD.DLL, MSIENGD.PDB, MSIENGD.BSC, MSIENGD.MAP } Engine, debug components
{\f1\line\b  MSIHNDD.DLL, MSIHNDD.PDB, MSIHNDD.BSC, MSIHNDD.MAP } Handler, debug components
{\f1\line\b  MSISRVD.DLL, MSISRVD.PDB, MSISRVD.BSC, MSISRVD.MAP } Services, debug components
{\f1\line\b  REGMSID.EXE  } debug build for registration tools, works identically to REGMSI.EXE
\page

#{\footnote CommandLine_Options}
${\footnote Command Line Options}
K{\footnote Command;Options}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Command Line Options
\par}\li180
Command line options may be specified when invoking a Windows launcher executable.
 The command line is parsed by the launcher with corresponding property values
 being passed on to the Services module, along with any properties stored in the
 resource section of the launcher itself.  The general format is to specify property
 =value pairs using an equals sign between the case insensitive property name and value.
 Property pairs are separated by white space on the command line.  If a value contains
 embedded white space it must be enclosed in double quotes.  Only properties whose
 names consist of all upper case characters can be entered on the command line.
\par
Help for command line parameters is available by using a question mark as the
 command line artument, (e.g., install ?). A selected list of property names and
 descriptions are displayed. If two successive question marks are provided as a
 property, the default values for properties predefined in the launcher are displayed.
 Both property values and their descriptions are programmed either by the build process
 or by using the MSIALTER.EXE tool.
\par
For backward compatibility with Acme, forward slash or minus sign followed by a letter continues
 to be supported by the Microsoft Installer (e.g., install /?).  The letters are
 case-insensitive and must be immediately preceeded by either a forward slash or minus sign.
 Some of the options set a particular value for a property while others require the value
 to follow the option letter. Backwards compatibile options are shown below, along with their
 resultant property assignments.
\par
{\line\f1   /A {\i }          } {\uldb ACTION}{\v *Property_ACTION} = Admin
{\line\f1   /G {\i logfile}   } {\uldb LOGFILE}{\v *Property_LOGFILE} = {\f1\i logfile}
{\line\f1   /I {\i rootdrive} } {\uldb ROOTDRIVE}{\v *Property_ROOTDRIVE} = {\f1\i rootdrive}
{\line\f1   /K {\i cdkey}     } !!?? CDKEY = {\f1\i cdkey}
{\line\f1   /M {\i logmode}   } {\uldb LOGMODE}{\v *Property_LOGMODE} = {\f1\i logmode}
{\line\f1   /N {\i username}  } {\uldb USERNAME}{\v *Property_USERNAME} = {\f1\i username}
{\line\f1   /O {\i orgname}   } {\uldb COMPANYNAME}{\v *Property_COMPANYNAME} = {\f1\i orgname}
{\line\f1   /P {\i pidstring} } {\uldb PRODUCTID}{\v *Property_PRODUCTID} = {\f1\i pidstring}
{\line\f1   /R {\i }          } {\uldb ACTION}{\v *Property_ACTION} = Reinstall
{\line\f1   /S {\i sourcedir} } {\uldb SOURCEDIR}{\v *Property_SOURCEDIR} = {\f1\i sourcedir}
{\line\f1   /T {\i database}  } {\uldb DATABASE}{\v *Property_DATABASE} = {\f1\i database} 
{\line\f1   /U {\i }          } {\uldb ACTION}{\v *Property_ACTION} = Uninstall
\par\par\li0\fi0{\b Remarks}\par\li180
Command line options are not available on the Mac.
 In their place will be an alternate mechanism for the user
 to specify property settings such as a preference file.
\page

#{\footnote MsiAutoOverview}
${\footnote Automation Overview}
K{\footnote Overview; Automation}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Microsoft Installer Automation Interface
\par}{\b Access to C++ Libraries}\par\li180
An MsiAuto object must be initially created in order to load the automation 
support that is required in order to access the Microsoft Installer components 
through OLE automation. This object provides wrappers to create the top level 
objects and access their methods. These wrapper simply provide argument 
translations to expose the C++ methods in manner consitent with BASIC without 
changing the behavior of the methods. When possible, a pair of Get and Set C++ 
methods will be exposed to BASIC as a single property. Multiple C++ methods 
that simply handle different data types will be exposed as a single method. 
Where appropriate, C++ methods taking an index argument will be exposed as an 
indexed property. Many C++ methods return the result through an argument, as 
the return value is used for the error return; however in BASIC errors are 
handled by a separate mechanism, and the result is always passed in the return 
value.
\page

#{\footnote MsiDb_Tool}
${\footnote MsiDb Tool}
K{\footnote MsiDb}
+{\footnote Tool:MsiDb}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
MSIDB.EXE Tool To Modify A Database
\par}\li180
The MSIDB.EXE tool uses the MSI database external API to import and export database tables as well
 as merge databases and apply transforms to databases.  It is essentially a UI and/or command line
 processing layer on MsiDatabase.Import and .Export.  If all required
 parameters (mode, folder, database and and table list) are specified on the command line,
 the tool will not bring up any UI and will operate as silent command line-driven utility,
 suitable for a build script. The -m and -t and create modes can only be used in silent command line mode.  Up to
 10 transforms or merge databases can be specified. If the folder
 containing the text archive files is not specified it will be prompted for; likewise the database will 
 be prompted for if not specified. Create new database (both .msi and .mdb), Import archives to database
 and Export tables to archives.  Tables can be exported from a read only database (only in interactive mode).
\par\fi-180\li180{\b Command Line Syntax}
{\line\f1 MsiDb \{option\}...\{option\}... \{table\}...\{table\}}
\line The following case-insensitive command line options are supported (slash delimiter may also be used).
{\line\f1\b  -i   } Import text archive files from folder into specified database
{\line\f1\b  -e   } Export selected tables into text archive files in specified folder
{\line\f1\b  -c   } Creates a new database file (overwrites existing) and imports tables
{\line\f1\b  -f   } Specifies the folder containing the text archive files for tables and streams
{\line\f1\b  -d   } Fully-qualified path to the database
{\line\f1\b  -m   } Fully-qualified path to the database to merge in
{\line\f1\b  -t   } Fully-qualified path to the transform to apply
{\line\f1\b  -?   } Displays command line help dialog
\line Table names for import are file names. Standard wild card specifications may be used.
\line Table names for export are table names. Only the wildcard specification, "*", may be used.
\par{\b Archive Table Naming}
\line The table name is truncated to 8 characters and the extension ".idt" added.
\line Tables names supplied by command for import are likewise converted.
\line The name used for database table creation is maintained in the .idt file.
\line Binary data streams are stored as separate files with extension ".ibd".
\line Binary filename used is primary key data for the row containing the stream.
\par{\b Database Naming Syntax}
\line Microsoft Installer database:  \{databasepath(*.msi)\}
\line Access database:    \{databasepath(*.mdb)\}[@\{owner\}][#\{password\}]
\line SQLServer database: \\\\\{server\}\\\{database\}[@\{owner\}][#\{password\}]
\line ODBC data source:   \{ODBCdatasource name\}[@\{owner\}][#\{password\}]
\line        \{owner\} defaults to the current network username
\line        \{password\} defaults to none
\line\line
Note:  When using long filenames with spaces, use quotes around them.  For example, for a
 database that is in the 'My Documents' folder, specify it as "c:\my documents".
\page

#{\footnote MsiTable_Tool}
${\footnote MsiTable Tool}
K{\footnote MsiTable}
+{\footnote Tool:MsiTable}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
MSITABLE.EXE Tool To Modify A Database
\par}\li180
\line
!!! OBSOLETE !!! \line\line
The {\b MSITABLE.EXE} tool uses the MSI database engine to import and export database tables as well
 as merge databases.  It is essentially a UI and/or command line processing layer on MsiDatabase.Import
 and .Export.  This tool uses OLE to create an instance of the MsiServices component. If all required
 parameters (mode, folder, database and and table list) are specified on the command line,
 the tool will not bring up any UI and will operate as silent command line-driven utility,
 suitable for a build script. It will also operate as a silent command line-driven utility if
 the -m mode and database are specified for merging.  No UI is available for merging.  If the folder
 containing the text archive files is not specified it will be prompted for; likewise the database will 
 be prompted for if not specified. There are three modes in which to tool can operate:
 Create new database, Import archives to database and Export tables to archives.  The Create and Merge 
 options are not available when in interactive mode.  One can use multiple merge options (up to 10).
\par\fi-180\li180{\b Command Line Syntax}
{\line\f1 MsiTable \{option\}...\{option\}... \{table\}...\{table\}}
\line The following case-insensitive command line options are supported (slash delimiter may also be used).
{\line\f1\b  -i   } Import text archive files from folder into specified database
{\line\f1\b  -e   } Export selected tables into text archive files in specified folder
{\line\f1\b  -c   } Creates a new database file (overwrites existing) and imports tables
{\line\f1\b  -f   } Specifies the folder containing the text archive files for tables and streams
{\line\f1\b  -d   } Fully-qualified path to the database
{\line\f1\b  -m   } Fully-qualified path to the database to merge in
{\line\f1\b  -?   } Displays command line help dialog
\line Table names for import are file names. Standard wild card specifications may be used.
\line Table names for export are table names. Only the wildcard specification, "*", may be used.
\par{\b Archive Table Naming}
\line The table name is truncated to 8 characters and the extension ".idt" added.
\line Tables names supplied by command for import are likewise converted.
\line The name used for database table creation is maintained in the .idt file.
\line Binary data streams are stored as separate files with extension ".ibd".
\line Binary filename used is primary key data for the row containing the stream.
\par{\b Database Naming Syntax}
\line Microsoft Installer database:  \{databasepath(*.msi)\}
\line Access database:    \{databasepath(*.mdb)\}[@\{owner\}][#\{password\}]
\line SQLServer database: \\\\\{server\}\\\{database\}[@\{owner\}][#\{password\}]
\line ODBC data source:   \{ODBCdatasource name\}[@\{owner\}][#\{password\}]
\line        \{owner\} defaults to the current network username
\line        \{password\} defaults to none
\line\line\line\line\line
\page

#{\footnote RegMsi_Tool}
${\footnote RegMsi Tool}
K{\footnote RegMsi}
+{\footnote Tool:RegMsi}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
REGMSI.EXE Tool to Self-register Installer Components
\par}\li180
The REGMSI.EXE tool simply calls the DllRegisterServer and DllUnregisterServer
 entry points of the Installer components to cause them to register or unregister
 themselves as OLE objects. Registration allows them to be called using the OLE
 call CoCreateInstance, or by using CreateObject from VBA. The tool interprets
 individual characters on the command line to set execution options. Options are
 case insensitive and may appear in any order.
 The default behavior is to register all the components designated below:
{\line\f1\b  A   } Automation module, MsiAuto(D).DLL, ProgId = Msi.Automation(Msi.AutoDebug)
{\line\f1\b  S   } Services module,     MsiSrv(D).DLL,   ProgId = Msi.Services(Msi.ServicesDebug)
{\line\f1\b  E   } Engine module,       MsiEng(D).DLL,  ProgId = Msi.Engine(Msi.EngineDebug)
{\line\f1\b  H   } Handler module,      MsiHnd(D).DLL,  ProgId = Msi.Handler(Msi.HandlerDebug)
{\line\f1\b  D   } Access the debug builds of the components (D suffix), rather than ship.
{\line\f1\b  B   } Access the Lego (BBT) builds of the components (L suffix), not available on Mac.
{\line\f1\b  U   } Unregister modules, otherwise register
{\line\f1\b  Q   } Quiet, no Errors show, returns non-zero status to batch file if failure.
{\line\f1\b  G   } Generate tool module, MsiGen(D).DLL,  ProgId = Msi.Generate
{\line\f1\b  L   } Localaize tool module, MsiLoc(D).DLL,  ProgId = Msi.Localize
{\line\f1\b  T   } Utilities tool module, MsiUtil(D).DLL,  ProgId = Msi.Utilities
{\line\f1\b  P   } Patch tool module,      MsiPat(D).DLL,  ProgId = Msi.Patch    
{\line\f1\b  C   } Acme convert tool module, MsiAcme(D).DLL,  ProgId = Msi.AcmeConvert
{\line\f1\b  ?   } Displays option letters
\par
The REGMSID.EXE tool is simply a debug build of the tool and is no different
in funtionality.\par
MAC NOTE: This tool cannot use command line arguments on the Mac, and thus
 only can register the components. A solution to this is being considered for unregistration.
 On the Mac, only the Automation module self-registers, as the others have no access to the registry, yet.
\page

#{\footnote MsiAlter_Tool}
${\footnote MsiAlter Tool}
K{\footnote MsiAlter}
+{\footnote Tool:MsiAlter}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
MSIALTER.EXE (formerly LOADPROP.EXE) Tool 
\par}\li180
The {\i\b MSIALTER.EXE} tool sets, updates, or displays launcher resources.  Also inserts cabinets or
 transforms into a Database.
\par
{\i\b Stuffing cabinets or transforms into the database:} \line
The tool can be used to stuff a cabinet or transform into the database storage.  For cabinets, use the syntax msialter \{database\} \{cabinet file\} where \{cabinet
 file\} is the full path to the cabinet and \{database\} is the full path to the database.  The cabinet
 will be stored as the base name in the database.  For example, if you specify the cabinet file as
 c:\\temp\\msproj1.cab, the c:\\temp\\msproj1.cab file will be opened and its data put into the database
 storage file as a stream whose name is msproj1.cab.  For transforms, use the syntax msialter -t \{database\} \{transform file\} where
 \{transform file\} is the full path to the transform file and \{database\} is the full path to the database.  Note, you
 don't have to use full paths if the transform or cabinet or database is in the same directory as msialter.exe.  Like the
 cabinet file, the transform file will be stored under its base name.  The transform is stored as a child storage of the
 database.  Note, OLE limits the size of streams and child storages allowed in the database.  This could be the cause of the
 'Unable to open child storage' error.  Currently, spaces are not allowed in the names of the cabinet stream or transform storage.
\par
{\i\b Setting or Updating resources:} \line
The tool can be used to set specific properties like DATABASE, ACTION, MESSSAGEBASE, and COMPANYNAME.  It can also update
 the ICON resource and insert a DATABASE, TRANSFORMS, and/or CABINET file resource(s) into the
 launcher.  The input is a text file of property and value pairs with one pair per text line.  Note that the end of
 line/carriage return is required for a property-value pair to be added. The
 delimiter between the property and value pair is the equals sign '='.  Only property  names that
 use no lower case characters can be set; however, the property names in the text file are case-insensitive.
 The value string in the text file is case sensitive.  File resources are designated by an at sign '@'
 preceding the name of the file in the value string.  The resource is loaded as a file resource in the
 launcher and its resource name is the base name [no path or file extension].  For the DATABASE property, an at
 sign loads the resource as a file resource and sets the DATABASE property to point to that resource using the
 @\{RESOURCE NAME\} syntax.  To specifiy languages for a property, use the following format: \{Property\}(langId)=\{Value\}
 where langId is the language in decimal form.  All file resources, CABINET, DATABASE, ICON, and TRANSFORMS are always
 netural and the DATABASE property is always neutral.  All other properties can have multiple languages associated
 with them.  If no language is specified, it is assumed to be language neutral or zero (0).  To remove an install
 property from the launcher, simply supply nothing after the delimiter as in the following format: \{Property\}(langId)=
    .  Only one DATABASE property/file resource and one ICON resource is allowed per launcher.  One can only specifiy
 a DATABASE property once in the property text file. 
\par
{\i\b Displaying resources:} \line
The tool can also be used to display the resources in the launcher.  It will display the install property resources as
 well as the transform, cabinet, database, and icon file resources.  Use of the -f option will dump the file resources into
 the current directory. The Icon file resource is displayed as ICON=@{exe name} where {exe name} is the executable whose
 resources the tool is displaying.
\par
{\i\b Command Line Syntax:} \line
{\b msialter \{database\} \{cabinet file\} } -- Stuffs the Cabinet file into the database \line
{\b msialter -t \{database\} \{transform file\} } -- Stuffs the Transform file into the database. \line
{\b msialter -l \{launcher\} \{property file\} } -- Loads resources in the property file into the
 launcher \line
{\b msialter \{launcher\} } -- Displays the resources in the launcher. \line
{\b msialter -f \{launcher\} } -- Displays the resources in the launcher and outputs the file resources
 to the current directory \line
\par
{\i\b Sample property file:} \line
COMPANYNAME(1032)=Microsoft \line
DATABASE=@testdb.msi \line
ICON=@cd.ico \line
MESSAGEBASE=32 \line
\par
{\i\b Comments on property file:} \line
COMPANYNAME(1032)=Microsoft sets the COMPANYNAME property to have the value of Microsoft in the Greek language.
 DATABASE=@testdb.msi loads the testdb.msi database as a file resource in the launcher.  It will be called TESTDB and
 the DATABASE property will contain the value @TESTDB.  ICON=@cd.ico changes the current icon resource in the launcher
 to display the cd.ico icon.  MESSAGEBASE=32 sets the MESSAGEBASE property to 32 in language neutral.
\par
{\i\b NOTE:} \line
This tool does not run on the current Windows95 release, as the API
 function UpdateResource is not implemented. It requires WindowsNT.
\page

#{\footnote MsiInfo_Tool}
${\footnote MsiInfo Tool}
K{\footnote MsiInfo}
+{\footnote Tool:MsiInfo}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
MSIINFO.EXE Tool To Modify A Database
\par}\li180
The MSIINFO.EXE tool uses the MSI database external API to edit or display the summary information of a
 database. It is a command line tool.
\par\fi-180\li180{\b Command Line Syntax}
{\line\f1 MsiInfo \{database\}}\line
Displays the Summary information of the database to the console\line
{\line\f1 MsiInfo \{database\} \{option\} \{data\}.....}\line
Sets the corresponding summary information property\line
\line The following case-insensitive command line options are supported (slash delimiter may also be used).
{\line\f1\b  -I   }  PID_DICTIONARY
{\line\f1\b  -C   }  PID_CODEPAGE
{\line\f1\b  -T   }  PID_TITLE
{\line\f1\b  -J   }  PID_SUBJECT
{\line\f1\b  -A   }  PID_AUTHOR
{\line\f1\b  -K   }  PID_KEYWORDS
{\line\f1\b  -O   }  PID_COMMENTS
{\line\f1\b  -P   }  PID_TEMPLATE
{\line\f1\b  -L   }  PID_LASTAUTHOR
{\line\f1\b  -V   }  PID_REVNUMBER
{\line\f1\b  -E   }  PID_EDITTIME
{\line\f1\b  -S   }  PID_LASTPRINTED
{\line\f1\b  -R   }  PID_CREATE_DTM
{\line\f1\b  -Q   }  PID_LASTSAVE_DTM
{\line\f1\b  -G   }  PID_PAGECOUNT
{\line\f1\b  -W   }  PID_WORDCOUNT
{\line\f1\b  -H   }  PID_CHARCOUNT
{\line\f1\b       }  PID_THUMBNAIL     !! NOT SUPPORTED !!
{\line\f1\b  -N   }  PID_APPNAME
{\line\f1\b  -U   }  PID_SECURITY
\line
\par
The data following the option is optional. If there is no data following the option, then the property is
 removed. The database must not be a readOnly database.  The same properties can be specified again on the
 command line, but only 20 switches can be used.  If the data for a particular option contains a space,
 encapsulate it in quotes, such as /T "MY TITLE".  The quotation marks notify the command line parser to
 ignore the space.  For the file time  properties, those being PID_EDITTIME, PID_LASTPRINTED, PID_CREATE_DTM,
 and PID_LASTSAVE_DTM, use the following format "year/month/day hour:minute:second" which is required to
 be "yyyy/mm/dd hh:mm:ss" (i.e. "1997/06/20 03:25:59).
\page

#{\footnote MsiDbVal_Tool}
${\footnote MsiDbVal Tool}
K{\footnote MsiDbVal}
+{\footnote Tool:MsiDbVal}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
MSIDBVAL.EXE Tool to Validate an Msi Database
\par}\li180
\line
!!! OBSOLETE !!!
The {\i\b MSIDBVAL.EXE} tool validates a *.msi database.  It utilizes 
the Validation tool module MsiVal(D).DLL for validation.  For any database 
to be validated, the tool requires that the {\uldb _Validation table}{\v _msi__Validation_Table@msi.hlp} 
 {\b ( _Validation table )} exist in that database.  This table contains the values allowed 
in the columns of all of the tables.  This is a console app and output is output 
to stdout or a pipe or handle if specified.  If any errors are found in validation, 
they are output to the screen. A valid database returns a valid database message.
\par
{\i\b COMMAND LINE SYNTAX:} \line
{\b msidbval \{database\} }
\page

#{\footnote MsiVal_Tool}
${\footnote MsiVal Tool}
K{\footnote MsiVal;Validation}
+{\footnote Tool:MsiVal}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
MSIVAL.EXE Tool to Validate an Msi Database
\par}\li180
The {\b MsiVal.EXE} tool validates a *.msi database.  It utilizes 
the external API for validation.  For any database 
to be validated, the tool requires that the {\uldb _Validation table}{\v _msi__Validation_Table@msi.hlp} 
 {\b ( _Validation table )} exist in that database.  This table contains the values allowed 
in the columns of all of the tables.  The msival.exe tool also performs the Missing
 Columns validation in which any column defined in the _Validation table, but not in the
 Columns catalog of the database is considered an error.  If one wishes to add a new
 table/column, then one has to add the corresponding entry(ies) to the _Validation table.
  If one removes an {\b optional} column {\i(no way of regulating this except through the
 authoring environment)}, then one has to remove the corresponding entry from the
 _Validation table.  The _Validation table is not shipped, and is merely used for
 validation during authoring.  The Missing column validation code is external to the
 Darwin code.  This is a console app and output is output 
to stdout or a pipe or handle if specified.  If any errors are found in validation, 
they are output to the screen. A valid database returns a valid database message.
\par
\line
{\i\b Required Tables:}\line\line
Depending on the validation, the following tables are required for the msival.exe tool to work\line
{\f1 _Validation:} Required when using the external APIs for validation.\line
{\f1 _Required:} Required for the 'Required' validation.  Not needed if use -OFF option\line
{\f1 _InstallSequence:} Required for the 'Organizational' InstallSequence validation.  Not needed if use -OFF option\line
{\f1 _Sequence:} Required for the 'Sequential' InstallSequence validation.  Not needed if use -OFF option\line
\line
{\i\b Command Line Syntax:} \line\line
{\b msival \{database\} } --> All validation (missing column, data/foreign key, required, organizational install, sequential install)\line
{\b msival \{database\} -OFF } --> Missing column and data/foreign key validation \line
\line
{\i\b How Validated:}\line\line
{\f1 Missing Columns:}\line
Use the _Validation table and ensure that every column listed in the _Validation table is also listed in the _Columns catalog
 of the database. (Normal validation using the API's catches the other way from _Columns to _Validation)\line
{\f1 Required:}\line
Use the _Required table and ensure that the values are found in the particular table.  This only makes sure that the primary
 keys are there, not that the values are valid.  See below for table definition information.\line
{\f1 Install Organization:}\line
Use the _InstallValidate table and ensure that the organization of the actions fall in the sections defined in the table.  If
 an action is not listed in this table, it is assumed to be either a Dialog or a Custom Action and checked to be sure that
 it is found in either the Dialog or CustomAction tables.\line
{\f1 Install Sequence:}\line
Use the _Sequence table and ensure that the actions occur in the correct order.  Some actions have pre and post conditional
 actions. \line
\line
{\i\b Table Definitions (except _Validation)}\line\line
{\f1 _Required}\line
Table (string, primary key, required) -- name of table with said required value\line
Value (string, primary key, required) -- required value, if multiple primary keys, then it is a delimited list (separator is semi-colon)\line
KeyCount (short, required) -- number of primary keys in table\line
Description (string, optional) -- description of required value\line
\line
{\f1 _InstallValidate}\line
Action (string, primary key, required) -- name of action (do not list Dialog or CustomActions here!!)\line
SectionFlag (integer, required) -- flag value of sections, 1 or more of the following:\line
{\i Search --> Searching actions, from LaunchConditions to RMCCPSearch}\line
{\i Costing --> Costing actions}\line
{\i Selection --> UI actions, CustomActions, etc.}\line
{\i Advertise --> RegisterProduct, PublishProduct, PublishFeatures, PublishComponents actions}\line
{\i Execution --> Script operations, InstallFiles, etc}\line
Other notes:\line
1.) Divisor between search and costing is CostInitialize\line
2.) Divisor between costing and selection is CostFinalize\line
3.) Divisor between selection and advertise is RegisterProduct\line
4.) Divisor between advertise and execution is InstallValidate\line
5.) If any advertise or execute action called, then ExecuteFinalize must be called\line
6.) A call to ExecuteFinalize resets section to search so more actions can occur afterwards\line
\line
{\f1 _Sequence}\line
Action (string, primary key, required) -- name of action (do not list Dialog or CustomActions here!!)\line
Dependent (string, primary key, required) -- action required to come before or after said action\line
After (boolean, required) -- 0 if action comes before dependent, 1 if action comes after dependent\line
Optional (boolean, required) -- (ignored for 'Before') 0 if action is not optional, 1 if optional\line
Other notes:\line
1.) Temporary column is created for marking 'dependent' action of actions\line\line
2.) As action is encountered in InstallSequence table, its sequence number if filled in for every row of the
 _Sequence table where the 'Dependent' action value equals the current action (thus marking the temp column)\line\line
3.) Two special queries are done for the _Sequence table (one for 'Before' and one for 'After' actions)\line\line
4.) The result sets of the fetches are important, as the idea is to not have a result set for valid (explained below)\line\line
a.) Action Is To Go After A Required Dependent Action And Marking Column Is  Zero --> ERROR\line
Explanation: A preceding action is required before this one, but it hasn't been found, so this is an error\line\line
b.) Action Is To Go After A Required Dependent Action And Marking Column Is Not Zero --> CORRECT\line
Explanation: A preceding action is required before this one, and it has been found, so this is valid\line\line
c.) Action Is To Go After An Optional Dependent Action And Marking Column Is Zero --> CORRECT\line
Explanation: This action doesn't have to be listed, but if it were to be found (some point after us, it would be caught as
 if the _Sequence table is authored correctly, the Dependent Action would have us listed as coming Before them so we
 would be caught in that pass)\line\line
d.) Action Is To Go After An Optional Dependent Action And Marking Column Is Not Zero --> CORRECT\line
Explanation: This action must come after an optional dependent action which happens to be listed before us, so this is valid\line
\line{\i\bThe Optional/Required Attrib is ignored for Before conditions}\line\line
e.) Action Is To Go Before Optional/Required Dependent Action And Marking Column Is Zero --> CORRECT\line
Explanation: Action is supposed to come before the dependent action and the dependent action hasn't been seen yet, so this
 is valid\line\line
f.) Action Is To Go Before Optional/Required Dependent Action And Marking Column Is Not Zero --> ERROR\line
Explanation: Action is supposed to come before the dependent action, but the dependent action has already been found, so this
 is invalid\line\line
\line
{\i\b Extensibility of Validation}\line
Validation is very extensible, as it is dependent upon tables, so changing the _Validation, _Required, _InstallValidate, and
 _Sequence tables will change validation.\line
\page

#{\footnote MsiTran_Tool}
${\footnote MsiTran Tool}
K{\footnote MsiTran}
+{\footnote Tool:MsiTran}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
MSITRAN.EXE Tool to Generate, Apply, or View a Transform file
\par}\li180
The {\i\b MSITRAN(d).EXE} tool can generate or apply a transform file  and can be used to
 view the transform file.  It utilizes the external API.  \par
{\i\b COMMAND LINE SYNTAX:} \line
{\b msitran(d) -g \{base db\} \{ref db\} \{transform file name\} [\{error conditions\}] --> Generate a Transform file }\line
{\b msitran(d) -v \{transform\} \{base db\} --> View a Transform file}\line
{\b msitran(d) -a \{transform\} \{database\} [\{error conditions\}] --> Apply a Transform}\line
\line
Error Conditions:\line
The following errors may be suppressed when applying a transform.
 To suppress an error, include the appropriate character in
 the \{error conditions\} argument. Conditions specified with -g are placed in
 the summary information of the transform, but are not used when
 applying a transform with -a.\line
\line
{\f1 'a': }Add existing row.\line
{\f1 'b': }Delete non-existing row.\line
{\f1 'c': }Add existing table.\line
{\f1 'd': }Delete non-existing table.\line
{\f1 'e': }Modify existing row.\line
\page

#{\footnote MsiMerge_Tool}
${\footnote MsiMerge Tool}
K{\footnote MsiMerge; MsiMerg}
+{\footnote Tool:MsiMerge}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
MSIMERG.EXE Tool to Merge a database into another
\par}\li180
The {\i\b MSIMERG(d).EXE} tool can a database into another.  If MergeConflicts are reported, information
 is placed in the _MergeErrors table.  Note, the _MergeErrors table may not always be created depending
 on the error that occured (an error not related to the actual merge of the data).  It utilizes the external API.  \par
{\i\b COMMAND LINE SYNTAX:} \line
{\b msimerg(d) \{base db\} \{ref db\}}\line
\page

*{\footnote Dev}
#{\footnote Coding_AutomateMethod}
${\footnote Automating C++ method}
K{\footnote Automate}
+{\footnote Coding:AutomateMethod}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
Steps to Exposing a C++ Method to Automation
\par}\li180
The following describes the series of operations that must be performed
 in order to expose a C++ method to OLE Automation and Object browers,
 including help topics, for use with VBA applications.
\par
For each C++ class that is exposed to OLE automation, a shadow class is
 defined which is derived from the common base class CAutoBase, and which
 simply holds a pointer to the C++ object. A member function is defined for
 each property or method exposed. All such functions take argument stack
 object, which abstracts the complicated Variant arguments and return values.
 All functions have a void return, as they throw exceptions on any error.
\par
C++ functions that get and set values are usually exposed as properties, with
 the "Get" and "Set" part of the names removed. If both a Get and a Set are
 present, they will likely be exposed as a single property. Since all data is
 passed as Variant unions, multiple functions that vary only in data types can
 sometimes be combined into a single function. Also note that properties can
 accept arguments, such that access to data from a particular field can be
 exposed as an indexed property. These index arguments may be of any data type.
\par\li0{\b Automation Wrapper}\par\li180
Add function to wrapper class definition:
\line {\f1   void MyFunc(CAutoArgs& args);}\line
Add implementation function that processes the arguments and return values:{\f1
\line  void CAutoFoo::MyFunc(CAutoArgs& args)
\line   \{
\line      args = m_riFoo.MyFunc(args[1], args[2]);
\line   \}}
\par\li0{\b Dispatch Table Entry}\par\li180
Add an entry to the dispatch table, supplying function and argument names,
 separated only by a comma. The convention is that both are mixed case,
 but the method or property names start with upper case, and the argument
 names start with lower case. Each entry in the dispatch table must be
 assigned a unique dispatch Id, normally starting with the number 1. The
 value 0 denotes the default property, which is called if the object itself
 is used in the context of a value, i.e. assignment or function argument.
 Properties use {\f1 aafPropRW} or {\f1 aafPropRO} instead of {\f1 aafMethod}.
\line {\f1  10, aafMethod, CAutoFoo::MyFunc, "MyFunc,arg1,arg2", }
\line 
\par\li0{\b ODL Specification}\par\li180
To expose the method in the type library, the prototype of the exposed
 method or property must be defined in ODL syntax, along with the help info:{\f1
\line   [id(10),helpcontext(MsiFoo_MyFunc),helpstring("What MyFunc does.")]
\line      Boolean MyFunc([in] long arg1, [in] BSTR arg2);}
\par\li0{\b Help Context ID}\par\li180
In the file "msiauto.hh", the help context Id must be defined. This file is
 used to compile the ODL file to the type library and to generate the help file.
 To insure uniqueness of the Ids, the low two digits are the same as the
 dispatch Id, and the upper digits are the decimal equivalent of the low byte
 of the GUID defined for the class.
\line {\f1   #define MsiFoo_MyFunc  1510}
\par\li0{\b Help Topic}\par\li180
Generate a new topic, including the necessary header information. It is best
 to copy an existing topic or the sample topic, and modify it as required.
*{\footnote Dev}
{\f1\line   *\{\\footnote VBA\}            }{\i <-Build tab, must be first}
{\f1\line   #\{\\footnote MsiFoo_MyFunc\}  }{\i <-Topic Id}
{\f1\line   $\{\\footnote MsiFoo.MyFunc\}  }{\i <-Topic Title, diplayed in Find}
{\f1\line   +\{\\footnote MsiFoo:MyFunc\}  }{\i <-Browse Sequence Id}
{\f1\line   K\{\\footnote MyFunc;Internet\}}{\i <-List of keywords, separated by ';'}
{\f1\line   \\pard\\f0\\cf1\\sb90           }{\i <-Restore paragraph and text styles}
{\f1\line   \{\\li-150\\fi150\\brdrb\\fs24\\b }{\i <-Set special format for heading}
{\f1\line   MyFunc Method               }{\i <-Heading text, larger font size, bold}
{\f1\line   \\line\\tx360\\tab\\fs18\\b0\{\\uldb MsiFoo Object\}\{\\v MsiFoo_Object\} }
{\f1\line   \\tx3000\\tab\{\\uldb Msi Objects\}\{\\v Msi_Objects\} }{\i <-Hot links}
{\f1\line   \\tx5000\\tab\{\\uldb Database Tables\}\{\\v Database_Tables\} }
{\f1\line   \\par\}\\li180                 }{\i <-End of heading, set normal indent}
{\f1\line   Tell what MyFunc does here. }
{\f1\line   \\par\\li0\{\\b Syntax\}\\par\\li500\\fi-320 }{\i <-Hanging indend}
{\f1\line   \{\\i object\}\{\\b .MyFunc(\{\\i arg1, arg2\})\} }
{\f1\line   \\par\{\\i object\}\\line }
{\f1\line   Required. The MsiFoo object. }
{\f1\line   \\par\{\\i\\b arg1\}\\line }
{\f1\line   Required. Description of a required argument. }
{\f1\line   \\par\{\\i\\b arg2\}\\line }
{\f1\line   Optional. Description of an optional argument. }
{\f1\line   \\par\\fi0\\li0\{\\b Remarks\}\\par\\li180 }{\i <-No indent, bold title, normal indent}
{\f1\line   Additional notes as required.... }
{\f1\line   \\page                       }{\i <-End of topic}
\par\li0{\b Help References}\par\li180
Incorporate links to the new topic inside other relevent topics. In particular,
 include the new topic under the appropriate {\b Methods} or {\b Properties}
 section within the topic for the class itself.
\line {\f1  \{\\uldb DoAction\}\{\\v MsiEngine_DoAction}\\line
\par\li0{\b Help Contents Entry}\par\li180
In the help contents file, "msiauto.cnt" for the VBA help file, the new topic
 must be inserted in the proper place in the topic hierarchy. The single digit
 at the start of each line is the tree level. Spaces are inserted only for
 clarity when editing this file. The first symbol is what is shown in the
 contents view.  Following the equal sign is the help topic Id.
\line {\f1   3 MyFunc=MsiFoo_MyFunc }
\page

*{\footnote Dev}
#{\footnote Coding_HelpFile}
${\footnote Coding Help File}
K{\footnote Help;RTF}
+{\footnote Coding:HelpFile}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b\keepn
Help Source File Syntax
\par}\li180
This topic describes the syntax and tokens used to develop help topics for
 Microsoft Installer. For a complete reference, use the VC++ help file
 {\uldb HCW.HLP}{\v RTFHelpRTFStatementReference@HCW.HLP}.
\par\li0{\b General RTF notes}\par\li180
The RTF format used in help files is a subset of that used by word processors.
 Some of the tokens have been usurped to have different meanings. Tokens always
 begin with a backslash and must be followed with a space (ignored), another
 backslash, or a brace character. Enclosing tokens within braces restricts their
 effect to the text enclosed within the braces. The entire RTF souce file must
 also be enclosed in a set of braces (take care not to delete the ending brace.)
\par
Line breaks are ignored in RTF files, but spaces are displayed except for the
 space immediately following an RTF token. Avoid accidently use of tab characters.
 When wrapping text, the space between words must be included. The convention here
 to avoid errors is to indent each wrapped line by a single space.
\par\li0{\b Text format tokens}\par\li180
These tokens change the following text style, independent of paragraph formatting.
 The change ends when the value is restored, either by explicitly restoring the
 previous value or preferably by enclosing the token with the affected text in braces.
 Avoid using "{\f1\\plain}" as this will reset the font size set in the file header.
{\f1\line   \\b     } Starts {\b bold} text, ends at {\f1\\b0} or closing {\f1\}}.
{\f1\line   \\i     } Starts {\i italic} text, ends at {\f1\\i0} or closing {\f1\}}.
{\f1\line   \\f1    } Starts {\f1 font number 1} (fixed-pitch here), ends at {\f1\\f0} or closing {\f1\}}.
{\f1\line   \\fs16  } Starts {\fs16 font size 8} (half the value), ends at next {\f1\\fs} or closing {\f1\}}.
\par\li0{\b Paragraph format tokens}\par\li180
These tokens affect line indentation and spacing, and will be reset either by
 the {\f1 \\pard} token, or by the ending brace if the token is enclosed in braces.
{\f1\line   \\tab    } Inserts a tab character, moves to the next tab stop
{\f1\line   \\line   } Forced line feed within a paragraph
{\f1\line   \\par    } Start a new paragraph
{\f1\line   \\li300  } Specified the line indent from left margin in twips (1\1440 inch)
{\f1\line   \\fi-100 } Specified the first line indent relative to the line indent
{\f1\line   \\sb90   } Specifies the extra space before paragraph in twips
{\f1\line   \\tx500  } Specifies the location of a single tab stop in twips
\par\li0{\b Topic header tokens}\par\li180
These tokens must placed at the start of each topic.
 Each topic must be terminated with a {\f1 \\page} token.
 If build tags are specified, the topic will only be included based on the 
 {\f1\b BUILD} expression in the help project file (.HPJ).
 Topics may be group into a browse sequence, enabling the next and previous buttons,
 by specifiying browse identifiers with identical text before the colon.
 The build tag and keyword tokens may be repeated as necessary.
{\f1\line   *\{\\footnote VBA\}            } Optional build tag, must be first tokens
{\f1\line   #\{\\footnote MsiFoo_MyFunc\}  } Required Topic Id, used by links and contents
{\f1\line   $\{\\footnote MsiFoo.MyFunc\}  } Topic Title, diplayed in Find and History
{\f1\line   +\{\\footnote MsiFoo:MyFunc\}  } Optional Browse Sequence Id, group and sequence
{\f1\line   K\{\\footnote MyFunc;Internet\}} Optional list of keywords, separated by ';'
\par\li0{\b Hot links}\par\li180
These paired tokens create hot spots, displayed as green underlined text.
{\f1\line   \{\\uldb Hot Spot Text\}\{\\v Help_Topic\}  } Jumps to another topic
{\f1\line   \{\\ul Hot Spot Text\}\{\\v Help_Topic\}    } Creates a popup window
\par\li0{\b File header tokens}\par\li180
These tokens are required to appear at the start of each RTF file.
 In addition, the default font size for the file is set to 10 points
 with the token: {\f1 \\fs20}.
{\f1\line   \\rtf1           } Identifies the file as RTF, must be first.
{\f1\line   \\ansi           } Identifies the character set
{\f1\line   \{\\fonttbl\{\\f0\\fswiss Arial;\}\{\\f1\\fmodern Courier New;\}\} }Font table
{\f1\line   \{\\colortbl;\}    } Color table, only color 0, black, is used here.
\page

*{\footnote Dev}
#{\footnote Coding_MemoryLeaks}
${\footnote Coding Memory Leaks}
K{\footnote Memory Leaks}
+{\footnote Coding:Memory Leaks}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b\keepn
Tracking Down Memory Leaks
\par}\li180
Memory errors come in two flavors. 
 Rarely seen, but possible is a
 list of memory blocks not freed when the services DLL goes away.
 More common is an assert the CMsiMalloc was not released and then a list
 of memory blocks not freed.
 The first case happens when everyone releases CMsiMalloc correctly.
 The second happens when someone holds on to CMsiMalloc without releasing it
 and we assert when the destructor for the object is called when the DLL is being
 removed by the system.
 Both give a stack backtrace of when the memory was allocated, hopefully with function
 names. They should also print out the type of object and which allocation it was
 made on.
 In order to get the stack backtrace to give function names, you need some DLLs in your
 system or system32 directory to allow Darwin to interpret the PDB files.
\par
On Win95 and NT you need imagehlp.dll and mspdb50.dll in your system32 directory.
\par
If you think you have this set-up and it's not working, see DavidMck.
\par
The memory management code also allows you to increase the size of the stack back trace
 if you need more data kept to make it easier to debug. There is a #define at the beginning
 of imemory.cpp for cFuncTrace. It is currently set to 4 by default. You can adjust it as
 needed.
\par
The output of the asserts should go to the log file if the log is open and set on the command
 line. Otherwise the output of all asserts goes to the file c:\msidbg.log.
\par
Generally memory leaks are either a simple case of not freeing something that was allocated, or
 a more complex issue of a reference counting problem. We have integrated code to help track
 down reference counting issues. See {\uldb Reference Tracking}{\v Coding_RefTracking} for
 more information on those features.
\page

*{\footnote Dev}
#{\footnote Coding_DebugMemMgr}
${\footnote Coding Debug Memory Manager}
K{\footnote Debug Memory Manager}
+{\footnote Coding:Debug Memory Manager}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b\keepn
Hooking up the Debug memory manager
\par}\li180
The debug memory manager is hooked up for the main darwin DLLs. There are two cases
 where you will need to hook it up your self to either make debugging easier or get
 your new object to work.
\par
The debug memory manager overloads the new and delete operators. In order to work, a global
 piMalloc needs to be set (since we have globally defined the new and delete overloaded functions).
 These functions are in imsimem.h.
 In order to set piMalloc you need to call SetAllocator with a pointer to a services object.
 The allocator will be retrieved from the services object. We also keep a count for the DLL of how
 many objects have called SetAllocator. This is needed since some DLLs contain multiple objects
 that do not hold references to each other.
 When your object that called SetAllocator is being deleted, you will want to call ReleaseAllocator.
 The object that calls SetAllocator, however, cannot be allocated with the overloaded new and delete
 operators since piMalloc will probably not be set correctly. In order to handle this we have
 functions AllocSpc and FreeSpc which should be included as public member functions of your class
 as follows.
\par\tab
static void *operator new(size_t cb) \{ return AllocSpc(cb); \}
\par\tab
static void operator delete(void * pv) \{ FreeSpc(pv); \}
\par
If you include imsimem.h in all the source files of your DLL, and appropriately hook up SetAllocator,
 ReleaseAllocator, AllocSpc and FreeSpc, you should have the Darwin memory management installed. I would
 urge that we have this done in all our DLLs in order to track down memory issues.
\page

*{\footnote Dev}
#{\footnote Coding_RefTracking}
${\footnote Coding Reference Tracking}
K{\footnote Reference Tracking}
+{\footnote Coding:Reference Tracking}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b\keepn
Tracking Down Reference Counting Problems
\par}\li180
The services DLL (and in the future other Darwin DLLs) has a reference counting harness built in
 to it to aid in tracking down problems with AddRefs and Releases.
 Currently it is only useful in tracking down problems where objects are not released correctly. I
 plan to add code to handle the case where an object is released too many times.
\par
The code hooks in to the AddRef and Release calls and uses the CMsiRef ref object which encompases
 the m_iRefCnt as well as pointers to keep a link list of objects and a list of reference counting
 actions and the stack track of each action.
\par
Due to the overhead imposed by keeping the tracking data this functionality is turned on for individual
 classes. The environment variable TRACK_OBJECTS should be set to a comma separated list of darwin iids
 which you wish to have tracked (you just need to use the low byte of the iid so to track services
 set TRACK_OBJECTS=B).
\par
A static object that is an object of the CMsiRefHead class checks for objects not deleted in its
 destructor. At that point it will assert with a list of actions and the stack track for those actions.
 This info is also placed in the debug log (since usually the normal log has been closed by this point
 in the process).
 Using this information it is usually quite simple to look at the log and pair up AddRef and Release
 calls until you end up with one or more AddRefs that shouldn't have happened. Looking through the code
 you can then uncover the problem.
\par
As with the memory manager you can increase the size of the stack backtrace that is recorded if you
 need more information. In imsidbg.h the defined value cFuncStack defaults to 3 currently and can
 be adjusted as necessary.
\page


*{\footnote Dev}
#{\footnote Coding_CodeReview}
${\footnote Code Review guidelines}
K{\footnote Code Review guidelines;Coding conventions;Variable naming}
+{\footnote Coding: Code Review guidelines}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b\keepn
Coding Conventions and Code Review Guidelines
\par}\li180
{\b General Coding Conventions}
\par
{\ul Tabs}\line
* Every 3 columns, i.e. 1,4,7..., but only before the first non-white space character on the line.\line
* Use tabs rather than spaces to indent lines, no tabs between any text on a line.\line
* Avoid trailing white space on a line (expecially important for help .RTF files).\line
* Avoid lines greater than 80 characters when possible (hard to diff and print).\line
* When wrapping lines with multiple arguments, indent (with tabs) to line up the args if possible.\line
* A utility exists, FIXTAB.EXE (from OTOOLS), to indicate or correct tab problems.\line
\line
{\ul Braces}\line
* Opening and closing braces line up with each other and with the enclosing scope.\line
* Code within braces indented one tab stop.\line
* Braces may optionally be omitted for single line clauses following if, else, for, etc.\line
* Lines with switch case values are lined up with the switch braces, code lines are indented.\line
\par

{\b Variable naming}
\par
{\ul Global Variables}\line
Use the "g_" prefix followed by the Hungarian name. Ex: int g_cInstances\line
\line
{\ul Member Data Variables}\line
Use the "m_" prefix followed by the Hungarian name. Ex: int m_iRefCnt\line
\line
{\ul COM Object Methods}\line
Use mixed-case non-Hungarian (OLE Standard); args use Hungarian prefixes.\line
Ex: int GetPropertyLen(const ICHAR* szProperty)\line
\line
Methods that return enumerators should be named Get{Item}Enumerator. \line
Ex: IEnumMsiString* GetSubFolderEnumerator()\line
\line
{\ul COM Pointers And References}\line
Use the "pi" (pointer to interface) and "ri" (reference to interface) prefixes followed by the variable name,
 followed by the object type.  Do not include the type of instance pointer in the hungarian prefix.
For the standard Darwin objects, preferred naming convention examples are:\line
\line
{\f1
IMsiString*:   piComponentString (not pistrComponent)\line
IMsiRecord&:   riErrRecord (riErrRec is also common in Darwin code, and is ok)\line
IMsiCursor*:   piFeatureCursor\line
IMsiTable*:    piFeatureTable\line
IMsiDatabase&: riDatabase\line
IMsiEngine&:   riEngine\line
IMsiPath&:     riSourcePath\line
}
\line
{\ul MsiString}\line
Use the "str" prefix followed by the variable name. After the prefix follow the same
convention as for COM pointers. Ex: MsiString strUserName.\line
\line
{\ul Wrapper COM Pointers (PMsi...)}\line
Use the "p" prefix, followed by the same convention as for "COM Pointers and References".
 Ex: PMsiRecord pErrorRecord(0); \line
\par

{\ul Usage of char[], ICHAR[], IMsiString, and MsiString types}
\par
IMsiString is Darwin's string interface. It provides reference-counted string handling. An MsiString
 is a wrapper object around an IMsiString interface. The MsiString class simplifies string handling
 by automating the reference-counting.
\par
Avoid the use of the char data type except where 8-bit bytes are used.
 Use ICHAR to refer to text characters; this define is current char but eventually will be
 changed to wchar_t (16-bit) when we convert Darwin to Unicode.
 Avoid the direct use of strlen, strcpy, strcat (run-time library functions).
 Use the string functions defined in ISTRING.H: IStrLen, IStrCopy, etc.
 These are wrappers for system APIs that are DBCS enabled. These will change to Unicode someday.
 For non-trivial string handling, use the IMsiString and MsiString objects.
\line
\par
{\b Type}
\par
Avoid the use of Windows-defined macros, such as WORD, whenever possible; use the inherent C type instead.
 The exception is local variables used directly as in/out parameters to Windows API.
 For boolean values, use the Darwin Bool enum, to allow type checking and automation conversion.
 Avoid #defines whenever possible; use "const int" or other const values instead. This allows full
 type checking without generating additional code. Use the int type when size doesn't matter, since that is
 processed most efficiently.
\line
\par
{\b Header Files}
\par
 Only put defines in header files that are required by more than one source file. Otherwise,
 dependencies may inadvertently be created by exposing internal structures.
 Define derived implementation classes at the start of the .CPP file when possible.
 Headers local to a module are put in the same directory as the .CPP files
 Put detailed method comments in the help file, put the help file source name in the header
 Put comments in the header file describing classes defined and include and define requirements.
\line
\par
{\b Function calls}
\par
All calls to functions other than a member function of the current object, or a static member of another class, 
 should be qualified with one of the dummy specifiers below to indicate the API that is being used. Unspecified
 global functions can use just a "::" prefix, such as ::operator new.\line
\line
Currently the following API dummy specifiers are defined (all defined to nothing):\line
WIN::  - Win32 API call, fails on Mac\line
MAC::  - Mac API call, fails on Win32\line
OLE::  - OLE API call, fails on modules not using OLE\line
AUT::  - Local automation DLL functions\line
SRV::  - Local services DLL function\line
LOC::  - Functions local to a file\line
\par
{\b Procedure headers}
\par
All procedures should be well documented, with all input and return parameters described.  If the procedure
 is an interface function of any object exposed through an IMsi* COM interface, the documentation for that
 function should reside in the MSIAUTO help file (not in the source code).  In this case, the function header
 should be formatted like this example:\line
 \line{\f1
IMsiRecord* CMsiEngine::GetFeatureCost(IMsiString& ristrFeature, int& iCost)\line
//----------------------------------------------\line
\{\line
...\line
\}\line
}
\line
If the procedure is a local function (whether global, or a protected or private member of a class), then
 the documentation should appear in the function header, as in this example:\line
\line {\f1
ifiEnum CMsiPath::GetFileVersion(const ICHAR* szFullPath, int& riMS, int& riLS )\line
/*----------------------------------------------------------------------------\line
Gets the file version values from the given file and sets the given riMS & \line
riLS variables.\line
\line
Arguments:\line
	szFullPath: a zero terminated character string containing the fully\line
		qualified path (including disk drive) to the file.\line
	riMS: Most significant 32 bits of source file version stamp.\line
	riLS: Least significant 32 bits of source file version stamp.\line
Returns:\line
	ifiNoError-       Version retrieved successfully \line
	ifiNoFile-        Specified file does not exist\line
	ifiNoFileInfo-    Specified file has no version\line
	ifiFileInfoError- An error occurred while trying to retrieve the version\line
------------------------------------------------------------------------------*/\line
\{\line
...\line
\}\line
}
\line
\par
{\b General Code Review Checklist}
\par
Here are a few of the important issues, and potential problems, to look for when reviewing code:\line
\line
* Are all input values and return values well-defined?\line
\line
* Are all return states well-defined and correct?\line
\line
* Are potential errors returned by function calls always being handled properly?\line
\line
* Are there any "magic numbers" that should be made into well-defined constants?\line
\line
* Are there any useful assertions (or other debugging code) missing?\line
\line
* Are comments correct and concise?\line
\line
* Any code that is commented or #IFDEF'ed out should either be taken out, or well commented
 as to why the code isn't being used.\line
\line
* Are any header files included that are unnecessary?\line
\line
* Is there code here that duplicates code found elsewhere in the project?\line
\line
* Are there any local variables which are used only once, where a constant value might be better?\line
\line
* Are there any unnecessary globals?\line
\line
* Are there any other performance problems?\line
\line
\par
{\b Specific problems to watch for}
\par
* Is the value returned by the GetLastError() system call being interpreted properly?  Remember that the error
 code returned by GetLastError() gets reset on every system call (successful or not), so a better name for it
 would be GetLastStatus().\line
\page

#{\footnote Coding_UsingMemMgr}
${\footnote Coding Using Debug Memory Manager}
K{\footnote Using Debug Memory Manager}
+{\footnote Coding:Using Debug Memory Manager}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b\keepn
Using the Debug memory manager
\par}\li180
The debug memory manager has several flags you can set to change how it works.
\par
Setting the environment variable DEBUGMEM or calling the {\uldb SetDebugFlags}{\v MsiMalloc_SetDebugFlags} method
 on an allocator from VB allows you to set several flags.
\par 1\tab Does not actually free memory. 
 Places it in a linked list for comparing with future free requests.
 Useful for tracking down doubly freeing memory.
\par 2\tab Logs all allocations to the debug log file.
\par 4\tab Checks the status of all memory blocks when a block is allocated
\par 8\tab Checks the status of all memory blocks when a block is freed.
\par 16\tab Only initializes the symbol information when it's needed.
 This is useful when tracking down a memory leak when the EXE terminates and frees
 memory. There are currently problems with the symbol information being freed when
 this happens.
\page

#{\footnote Coding_BuildingDatabases}
${\footnote Building the databases}
K{\footnote Building the databases}
+{\footnote Coding:Building the databases}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b\keepn
Building the databases
\par}\li180
The makefile currently builds five databases during the debug build process: {\f1 testdb.msi}, {\f1 template.msi},
 {\f1 schema.msi}, {\f1 testcab.msi}, and {\f1 repack.msi} and then validates all five (validation won't catch
 everything though).
\par {\b Source directories for the databases}\line
{\f1  testdb.msi    } %DARWIN%\\data\\testdb \line
{\f1  template.msi  } %DARWIN%\\data\\template \line
{\f1  schema.msi    } %DARWIN%\\data\\schema \line
{\f1  testcab.msi   } %DARWIN%\\data\\testdb.cab \line
{\f1  repack.msi    } %DARWIN%\\src\\tools\\repack\\support \line
\par {\b Build order}\line
{\f1 first  } schema.msi \line
{\f1 second } template.msi \line
{\f1 third  } testdb.msi \line
{\f1 fourth } testcab.msi \line
{\f1 fifth  } repack.msi \line
\par {\b What's in the databases}\line
{\f1 schema.msi   } contains defined _Validation table, all other table schemas (no row data)\line
{\f1 template.msi } basic UI, install sequences and actions \line
{\f1 testdb.msi   } UITEST, sample install \line
{\f1 testcab.msi  } sample install \line
{\f1 repack.msi   } repackager template database, some extra tables (i.e. SourceDirectory)\line
\par {\b How built}\line
{\f1 schema.msi   } create new, import from schema source\line
{\f1 template.msi } create new, import from template source, merge in schema.msi \line
{\f1 testdb.msi   } create new, import from testdb source, merge in template.msi \line
{\f1 testcab.msi  } create new, import from testcab source, merge in template.msi, add msproj1.cab\line
{\f1 repack.msi   } create new, import from repack source, merge in template.msi \line 
\par {\b Making changes}\line\line
{\f1 Table schema changes}\line
\tab When adding, removing, or modifying columns or tables, always change the .idt file in
 the schema source.  If the table also exists in one of the other four source directories, be sure to
 change it there as well (or merge problems or worse could arrise). {\b Always remember to make
 the change to the {\uldb Validation table}{\v _msi__Validation_Table@msi.hlp} as well.}  You will also have to
 modify the _Validation table in %DARWIN%\\data\\testdb.cab\\validate as it is another copy of the
 _Validation table which was required since the cabinets were generated before the decision to
 enforce the primary key as token rule.\line\line
{\f1 Bumping the Database version}\line
\tab When the database version is bumped up, edit the _Summary.idt tables in all five source
 directories.  Merging does not deal with the {\uldb Summary Information}{\v Summary_Overview} stream.\line\line
 {\f1 Changing the _Validation table}\line
 \tab When changing the entries in the _Validation table, be sure to change it in schema source and in
  the _Validation table in %DARWIN%\\data\\testdb.cab\\validate.  If you add a new table particular to
  only one database (and not any others), update or add the _Validation table and the entries required
  for the new table or column.  During merging, the database will import those new entries and
  receive the rest from the merging of the other database (which will bring schema.msi's _Validation
  table).\line\line
{\f1 Other}\line
\tab Make sure all of the databases pass validation and that the '_MergeErrors' table is not
 created as it means that merge conflicts occured and those conflicts should be investigated.
\page


#{\footnote Msispy_Tool}
${\footnote Msispy Tool}
K{\footnote Msispy}
+{\footnote Tool:Msispy}
\pard\f0\cf1\sb90{\li-150\fi150\brdrb\fs24\b
MSISPY: A Tool to Display Component-Level View of System
\par}\li180
\line
{\i\b MSISPY} provides a component level view of the products and features installed on a system,
 using either a Darwin database, or the registry information. Msispy also displays the status of
 each, and allows you to partially or completely re-install missing or damaged items. You  can also
 re-configure any product or feature, selecting the install level, and specifying whether to install
 it locally or run it from a network server. \line\line
{\b Menu Options}\line\line
 Under the {\b File} Menu,\line
\tab {\i\b Open Any Database} allows you to open an MSI package.\line
\tab {\i\b Open Local Database} uses the registry information to display information about all the\line
\tab   products installed on the computer.\line
\tab {\i\b Load Saved Profile} allows you to load a profile of the system previously saved by Msispy.\line
\tab {\i\b Restore Profile} (enabled only when a profile is loaded) attempts to restore the system\line
\tab   to the saved profile. If more components have been added since the profile was saved, they\line
\tab   are left untouched. If some products or components have been damaged since the profile was\line
\tab   saved, msispy attempts to restore them by attempting to re-install them from the original\line
\tab   source. If the source is not available, you are given the option to abort, retry or ignore.\line
\tab {\i\b Save Current Profile} allows you to save a complete profile of the system onto a file. The\line
\tab   information is stored in an easy to read text format. This information should not be modified\line
\tab   directly.\line\line
 Under the {\b View} Menu,\line
\tab {\i\b Refresh} refreshes the display by getting the displayed information again and redrawing it.\line\line
 Under the {\b Options} Menu, \line
\tab {\i\b Diagnostic Mode} allows you to run msispy in either of the two modes- normal and diagnostic.\line
\tab   In the Normal mode, a component's status is determined by the status of its key-file.\line
\tab   In the Diagnostic mode, each file of the component is checked and the component status\line
\tab   displayed is determined using this information. This gives a more accurate picture of the\line
\tab   system, but make the program much slower.\line\line
{\b Context Menus}\line\line
When a product, feature or component is selected, clicking on the right mouse-button brings up the 
 context menus that allow you to perform operations on the selected item.\line\line
All context menus have a {\i\b Properties} option, that brings up a property sheet containing information
 about the selected item. In addition to the {\b General} tab that contains the information, the property
 sheets also contain a {\b File List} tab, that contains information about all the files needed by the
 selected item. The list of files contains information about the file including the component that uses it,
 the file name and size when it was installed, the location of the file. In this tab, the {\b Verify Files}
 button allows you to check the current status of the files. This button brings up a window with the current
 file information, including current size, creation, last access and modification dates. If the file is not
 found, or if the file size is different, the file is marked broken with an icon to the its left.\line\line
{\b Important:} If a profile is in use, the verify files brings up information about the files {\i when the
 profile was saved, not the current file information}.\line\line
Additional context-menu choices cary depending on the item selected. When the selected item is a\line\line
{\b Component}: The menu comprises \line
\tab {\i\b Re-install Component} (enabled only if the component is broken), which allows you to re-install\line
\tab   the component from it's original install source.\line\line
{\b Installed Feature or Product}: The menu comprises \line
\tab {\i\b Re-install}, which allows you to use one of the available re-install modes, including\line
\tab   options to re-install just the damaged or missing files. Other options allow you to force all \line
\tab   the files to be re-installed, the registry entries to be verified, and so on.\line
\tab {\i\b Configure}, which allows you to install the feature on your local machine, or run it\line
\tab   from a remote source. Some features may have components that need to be installed on the local\line
\tab   machine. Attempting to install such features to run from a remote location will lead to a mix\line
\tab   of some components being on the local system and the rest at the remote location.\line
\tab {\i\b Un-install}, which allows you to un-install the product or feature. If a feature with\line
\tab   sub-features is un-installed, all of its sub-features will be un-installed as well.\line\line
{\b Uninstalled Product or Feature}: If an MSI package for a product not installed on the local system \line
\tab   is in use, the context menu has the following options:\line
\tab {\i\b Install Product}, which will install the product on the local system using the default options\line
\tab {\i\b Advertise Product}, which will advertise the product on to the local system. This will \line
\tab   set all the registry entries needed for the product, but will not actually install any files \line
\tab   on the local system. The files will be transferred in when the component they belong to is used.\line\line
{\b Product or Feature in a Profile}: The menu always comprises:\line
\tab {\i\b Restore Profile}, which has the same functionality as {\b Restore Saved Profile} described above.\line\line
{\b Command Line Syntax:} \line
{\b msispy }
\page


}
