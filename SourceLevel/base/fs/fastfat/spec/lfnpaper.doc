{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}{\f17\fnil\fcharset2\fprq2{\*\panose 01010601010101010101}Monotype Sorts;}{\f18\froman\fcharset238\fprq2 Times New Roman CE;}{\f19\froman\fcharset204\fprq2 Times New Roman Cyr;}{\f21\froman\fcharset161\fprq2 Times New Roman Greek;}{\f22\froman\fcharset162\fprq2 Times New Roman Tur;}{\f23\froman\fcharset186\fprq2 Times New Roman Baltic;}{\f24\fswiss\fcharset238\fprq2 Arial CE;}{\f25\fswiss\fcharset204\fprq2 Arial Cyr;}{\f27\fswiss\fcharset161\fprq2 Arial Greek;}{\f28\fswiss\fcharset162\fprq2 Arial Tur;}{\f29\fswiss\fcharset186\fprq2 Arial Baltic;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\qj\nowidctlpar\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}{\s1\qj\fi-720\li720\sb240\nowidctlpar\widctlpar\ls1\outlinelevel0\adjustright \b\f1\ul\cgrid \sbasedon0 \snext0 heading 1;}{\s2\qj\fi-720\li1440\sb120\nowidctlpar\widctlpar\ls1\ilvl1\outlinelevel1\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 2;}{\s3\qj\fi-720\li2160\nowidctlpar\widctlpar\ls1\ilvl2\outlinelevel2\adjustright \i\f1\cgrid \sbasedon0 \snext0 heading 3;}{\s4\qj\fi-720\li2880\sb240\sa60\keepn\nowidctlpar\widctlpar\ls1\ilvl3\outlinelevel3\adjustright \b\i\cgrid \sbasedon0 \snext0 heading 4;}{\s5\qj\fi-720\li3600\sb240\sa60\nowidctlpar\widctlpar\ls1\ilvl4\outlinelevel4\adjustright \f1\fs22\cgrid \sbasedon0 \snext0 heading 5;}{\s6\qj\fi-720\li4320\sb240\sa60\nowidctlpar\widctlpar\ls1\ilvl5\outlinelevel5\adjustright \i\f1\fs22\cgrid \sbasedon0 \snext0 heading 6;}{\s7\qj\fi-720\li5040\sb240\sa60\nowidctlpar\widctlpar\ls1\ilvl6\outlinelevel6\adjustright \f1\fs20\cgrid \sbasedon0 \snext0 heading 7;}{\s8\qj\fi-720\li5760\sb240\sa60\nowidctlpar\widctlpar\ls1\ilvl7\outlinelevel7\adjustright \i\f1\fs20\cgrid \sbasedon0 \snext0 heading 8;}{\s9\qj\fi-720\li6480\sb240\sa60\nowidctlpar\widctlpar\ls1\ilvl8\outlinelevel8\adjustright \i\f1\fs18\cgrid \sbasedon0 \snext0 heading 9;}{\*\cs10 \additive Default Paragraph Font;}{\s15\li200\nowidctlpar\widctlpar\tqr\tlul\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext0 toc 3;}{\s16\sb120\nowidctlpar\widctlpar\tqr\tlul\tx8640\adjustright \b\fs22\cgrid \sbasedon0 \snext0 toc 2;}{\s17\sb120\nowidctlpar\widctlpar\tqr\tlul\tx8640\adjustright \b\i\cgrid \sbasedon0 \snext0 toc 1;}{\s18\qj\nowidctlpar\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext18 footer;}{\s19\qj\nowidctlpar\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext19 header;}{\s20\qj\li720\nowidctlpar\widctlpar\adjustright \fs20\cgrid \sbasedon0 \snext20 Normal Indent;}{\s21\qc\nowidctlpar\widctlpar\adjustright \b\fs28\cgrid \sbasedon0 \snext1 Title;}{\s22\fi-360\li360\sa240\sl240\slmult0\nowidctlpar\widctlpar\adjustright \fs20\cgrid \sbasedon0 \snext22 L1;}{\s23\li400\nowidctlpar\widctlpar\tqr\tlul\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext0 toc 4;}{\s24\li600\nowidctlpar\widctlpar\tqr\tlul\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext0 toc 5;}{\s25\li800\nowidctlpar\widctlpar\tqr\tlul\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext0 toc 6;}{\s26\li1000\nowidctlpar\widctlpar\tqr\tlul\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext0 toc 7;}{\s27\li1200\nowidctlpar\widctlpar\tqr\tlul\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext0 toc 8;}{\s28\li1400\nowidctlpar\widctlpar\tqr\tlul\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext0 toc 9;}}{\*\listtable{\list\listtemplateid-1{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelold\levelspace0\levelindent720{\leveltext\'02\'00.;}{\levelnumbers\'01;}\s1\fi-720\li720 }{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelold\levelspace0\levelindent720{\leveltext\'04\'00.\'01.;}{\levelnumbers\'01\'03;}\s2\fi-720\li1440 }{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelold\levelspace0\levelindent720{\leveltext\'06\'00.\'01.\'02.;}{\levelnumbers\'01\'03\'05;}\s3\fi-720\li2160 }{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelold\levelspace0\levelindent720{\leveltext\'08\'00.\'01.\'02.\'03.;}{\levelnumbers\'01\'03\'05\'07;}\s4\fi-720\li2880 }{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelold\levelspace0\levelindent720{\leveltext\'0a\'00.\'01.\'02.\'03.\'04.;}{\levelnumbers\'01\'03\'05\'07\'09;}\s5\fi-720\li3600 }{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelold\levelspace0\levelindent720{\leveltext
\'0c\'00.\'01.\'02.\'03.\'04.\'05.;}{\levelnumbers\'01\'03\'05\'07\'09\'0b;}\s6\fi-720\li4320 }{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelold\levelspace0\levelindent720{\leveltext\'0e\'00.\'01.\'02.\'03.\'04.\'05.\'06.;}{\levelnumbers\'01\'03\'05\'07\'09\'0b\'0d;}\s7\fi-720\li5040 }{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelold\levelspace0\levelindent720{\leveltext\'10\'00.\'01.\'02.\'03.\'04.\'05.\'06.\'07.;}{\levelnumbers\'01\'03\'05\'07\'09\'0b\'0d\'0f;}\s8\fi-720\li5760 }{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat1\levelold\levelspace0\levelindent720{\leveltext
\'12\'00.\'01.\'02.\'03.\'04.\'05.\'06.\'07.\'08.;}{\levelnumbers\'01\'03\'05\'07\'09\'0b\'0d\'0f\'11;}\s9\fi-720\li6480 }{\listname ;}\listid-5}{\list\listtemplateid-1\listsimple{\listlevel\levelnfc0\leveljc0\levelfollow0\levelstartat0\levelspace0\levelindent0{\leveltext\'01*;}{\levelnumbers;}}{\listname ;}\listid-2}}{\*\listoverridetable{\listoverride\listid-5\listoverridecount0\ls1}{\listoverride\listid-2\listoverridecount1{\lfolevel\listoverrideformat{\listlevel\levelnfc23\leveljc0\levelfollow0\levelstartat1\levelold\levelspace0\levelindent360{\leveltext\'01\u-3913 ?;}{\levelnumbers;}\f3\fbias0 \fi-360\li1080 }}\ls2}}{\info{\title Chicago File System Features - Tips & Issues}{\author Russ Arun}{\operator Dan Lovinger}{\creatim\yr1997\mo4\dy4\hr15\min37}{\revtim\yr1997\mo4\dy4\hr15\min38}{\printim\yr1994\mo3\dy18\hr12\min36}{\version2}{\edmins1}{\nofpages13}{\nofwords6083}{\nofchars34677}{\*\company MSFT}{\nofcharsws42585}{\vern71}}\widowctrl\ftnbj\aenddoc\noextrasprl\prcolbl\cvmme\sprsspbf\brkfrm\swpbdr\lytprtmet\hyphcaps0\fracwidth\viewkind4\viewscale100\pgbrdrhead\pgbrdrfoot \fet0\sectd \pgnrestart\linex0\sectdefaultcl {\footer \pard\plain \s18\qj\nowidctlpar\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid {\b \tab }{\b\i Microsoft Corporation Company Confidential}{\b  \tab 
\par }}{\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \qj\nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard\plain \s21\qc\nowidctlpar\widctlpar\adjustright \b\fs28\cgrid {
\par Chicago File System Features - Tips & Issues
\par }\pard\plain \qj\nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {
\par 
\par 
\par 
\par 
\par 
\par 
\par 
\par }\pard\plain \s21\qc\nowidctlpar\widctlpar\adjustright \b\fs28\cgrid {\fs24 Attention:  Requires Chicago NDA
\par }\pard\plain \qj\nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {
\par 
\par 
\par 
\par 
\par 
\par 
\par Revision:\tab 0.98
\par Date:\tab \tab April 22, 1994
\par Author:\tab \tab Russ Arun
\par {\*\bkmkstart _Toc291078650}{\*\bkmkstart _Toc291687435}{\*\bkmkend _Toc291078650}{\*\bkmkend _Toc291687435}{\listtext\pard\plain\s1 \b\f1\ul\cgrid \hich\af1\dbch\af0\loch\f1 1.\tab}}\pard\plain \s1\qj\fi-720\li720\sb240\nowidctlpar\widctlpar\ls1\outlinelevel0\adjustright \b\f1\ul\cgrid {\sect }\sectd \pgnrestart\pgnlcrm\linex0\sectdefaultcl {\header \pard\plain \s19\qj\nowidctlpar\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid {File System - Tips & Issues\tab \tab Page }{\field{\*\fldinst {PAGE}}{\fldrslt {\lang1024 i}}}{
\par }}\pard\plain \s17\sb120\nowidctlpar\widctlpar\tx360\tqr\tlul\tx8640\adjustright \b\i\cgrid {\i0 Table of Contents
\par }\pard \s17\sb120\nowidctlpar\widctlpar\tqr\tlul\tx8640\adjustright {\field\fldedit{\*\fldinst {\caps  TOC \\o }}{\fldrslt {
\par }\pard \s17\sb120\nowidctlpar\widctlpar\tqr\tlul\tx8640\adjustright {1. Overview\tab }{\field\flddirty{\*\fldinst { GOTOBUTTON _Toc291687437  }{\field{\*\fldinst { PAGEREF _Toc291687437 }}{\fldrslt {1}}}}}{
\par 2. File System Details\tab }{\field\flddirty{\*\fldinst { GOTOBUTTON _Toc291687438  }{\field{\*\fldinst { PAGEREF _Toc291687438 }}{\fldrslt {1}}}}}{
\par 3. End User Issues\tab }{\field\flddirty{\*\fldinst { GOTOBUTTON _Toc291687439  }{\field{\*\fldinst { PAGEREF _Toc291687439 }}{\fldrslt {2}}}}}{
\par }\pard\plain \s16\sb120\nowidctlpar\widctlpar\tqr\tlul\tx8640\adjustright \b\fs22\cgrid {3.1. Auto-generation of 8.3 names\tab }{\field\flddirty{\*\fldinst { GOTOBUTTON _Toc291687440  }{\field{\*\fldinst { PAGEREF _Toc291687440 }}{\fldrslt {2}}}}}{
\par }\pard \s16\sb120\nowidctlpar\widctlpar\tqr\tlul\tx8640\adjustright {3.2. Searches\tab }{\field\flddirty{\*\fldinst { GOTOBUTTON _Toc291687441  }{\field{\*\fldinst { PAGEREF _Toc291687441 }}{\fldrslt {3}}}}}{
\par 3.3. Down Level Systems\tab }{\field\flddirty{\*\fldinst { GOTOBUTTON _Toc291687442  }{\field{\*\fldinst { PAGEREF _Toc291687442 }}{\fldrslt {3}}}}}{
\par 3.4. Disk Utilities & Exclusive Volume Lock\tab }{\field\flddirty{\*\fldinst { GOTOBUTTON _Toc291687443  }{\field{\*\fldinst { PAGEREF _Toc291687443 }}{\fldrslt {4}}}}}{
\par 3.5. Long File Name Format\tab }{\field\flddirty{\*\fldinst { GOTOBUTTON _Toc291687444  }{\field{\*\fldinst { PAGEREF _Toc291687444 }}{\fldrslt {5}}}}}{
\par 3.6. Long File Names in the Root\tab }{\field\flddirty{\*\fldinst { GOTOBUTTON _Toc291687445  }{\field{\*\fldinst { PAGEREF _Toc291687445 }}{\fldrslt {5}}}}}{
\par }\pard\plain \s17\sb120\nowidctlpar\widctlpar\tqr\tlul\tx8640\adjustright \b\i\cgrid {4. ISV Issues\tab }{\field\flddirty{\*\fldinst { GOTOBUTTON _Toc291687446  }{\field{\*\fldinst { PAGEREF _Toc291687446 }}{\fldrslt {5}}}}}{
\par }\pard\plain \s16\sb120\nowidctlpar\widctlpar\tqr\tlul\tx8640\adjustright \b\fs22\cgrid {4.1. Limits in the Name\tab }{\field\flddirty{\*\fldinst { GOTOBUTTON _Toc291687447  }{\field{\*\fldinst { PAGEREF _Toc291687447 }}{\fldrslt {5}}}}}{
\par }\pard \s16\sb120\nowidctlpar\widctlpar\tqr\tlul\tx8640\adjustright {4.2. Auto-generation scheme\tab }{\field\flddirty{\*\fldinst { GOTOBUTTON _Toc291687448  }{\field{\*\fldinst { PAGEREF _Toc291687448 }}{\fldrslt {5}}}}}{
\par 4.3. 32-bit Apps on Windows\tab }{\field\flddirty{\*\fldinst { GOTOBUTTON _Toc291687449  }{\field{\*\fldinst { PAGEREF _Toc291687449 }}{\fldrslt {6}}}}}{
\par 4.4. 16-bit Apps on Chicago\tab }{\field\flddirty{\*\fldinst { GOTOBUTTON _Toc291687450  }{\field{\*\fldinst { PAGEREF _Toc291687450 }}{\fldrslt {6}}}}}{
\par 4.5. 16-bit Apps & Down Level Systems\tab }{\field\flddirty{\*\fldinst { GOTOBUTTON _Toc291687451  }{\field{\*\fldinst { PAGEREF _Toc291687451 }}{\fldrslt {6}}}}}{
\par 4.6. Character sets: APIs & on-disk names\tab }{\field\flddirty{\*\fldinst { GOTOBUTTON _Toc291687452  }{\field{\*\fldinst { PAGEREF _Toc291687452 }}{\fldrslt {7}}}}}{
\par }\pard\plain \s15\li200\nowidctlpar\widctlpar\tqr\tlul\tx8640\adjustright \fs20\cgrid {4.6.1. 16 bit file APIs\tab }{\field\flddirty{\*\fldinst { GOTOBUTTON _Toc291687453  }{\field{\*\fldinst { PAGEREF _Toc291687453 }}{\fldrslt {7}}}}}{
\par }\pard \s15\li200\nowidctlpar\widctlpar\tqr\tlul\tx8640\adjustright {4.6.2. 32 bit file APIs\tab }{\field\flddirty{\*\fldinst { GOTOBUTTON _Toc291687454  }{\field{\*\fldinst { PAGEREF _Toc291687454 }}{\fldrslt {7}}}}}{
\par 4.6.3. On-Disk names\tab }{\field\flddirty{\*\fldinst { GOTOBUTTON _Toc291687455  }{\field{\*\fldinst { PAGEREF _Toc291687455 }}{\fldrslt {7}}}}}{
\par }\pard\plain \s16\sb120\nowidctlpar\widctlpar\tqr\tlul\tx8640\adjustright \b\fs22\cgrid {4.7. CreateProcess, WinExec & $exec functions and LFNs\tab }{\field\flddirty{\*\fldinst { GOTOBUTTON _Toc291687456  }{\field{\*\fldinst { PAGEREF _Toc291687456 }}{\fldrslt {7}}}}}{
\par }\pard \s16\sb120\nowidctlpar\widctlpar\tqr\tlul\tx8640\adjustright {4.8. Canonical API\tab }{\field\flddirty{\*\fldinst { GOTOBUTTON _Toc291687457  }{\field{\*\fldinst { PAGEREF _Toc291687457 }}{\fldrslt {8}}}}}{
\par 4.9. Exclusive Volume API (specific to Chicago)\tab }{\field\flddirty{\*\fldinst { GOTOBUTTON _Toc291687458  }{\field{\*\fldinst { PAGEREF _Toc291687458 }}{\fldrslt {8}}}}}{
\par 4.10. Keying off file names\tab }{\field\flddirty{\*\fldinst { GOTOBUTTON _Toc291687459  }{\field{\*\fldinst { PAGEREF _Toc291687459 }}{\fldrslt {8}}}}}{
\par 4.11. Checking Directory Entries\tab }{\field\flddirty{\*\fldinst { GOTOBUTTON _Toc291687460  }{\field{\*\fldinst { PAGEREF _Toc291687460 }}{\fldrslt {8}}}}}{
\par 4.12. Win32 & New INT 21 FindFirst/Next and FindClose\tab }{\field\flddirty{\*\fldinst { GOTOBUTTON _Toc291687461  }{\field{\*\fldinst { PAGEREF _Toc291687461 }}{\fldrslt {9}}}}}{
\par 4.13. Time APIs\tab }{\field\flddirty{\*\fldinst { GOTOBUTTON _Toc291687462  }{\field{\*\fldinst { PAGEREF _Toc291687462 }}{\fldrslt {9}}}}}{
\par 4.14. TSR and Apps that monitor INT 21 calls (INT 21 hookers)\tab }{\field\flddirty{\*\fldinst { GOTOBUTTON _Toc291687463  }{\field{\*\fldinst { PAGEREF _Toc291687463 }}{\fldrslt {10}}}}}{
\par 4.15. File System "Compatibility" switch\tab }{\field\flddirty{\*\fldinst { GOTOBUTTON _Toc291687464  }{\field{\*\fldinst { PAGEREF _Toc291687464 }}{\fldrslt {10}}}}}{
\par 4.16. "for" command in COMMAND.COM\tab }{\field\flddirty{\*\fldinst { GOTOBUTTON _Toc291687465  }{\field{\*\fldinst { PAGEREF _Toc291687465 }}{\fldrslt {11}}}}}{
\par 4.17. Down level system idiosyncrasies\tab }{\field\flddirty{\*\fldinst { GOTOBUTTON _Toc291687466  }{\field{\*\fldinst { PAGEREF _Toc291687466 }}{\fldrslt {11}}}}}{
\par 4.18. Long command lines\tab }{\field{\*\fldinst { GOTOBUTTON _Toc291687467  }{\field{\*\fldinst { PAGEREF _Toc291687467 }}{\fldrslt {11}}}}}{
\par }\pard\plain \qj\nowidctlpar\widctlpar\adjustright \fs20\cgrid }}\pard\plain \qj\nowidctlpar\widctlpar\adjustright \fs20\cgrid {\b\fs24 
\par {\*\bkmkstart _Toc291078651}{\*\bkmkstart _Toc291687436}{\*\bkmkend _Toc291078651}{\*\bkmkend _Toc291687436}{\listtext\pard\plain\s1 \b\f1\ul\cgrid \hich\af1\dbch\af0\loch\f1 1.\tab}}\pard\plain \s1\qj\fi-720\li720\sb240\nowidctlpar\widctlpar\ls1\outlinelevel0\adjustright \b\f1\ul\cgrid {\sect }\sectd \pgnrestart\linex0\sectdefaultcl {\header \pard\plain \s19\qj\nowidctlpar\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid {File System - Tips & Issues\tab \tab Page }{\field{\*\fldinst {PAGE}}{\fldrslt {\lang1024 11}}}{
\par }}{\footer \pard\plain \s18\qj\nowidctlpar\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid {\b \tab }{\b\i Microsoft Corporation Company Confidential}{\b \tab 
\par }\pard \s18\qj\nowidctlpar\widctlpar\tqc\tx4320\tqr\tx8640\adjustright {
\par }}{\*\bkmkstart _Toc287753064}{\*\bkmkstart _Toc287900660}{\*\bkmkstart _Toc288048223}{\*\bkmkstart _Toc288498088}{\*\bkmkstart _Toc291078299}{\*\bkmkstart _Toc291078652}{\*\bkmkstart _Toc291687437}{\listtext\pard\plain\s1 \b\f1\ul\cgrid \hich\af1\dbch\af0\loch\f1 1.\tab}\pard\plain \s1\qj\fi-360\li360\sb240\nowidctlpar\widctlpar\ls1\outlinelevel0\adjustright \b\f1\ul\cgrid {Overview{\*\bkmkend _Toc287753064}{\*\bkmkend _Toc287900660}{\*\bkmkend _Toc288048223}{\*\bkmkend _Toc288498088}{\*\bkmkend _Toc291078299}{\*\bkmkend _Toc291078652}{\*\bkmkend _Toc291687437}
\par }\pard\plain \qj\nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {The FAT file system was the original file system that was part of MS-DOS.  This file system has hardly been modified since MS-DOS 2.0, but for the introduction of 16 bit FAT in MS-DOS 3.0.  Hence the enhancement of the FAT file system to support long file names will be the first major extension of this file system in quite a while.  Long file names are being introduced in the FAT file system in a backward compatible manner in the next version of Windows.
\par 
\par Any physical file on this extended FAT file system will logically be associated with two names: namely the }{\i (primary)}{ }{\i file name}{ and its }{\i (alternate name or)}{ }{\i alias}{.  The alias will be in the standard MS-DOS 8.3 name format.  The alias will be generated automatically, if necessary.  Valid characters, as defined by MS-DOS for the 8.3 names, have been any combination of letters, digits or characters with ASCII codes greater than 127, blank (ASCII 20H), plus any of the following special characters:
\par \tab $ % ' - _ @   ~ ` ! ( ) \{ \} ^ # &
\par This is the same set of characters that is valid for the alias too.  The (long) file name can be up to 255 characters long.  Also the following additional characters, which are invalid in the alias (8.3 name), are valid in the (long) file name:
\par \tab + , ; = [ ]
\par 
\par {\*\bkmkstart _Toc287753065}{\*\bkmkstart _Toc287900661}{\*\bkmkstart _Toc288048224}{\*\bkmkstart _Toc288498089}{\*\bkmkstart _Toc291078300}{\*\bkmkstart _Toc291078653}{\*\bkmkstart _Toc291687438}{\listtext\pard\plain\s1 \b\f1\ul\cgrid \hich\af1\dbch\af0\loch\f1 2.\tab}}\pard\plain \s1\qj\fi-360\li360\sb240\nowidctlpar\widctlpar\ls1\outlinelevel0\adjustright \b\f1\ul\cgrid {File System Details{\*\bkmkend _Toc287753065}{\*\bkmkend _Toc287900661}{\*\bkmkend _Toc288048224}{\*\bkmkend _Toc288498089}{\*\bkmkend _Toc291078300}{\*\bkmkend _Toc291078653}{\*\bkmkend _Toc291687438}
\par }\pard\plain \qj\nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {In Chicago, the Long File name FAT, will be supported only when running Windows.  The regular MS-DOS real mode FAT file system (and not the Long File name FAT file system) will be the one that is supported in Single MS-DOS application mode (real mode).  This means that long names that are created in a Windows environment will }{\i not}{ be visible when the user exits to Single MS-DOS application mode, though the names themselves are physically present on the media.  Only the alias (8.3 name) will be visible.  The same applies to any down level FAT file system, when a floppy media with long file names is transported to them.  On systems like MS-DOS 6.0, Win 3.1, Windows NT 3.1 and OS/2 2.11 only the alias (8.3 name) will be visible on the floppy, even if it contains long file names created on Chicago.
\par 
\par Chicago will be able to see the long file names on Windows NT\rquote s NTFS, OS/2\rquote s HPFS or Novell Netware\rquote s file system, if there are long file names on the server.
\par 
\par As mentioned before, when a file is created, it logically has both a file name and an alias.  If the file name is 8.3 compliant then the file name and the alias are the same.  For the file name to be 8.3 compliant it has to use only the characters that are valid for an alias }{\i and}{ it has to be all }{\i upper case}{.  This implies that a name that uses only characters that are valid for an alias and is 8.3 compliant as far as its format goes, is still not the same as the alias, if it contains lower case characters.  However in this case, the alias will just be the upper case version of the file name.  For example, if the file name of a file is }{\b Examples.Txt}{, then its corresponding alias will be }{\b EXAMPLES.TXT}{.  The case of the name is preserved in the file name.  Note that searches in the file system are case insensitive, so a search of the form }{\b examples.txt}{ will find this file.
\par 
\par If the file name is not compliant with an 8.3 name either in format or in the characters it uses, then an alias will be auto-generated.   The user or an application cannot control the name created by the auto-generation process.  For example, a (long) file name of the form }{\b ThisIsALongFileName}{ will be associated with an auto-generated alias of the form }{\b THISISAL}{.  In the case of alias (8.3) name collisions, this alias could easily be of the form }{\b THISIS~1}{ or }{\b THISI~19}{. 
\par 
\par The requests to extend the FAT file system to support long file names have poured in over time.  It is a difficult balancing act extending a widely used file system, such as the FAT file system, in a backward compatible manner.  Further the long file name scheme that is being introduced is compatible with the Win32 file naming scheme.  The accrued benefits due to the existence of long file names should be obvious.  Its popularity and acceptance will be determined by how fast and how well applications support this feature, and how many of such applications find their way on to the user's machine.  A user who chooses to use the older 8.3 names, will not see much of a difference in the system, due to the long file names.    To be sure there are some issues and subtleties introduced by this feature and they are discussed below.  
\par 
\par The rest of this paper dwells on issues that end users will see while using the long file name extensions in the FAT file system, and on tips for ISVs who develop applications and utilities.
\par 
\par {\*\bkmkstart _Toc287753066}{\*\bkmkstart _Toc287900662}{\*\bkmkstart _Toc288048225}{\*\bkmkstart _Toc288498090}{\*\bkmkstart _Toc291078301}{\*\bkmkstart _Toc291078654}{\*\bkmkstart _Toc291687439}{\listtext\pard\plain\s1 \b\f1\ul\cgrid \hich\af1\dbch\af0\loch\f1 3.\tab}}\pard\plain \s1\qj\fi-360\li360\sb240\nowidctlpar\widctlpar\ls1\outlinelevel0\adjustright \b\f1\ul\cgrid {End User Issues{\*\bkmkend _Toc287753066}{\*\bkmkend _Toc287900662}{\*\bkmkend _Toc288048225}{\*\bkmkend _Toc288498090}{\*\bkmkend _Toc291078301}{\*\bkmkend _Toc291078654}{\*\bkmkend _Toc291687439}
\par }\pard\plain \qj\nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par {\*\bkmkstart _Toc287753067}{\*\bkmkstart _Toc287900663}{\*\bkmkstart _Toc288048226}{\*\bkmkstart _Toc288498091}{\*\bkmkstart _Toc291078302}{\*\bkmkstart _Toc291078655}{\*\bkmkstart _Toc291687440}{\listtext\pard\plain\s2 \b\f1\cgrid \hich\af1\dbch\af0\loch\f1 3.1.\tab}}\pard\plain \s2\qj\fi-360\li360\sb120\nowidctlpar\widctlpar\ls1\ilvl1\outlinelevel1\adjustright \b\f1\cgrid {Auto-generation of 8.3 names{\*\bkmkend _Toc287753067}{\*\bkmkend _Toc287900663}{\*\bkmkend _Toc288048226}{\*\bkmkend _Toc288498091}{\*\bkmkend _Toc291078302}{\*\bkmkend _Toc291078655}{\*\bkmkend _Toc291687440}
\par }\pard\plain \qj\nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {The auto-generation of the alias has some side effects. Since the system auto-generates the alias name on }{\i every create}{, the following idiosyncrasies will be observed by users.
\par 
\par }\pard \qj\fi-360\li360\nowidctlpar\widctlpar\adjustright {\field\flddirty{\*\fldinst {SYMBOL 183 \\f "Symbol" \\s 10 \\h}}{\fldrslt }}{\tab }{\i Operations on a long file name, can potentially change the alias name}{.  In particular operations such as copy, edit, backup & restore might change the 8.3 name associated with the file.  For example, if a file with the name }{\b LongFileName}{ is associated with an alias }{\b LONGFI~2}{, and this file is copied to a different directory using:
\par }\pard \qj\fi-360\li360\nowidctlpar\widctlpar\adjustright {\tab \tab }{\b copy LongFileName  \\TMP\\LongFileName}{
\par \tab then the alias associated with this file can become }{\b LONGFILE}{, if such an alias (8.3 name) is not present in the target directory.  The (long) file name is of course preserved in this case.
\par }\pard \qj\fi-360\li360\nowidctlpar\widctlpar\adjustright {
\par }{\field\flddirty{\*\fldinst {SYMBOL 183 \\f "Symbol" \\s 10 \\h}}{\fldrslt }}{\tab }{\i Operations on the alias (the 8.3 name) will destroy the long file name}{.  In particular operations such as copy, with older versions of utilities that have not been updated to support long file names, can destroy the long file name associated with the file that is operated upon.  For example, if a file with a file name }{\b LongFileName.Txt}{ is associated with an alias }{\b LONGFI~1.TXT}{, and this file is copied to a different directory using an older version of copy that is not aware of long file names then: 
\par \tab \tab }{\b oldcopy LONGFI~1.TXT \\TMP\\LONGFI~1.TXT
\par }\pard \qj\fi-360\li360\nowidctlpar\widctlpar\adjustright {\tab will cause the destination file in the target directory to be associated only with the file name and alias of }{\b LONGFI~1.TXT}{.  In other words the destination file will }{\i not}{ have the file name }{\b LongFileName.Txt}{.   Of course Chicago's COMMAND.COM has been updated to support long file names as part of all of its commands, including COPY.
\par }\pard \qj\fi-360\li360\nowidctlpar\widctlpar\adjustright {
\par \tab A similar problem can occur on older versions of backup and restore.  If one backs up the entire system, using an old version of a backup utility that does not support long file names, and then restores the entire system at some point later, then all the long file names in the system will be lost.  Note that the alias (which will also be the newer file name) and the data of the file will be preserved.
\par 
\par \tab A utility called LFNBK has been posted on Compuserve.  The user can preserve the (long) file names in this case by doing the following:
\par {\pntext\pard\plain\f3\fs20\cgrid \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \qj\fi-360\li1080\nowidctlpar\widctlpar{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls2\adjustright {Preserve the (long) file name to (8.3) alias name association}{\b ,}{ by running}{\b  LFNBK /b <drive letter>}{, where <drive letter> is the drive the user plans to backup
\par {\pntext\pard\plain\f3\fs20\cgrid \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \qj\fi-360\li1080\nowidctlpar\widctlpar{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls2\adjustright {Backup this drive (specified as the drive letter in the previous line) using an old backup program that will not be aware of long file names.
\par {\pntext\pard\plain\f3\fs20\cgrid \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \qj\fi-360\li1080\nowidctlpar\widctlpar{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls2\adjustright {Restore the backed up files to a drive, when necessary at some point later, using the old restore program that will not be aware of long file names
\par {\pntext\pard\plain\f3\fs20\cgrid \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \qj\fi-360\li1080\nowidctlpar\widctlpar{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls2\adjustright {Restore the long file names on this drive, by running }{\b LFNBK /r <drive letter>}{, where drive letter is the drive where the files were restored to.
\par }\pard \qj\fi-360\li360\nowidctlpar\widctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\tab Note that the (8.3) alias name might be different from what was backed up in some cases, but the (long) file name will match what was backed up.
\par }\pard \qj\fi-360\li360\nowidctlpar\widctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {
\par \tab Chicago will provide a feature, called }{\i tunneling}{, to preserve the (long) file names when using older editors.  These older editors will only operate on the (alias) 8.3 name because they are not aware of (long) file names.  Tunneling will be turned on by default in Chicago, but the user can choose to turn it off.  Tunneling aims to preserve the (long) file name on editors that use the following scheme:
\par {\pntext\pard\plain\f3\fs20\cgrid \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \qj\fi-360\li1080\nowidctlpar\widctlpar{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls2\adjustright {Normal file open and editing \ldblquote creates\rdblquote  a temporary file
\par {\pntext\pard\plain\f3\fs20\cgrid \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \qj\fi-360\li1080\nowidctlpar\widctlpar{\*\pn \pnlvlblt\ilvl0\ls2\pnrnot0\pnf3\pnstart1\pnindent360\pnhang{\pntxtb \'b7}}\ls2\adjustright {A \ldblquote save and/or close\rdblquote  operation, saves the temporary file, deletes or renames the original file, renames the temporary file just edited to be the original file
\par }\pard \qj\fi-360\li360\nowidctlpar\widctlpar\adjustright {\tab Most editors use the above scheme.
\par }\pard \qj\fi-360\li360\nowidctlpar\widctlpar\adjustright {
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {A user who chooses to use only 8.3 compliant names (ignoring case) or sets the file system in Win 3.1 compatible mode will not see these idiosyncrasies.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {
\par }\pard \qj\fi-720\li720\nowidctlpar\widctlpar\adjustright {\f17\fs24 \'2a}{\tab LFNBK productizing decisions have not been made yet.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {
\par {\*\bkmkstart _Toc287753068}{\*\bkmkstart _Toc287900664}{\*\bkmkstart _Toc288048227}{\*\bkmkstart _Toc288498092}{\*\bkmkstart _Toc291078303}{\*\bkmkstart _Toc291078656}{\*\bkmkstart _Toc291687441}{\listtext\pard\plain\s2 \b\f1\cgrid \hich\af1\dbch\af0\loch\f1 3.2.\tab}}\pard\plain \s2\qj\fi-360\li360\sb120\nowidctlpar\widctlpar\ls1\ilvl1\outlinelevel1\adjustright \b\f1\cgrid {Searches{\*\bkmkend _Toc287753068}{\*\bkmkend _Toc287900664}{\*\bkmkend _Toc288048227}{\*\bkmkend _Toc288498092}{\*\bkmkend _Toc291078303}{\*\bkmkend _Toc291078656}{\*\bkmkend _Toc291687441}
\par }\pard\plain \qj\nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {Searches of file names apply to both the file name and its alias.  The system presents a }{\i single unified name space}{.  This is done so that the single physical view of the file is preserved.  However if the result of the search shows only the file name, it could be confusing to the user.  Consider a set of files in a directory, where the file names and aliases are as follows:
\par }{\b \tab LongFileName\tab \tab \tab LONGFI~1
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\b \tab MyFile\tab \tab \tab \tab MYFILE
\par \tab Problems.Txt\tab \tab \tab PROBLEMS.TXT
\par \tab AnotherFile\tab \tab \tab ANOTHERF
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\b \tab File-1\tab \tab \tab \tab FILE-1
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {A search of the form }{\b DIR *1}{ will display:
\par }{\b \tab LONGFI~1\tab \tab 123\tab 08-11-93\tab 15:26\tab LongFileName
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\b \tab FILE-1\tab \tab \tab 352\tab 08-11-93\tab 16:01\tab File-1
\par 
\par }{Note that DIR displays the alias first for compatibility with the older }{\b DIR}{ format.  However another utility, that is aware of long file names and displays only the file name, will display both the files }{\b LongFileName}{ and }{\b File-1}{.  This could be confusing at first glance because the file }{\b LongFileName}{ does not have the number }{\b 1}{ as part of the name (which was specified in the search criteria).  The file was matched by the search pattern because its alias contains the number }{\b 1}{.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {
\par The wildcard searches have been made more flexible in Chicago (if the file system is not in Win 3.1 compatible mode - see below for a definition of this file system mode).  Note that in the above search }{\b *1}{ was a valid specification.  It is acceptable to search for all files contain the words }{\b mid}{ somewhere in the file name with a specification such as }{\b *mid*}{.  In the old search semantics, the first }{\b * }{encountered ignored all other character specifications.
\par }\pard \qj\fi-360\li360\nowidctlpar\widctlpar\adjustright {
\par {\*\bkmkstart _Toc287753069}{\*\bkmkstart _Toc287900665}{\*\bkmkstart _Toc288048228}{\*\bkmkstart _Toc288498093}{\*\bkmkstart _Toc291078304}{\*\bkmkstart _Toc291078657}{\*\bkmkstart _Toc291687442}{\listtext\pard\plain\s2 \b\f1\cgrid \hich\af1\dbch\af0\loch\f1 3.3.\tab}}\pard\plain \s2\qj\fi-360\li360\sb120\nowidctlpar\widctlpar\ls1\ilvl1\outlinelevel1\adjustright \b\f1\cgrid {Down Level Systems{\*\bkmkend _Toc287753069}{\*\bkmkend _Toc287900665}{\*\bkmkend _Toc288048228}{\*\bkmkend _Toc288498093}{\*\bkmkend _Toc291078304}{\*\bkmkend _Toc291078657}{\*\bkmkend _Toc291687442}
\par }\pard\plain \qj\nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {Down Level Systems are systems that support the old MS-DOS FAT file system.  Examples of such systems include MS-DOS 6.0, Windows 3.1, OS/2 2.11, Windows NT 1.0, etc.  These systems are not aware of the long file name extensions to the FAT file system.  If you were to take a floppy containing files that sport a long file name to the down level system, only the alias (8.3 name) will be visible on the down level system.  You can view the file using the alias name on the down level system.  If you take  the floppy back to the newer Windows release or to the newer Windows NT release, the long file name will be visible.
\par 
\par If you copy the file from the floppy to the hard disk on the down level system, the long file name associated with the file is not copied over.  This is not problematic because the down level system cannot see the long file name anyway.  However if you edit the file on the floppy using the alias, and then save a new copy back on the floppy on the down level system, the long file name associated with the file will be lost (if the editor uses the save, delete, rename cycle mentioned before).  If you take this floppy back to the newer Windows system, only the alias name will be associated with the file.   This is due to the fact that the down level system is not aware of the long file name and hence will not preserve it.
\par 
\par {\*\bkmkstart _Toc287753070}{\*\bkmkstart _Toc287900666}{\*\bkmkstart _Toc288048229}{\*\bkmkstart _Toc288498094}{\*\bkmkstart _Toc291078305}{\*\bkmkstart _Toc291078658}{\*\bkmkstart _Toc291687443}{\listtext\pard\plain\s2 \b\f1\cgrid \hich\af1\dbch\af0\loch\f1 3.4.\tab}}\pard\plain \s2\qj\fi-360\li360\sb120\nowidctlpar\widctlpar\ls1\ilvl1\outlinelevel1\adjustright \b\f1\cgrid {Disk Utilities & Exclusive Volume Lock{\*\bkmkend _Toc287753070}{\*\bkmkend _Toc287900666}{\*\bkmkend _Toc288048229}{\*\bkmkend _Toc288498094}{\*\bkmkend _Toc291078305}{\*\bkmkend _Toc291078658}{\*\bkmkend _Toc291687443}
\par }\pard\plain \qj\nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {Previously reserved fields in the file system directory entry are used for storing Last Access Date and Creation Date/Time.  A file with a long file name, which is longer than 5 characters,  will also cause the system to use previously reserved fields in the directory entry.   In previous versions of MS-DOS and Windows, these reserved entries were zero. Some Disk Utilities, especially disk repair and checking utilities, might display errors about the disk because of the usage of these reserved entries, though there are no real errors on the disk.  In the pathological case, a disk repair utility could destroy all these entries since it mistakenly thinks they are corrupted entries.  The end result of destroying these entries is different between the long file name case and last access date  & creation date/time case.  In the long file name case, the long file name is lost, but the alias (8.3 name) and the data in the file are still present.  It will just be difficult to find the file, without the associated long file name.  In the last access date & creation date/time case, the alias and the data will also be lost, because crucial information about the file (apart from the name) is also lost!  
\par 
\par For this reason, Windows is setup to fail such utilities on default.  This feature is called }{\b\i Exclusive Volume Lock}{.  A newer version of the utility that will understand the newer on-disk file system structures, will take an exclusive volume lock and do the right thing.  Older versions of the utilities, that do not understand the newer disk structures, will not take the exclusive volume lock and will be failed when the utility tries to do direct disk writes.  The user will have to run some sort of wrapper utility that will take the Exclusive Volume lock on behalf of the app and execute the app.  COMMAND.COM will provide a switch, of the form }{\b lock <volume>:}{, that takes the Exclusive Volume lock on behalf of the app, if the file system is in Win 3.1 compatible mode (see below).  This COMMAND.COM switch will }{\i not}{ be functional when the file system is in the default Chicago mode (that is the file system is }{\i not}{ in Win 3.1 compatible mode).  If a user does use a third party wrapper for this purpose when the file system is in Chicago mode it can be risky, because an older version of a utility might }{\i potentially}{ destroy long file names and in the worst case destroy data, while trying to repair what it thinks is a corrupted disk.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {
\par The user can set the file system in }{\b\i Windows 3.1 compatible mode}{, through the system folder in the Control Panel.  This is a setting in which none of the new file system features, such as long file names, last access date and creation date/time will be available.  The user will have to pass through a set of dialog boxes warning the user about the dire consequences of setting the file system in Win 3.1 compatible mode, if it was not previously set.  Once the file system is in Win 3.1 compatible mode, any existing long file names, last access date and creation date/time in the system will be deleted.  This forces the on-disk structures in the file system to match the ones on older versions of DOS and Windows.  When in this mode, older versions of the utilities can be safely run because there is no new information on the file system that the utility will interpret incorrectly.  However the system will still enforce the Exclusive Volume Lock to preserve internal system data consistency.  The user can safely use a COMMAND.COM switch or a third party wrapper, that would take the exclusive volume lock on behalf of the utility,  to run a utility in this case.   
\par 
\par Even in Single MS-DOS application mode, the direct disk writes (specifically INT 26H) will be failed if the file system is in Chicago mode.  These direct disk writes will not be failed in Single MS-DOS app mode, if the file system is in Win 3.1 compatible mode.  The COMMAND.COM switch described above can be used in Single MS-DOS application mode too.
\par 
\par }\pard \qj\fi-720\li720\nowidctlpar\widctlpar\adjustright {\f17\fs24 {\*\bkmkstart _Toc287753071}{\*\bkmkstart _Toc287900667}{\*\bkmkstart _Toc288048230}\'2a}{\tab The decision about the form of the wrapper has not been finalized yet.  It might become a switch elsewhere in the system.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {
\par {\*\bkmkstart _Toc288498095}{\*\bkmkstart _Toc291078306}{\*\bkmkstart _Toc291078659}{\*\bkmkstart _Toc291687444}{\listtext\pard\plain\s2 \b\f1\cgrid \hich\af1\dbch\af0\loch\f1 3.5.\tab}}\pard\plain \s2\qj\fi-360\li360\sb120\nowidctlpar\widctlpar\tx1440\ls1\ilvl1\outlinelevel1\adjustright \b\f1\cgrid {Long File Name Format{\*\bkmkend _Toc287753071}{\*\bkmkend _Toc287900667}{\*\bkmkend _Toc288048230}{\*\bkmkend _Toc288498095}{\*\bkmkend _Toc291078306}{\*\bkmkend _Toc291078659}{\*\bkmkend _Toc291687444}
\par }\pard\plain \qj\nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {As mentioned before, long file names preserve the case of the name.  Hence a user who creates a directory by typing }{\b mkdir examples}{ is actually creating a directory name of }{\b examples}{ and an alias of }{\b EXAMPLES}{.  However searches are case insensitive.
\par 
\par Period (the character }{\b .}{) is just another character in a (long) file name. Leading periods are allowed in a (long) file name, but trailing periods are stripped.  A file can have multiple periods as part of its name.  For example, }{\b MyFile.081293.Document}{ is a valid file name, though its alias will probably be }{\b MYFILE08.DOC}{.  The first three characters after the last period in the file name are used as the extension for the alias, as long as the last period is not a leading period.  A file name of }{\b .login}{ is also valid, though its alias will probably be }{\b LOGIN}{.
\par 
\par {\*\bkmkstart _Toc287753072}{\*\bkmkstart _Toc287900668}{\*\bkmkstart _Toc288048231}{\*\bkmkstart _Toc288498096}{\*\bkmkstart _Toc291078307}{\*\bkmkstart _Toc291078660}{\*\bkmkstart _Toc291687445}{\listtext\pard\plain\s2 \b\f1\cgrid \hich\af1\dbch\af0\loch\f1 3.6.\tab}}\pard\plain \s2\qj\fi-360\li360\sb120\nowidctlpar\widctlpar\ls1\ilvl1\outlinelevel1\adjustright \b\f1\cgrid {Long File Names in the Root{\*\bkmkend _Toc287753072}{\*\bkmkend _Toc287900668}{\*\bkmkend _Toc288048231}{\*\bkmkend _Toc288498096}{\*\bkmkend _Toc291078307}{\*\bkmkend _Toc291078660}{\*\bkmkend _Toc291687445}
\par }\pard\plain \qj\nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {Any file is best stored in a directory below the root in general.  This is especially true for files with long file names.  Files with long file names use up more directory entries than files with just an 8.3 name.  Since the number of entries in the root is limited, the root directory will be "filled up" with fewer files that have long file names.  In the above example, a long directory name of }{\b examples}{ and an alias of }{\b EXAMPLES}{ will be created.  In essence two entries will be used up and this causes the root directory to fill up faster.
\par {\*\bkmkstart _Toc287753073}{\*\bkmkstart _Toc287900669}{\*\bkmkstart _Toc288048232}{\*\bkmkstart _Toc288498097}{\*\bkmkstart _Toc291078308}{\*\bkmkstart _Toc291078661}{\*\bkmkstart _Toc291687446}{\listtext\pard\plain\s1 \b\f1\ul\cgrid \hich\af1\dbch\af0\loch\f1 4.\tab}}\pard\plain \s1\qj\fi-360\li360\sb240\nowidctlpar\widctlpar\ls1\outlinelevel0\adjustright \b\f1\ul\cgrid {ISV Issues{\*\bkmkend _Toc287753073}{\*\bkmkend _Toc287900669}{\*\bkmkend _Toc288048232}{\*\bkmkend _Toc288498097}{\*\bkmkend _Toc291078308}{\*\bkmkend _Toc291078661}{\*\bkmkend _Toc291687446}
\par }\pard\plain \qj\nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par {\*\bkmkstart _Toc287753074}{\*\bkmkstart _Toc287900670}{\*\bkmkstart _Toc288048233}{\*\bkmkstart _Toc288498098}{\*\bkmkstart _Toc291078309}{\*\bkmkstart _Toc291078662}{\*\bkmkstart _Toc291687447}{\listtext\pard\plain\s2 \b\f1\cgrid \hich\af1\dbch\af0\loch\f1 4.1.\tab}}\pard\plain \s2\qj\fi-360\li360\sb120\nowidctlpar\widctlpar\ls1\ilvl1\outlinelevel1\adjustright \b\f1\cgrid {Limits in the Name{\*\bkmkend _Toc287753074}{\*\bkmkend _Toc287900670}{\*\bkmkend _Toc288048233}{\*\bkmkend _Toc288498098}{\*\bkmkend _Toc291078309}{\*\bkmkend _Toc291078662}{\*\bkmkend _Toc291687447}
\par }\pard\plain \qj\nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {The maximum size of the file name component on Long File name FAT file systems is 255 characters (or 256 characters including the NULL).  The maximum path length is 260 characters (including the NULL).  These limits are the same as the ones in Win32.  The API }{\i GetVolumeInformation}{ returns this information.  This API is supported both as a Win32 (32 bit) and an INT 21 (16 bit) API.  This API returns other useful information, such as the name of the file system.  Using the GetVolumeInformation API to determine these limits and allocate buffers, is the preferred way to deal with these limits for a logical volume.  If static buffers need to be allocated then the maximum buffer sizes defined by the Win32 API should be used.  The Win32 API defines 256 characters (including the NULL) as the maximum file name component length and 260 characters (including the NULL) as the maximum path length.  The maximum path length is 260 characters (including the NULL) even if the path is an UNC path name.
\par 
\par {\*\bkmkstart _Toc291687448}{\listtext\pard\plain\s2 \b\f1\cgrid \hich\af1\dbch\af0\loch\f1 4.2.\tab}}\pard\plain \s2\qj\fi-360\li360\sb120\nowidctlpar\widctlpar\ls1\ilvl1\outlinelevel1\adjustright \b\f1\cgrid {Auto-generation scheme{\*\bkmkend _Toc291687448}
\par }\pard\plain \qj\nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {The (alias) 8.3 name is auto-generated for a file name, if necessary.  No assumption should be made about the auto-generation scheme itself.  This auto-generation scheme could change  between different revisions of the operating system.
\par 
\par {\*\bkmkstart _Toc287753075}{\*\bkmkstart _Toc287900671}{\*\bkmkstart _Toc288048234}{\*\bkmkstart _Toc288498099}{\*\bkmkstart _Toc291078310}{\*\bkmkstart _Toc291078663}{\*\bkmkstart _Toc291687449}{\listtext\pard\plain\s2 \b\f1\cgrid \hich\af1\dbch\af0\loch\f1 4.3.\tab}}\pard\plain \s2\qj\fi-360\li360\sb120\nowidctlpar\widctlpar\ls1\ilvl1\outlinelevel1\adjustright \b\f1\cgrid {32-bit Apps on Windows{\*\bkmkend _Toc287753075}{\*\bkmkend _Toc287900671}{\*\bkmkend _Toc288048234}{\*\bkmkend _Toc288498099}{\*\bkmkend _Toc291078310}{\*\bkmkend _Toc291078663}{\*\bkmkend _Toc291687449}
\par }\pard\plain \qj\nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {Using the Win32 API is the preferred way of developing new applications.  The Win32 API allows portability of the application across multiple Windows systems.  Further more any of the idiosyncrasies of the underlying system or new features in the system, such as long file names, are taken care off by the Win32 API.  Lastly Win32 apps run in separate address spaces and are preemptible.
\par 
\par {\*\bkmkstart _Toc287753076}{\*\bkmkstart _Toc287900672}{\*\bkmkstart _Toc288048235}{\*\bkmkstart _Toc288498100}{\*\bkmkstart _Toc291078311}{\*\bkmkstart _Toc291078664}{\*\bkmkstart _Toc291687450}{\listtext\pard\plain\s2 \b\f1\cgrid \hich\af1\dbch\af0\loch\f1 4.4.\tab}}\pard\plain \s2\qj\fi-360\li360\sb120\nowidctlpar\widctlpar\ls1\ilvl1\outlinelevel1\adjustright \b\f1\cgrid {16-bit Apps on Chicago{\*\bkmkend _Toc287753076}{\*\bkmkend _Toc287900672}{\*\bkmkend _Toc288048235}{\*\bkmkend _Toc288498100}{\*\bkmkend _Toc291078311}{\*\bkmkend _Toc291078664}{\*\bkmkend _Toc291687450}
\par }\pard\plain \qj\nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {Most of the Win16 APIs that require the application to pass in a file name have been updated to support long file names being passed in.  These include LoadLibrary(), WinExec(), Profile APIs, _lopen() and _lcreate().  However APIs that return file names will return only 8.3 names to older versions of Windows apps for compatibility reasons.  OpenFile is an exception to these general statements about Win16 APIs.  The Win16 OpenFile API will only take an 8.3 format file name as its parameter and will return the fully enumerated path in 8.3 name format.
\par 
\par DOS applications generally use the INT 21 API.  The older INT 21 APIs have not changed.  All long file name INT 21 APIs have been introduced as INT 21, Function 71XX.  Any DOS application that is interested in using long file names will have to be revved to use the newer INT 21s.
\par 
\par The new INT 21H calls will be supported on all file systems, to the extent possible, on Chicago.  Some file systems might not support long file names.  Examples of such file systems include MSCDEX, Flash, real mode network redirectors etc.  In these cases the system will translate the newer INT 21 calls to the older INT 21 calls automatically, as long as the parameters are valid.  For example, in the FileOpen (INT 21, Func 716C) system call, the file name has to be a valid 8.3 name, for file systems that do not support long file names.  The file system will take care of the relevant translation to the older FileOpen (INT 21, Func 6C).  The GetVolumeInformation API gives information on the capabilities of the underlying file system that supports the volume in question.
\par 
\par }{\f17\fs24 \'2a}{ The OpenFile() support might change before ship.
\par 
\par {\*\bkmkstart _Toc287753077}{\*\bkmkstart _Toc287900673}{\*\bkmkstart _Toc288048236}{\*\bkmkstart _Toc288498101}{\*\bkmkstart _Toc291078312}{\*\bkmkstart _Toc291078665}{\*\bkmkstart _Toc291687451}{\listtext\pard\plain\s2 \b\f1\cgrid \hich\af1\dbch\af0\loch\f1 4.5.\tab}}\pard\plain \s2\qj\fi-360\li360\sb120\nowidctlpar\widctlpar\ls1\ilvl1\outlinelevel1\adjustright \b\f1\cgrid {16-bit Apps & Down Level Systems{\*\bkmkend _Toc287753077}{\*\bkmkend _Toc287900673}{\*\bkmkend _Toc288048236}{\*\bkmkend _Toc288498101}{\*\bkmkend _Toc291078312}{\*\bkmkend _Toc291078665}{\*\bkmkend _Toc291687451}
\par }\pard\plain \qj\nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {It might be necessary to develop a 16-bit application that works both on Windows releases that support long file names and on Windows or MS-DOS releases that do not support long file names.  The main code fragment of interest to deal with can be characterized as:
\par 
\par \tab STC\tab \tab \tab \tab \tab ; Set Carry for error flag
\par \tab <new INT 21H call, Func 71H>\tab \tab ; Perform the newer INT 21H equivalent
\par \tab JNC\tab SUCCESS\tab \tab \tab ; Call succeeded, continue processing
\par \tab CMP \tab AX, 7100H\tab \tab \tab ; See if the call is really not 
\par \tab \tab \tab \tab \tab \tab ; supported.  When the call is not
\par \tab \tab \tab \tab \tab \tab ; supported then:  AL is set to 0; 
\par \tab \tab \tab \tab \tab \tab ; AH & Carry are preserved. This is 
\par \tab \tab \tab \tab \tab \tab ; true even in down level MS-DOS versions.
\par \tab JNE\tab Call_Failed\tab \tab \tab ; The call is supported, but something 
\par \tab \tab \tab \tab \tab \tab ; about this call failed
\par \tab <old INT 21H call>\tab \tab \tab ; Perform the older INT 21 call
\par 
\par Invariably the newer INT 21H calls will succeed on newer releases of Windows.  
\par 
\par An alternative would be to use the GetVolumeInformation API as the trigger to figure out which version of the INT 21H call to use.  If the API succeeds, then use the newer INT 21H long file name calls (that are all sub-functions of Func 71H).  Otherwise use the older INT 21H calls.  As mentioned above, the GetVolumeInformation API will succeed on newer Windows releases even on file systems that do not support long file names or if the file system is in Windows 3.1 compatibility mode.  Please be sure to pass in a name that is valid for the logical volume you are operating on.  Even when calling the GetVolumeInformation API, please remember to use a code fragment such as the one above. There is no equivalent "old INT 21H call" for the GetVolumeInformation API.  It is important for you to Set the Carry flag on the newer calls, so that you can check the error return correctly on down level MS-DOS systems. The GetVolumeInformation API does not access the disk.
\par 
\par Note that Chicago\rquote s Single MS-DOS Application mode behaves like a down level MS-DOS system for the case of the newer INT 21, 71xx APIs.  In this case, the Single MS-DOS application mode returns AX=7100H, without affecting the carry flag passed into the API.  So the above code fragment needs to be used for apps that need to run in Chicago\rquote s Single MS-DOS application mode too.
\par 
\par {\*\bkmkstart _Toc287753078}{\*\bkmkstart _Toc287900674}{\*\bkmkstart _Toc288048237}{\*\bkmkstart _Toc288498102}{\*\bkmkstart _Toc291078313}{\*\bkmkstart _Toc291078666}{\*\bkmkstart _Toc291687452}{\listtext\pard\plain\s2 \b\f1\cgrid \hich\af1\dbch\af0\loch\f1 4.6.\tab}}\pard\plain \s2\qj\fi-360\li360\sb120\nowidctlpar\widctlpar\ls1\ilvl1\outlinelevel1\adjustright \b\f1\cgrid {Character sets: APIs & on-disk names{\*\bkmkend _Toc287753078}{\*\bkmkend _Toc287900674}{\*\bkmkend _Toc288048237}{\*\bkmkend _Toc288498102}{\*\bkmkend _Toc291078313}{\*\bkmkend _Toc291078666}{\*\bkmkend _Toc291687452}
\par }\pard\plain \qj\nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par {\*\bkmkstart _Toc287753079}{\*\bkmkstart _Toc287900675}{\*\bkmkstart _Toc288048238}{\*\bkmkstart _Toc288498103}{\*\bkmkstart _Toc291078314}{\*\bkmkstart _Toc291078667}{\*\bkmkstart _Toc291687453}{\listtext\pard\plain\s3 \i\f1\cgrid \hich\af1\dbch\af0\loch\f1 4.6.1.\tab}}\pard\plain \s3\qj\fi-360\li360\nowidctlpar\widctlpar\ls1\ilvl2\outlinelevel2\adjustright \i\f1\cgrid {16 bit file APIs{\*\bkmkend _Toc287753079}{\*\bkmkend _Toc287900675}{\*\bkmkend _Toc288048238}{\*\bkmkend _Toc288498103}{\*\bkmkend _Toc291078314}{\*\bkmkend _Toc291078667}{\*\bkmkend _Toc291687453}
\par }\pard\plain \qj\nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {All 16 bit }{\i file}{ APIs, namely new and old INT 21 file APIs and Win 16 file APIs, will still present the OEM character set to 16 bit apps.  Since this has not changed, the 16 bit apps will continue to deal with file APIs in the same manner from a character set point of view.  
\par 
\par {\*\bkmkstart _Toc287753080}{\*\bkmkstart _Toc287900676}{\*\bkmkstart _Toc288048239}{\*\bkmkstart _Toc288498104}{\*\bkmkstart _Toc291078315}{\*\bkmkstart _Toc291078668}{\*\bkmkstart _Toc291687454}{\listtext\pard\plain\s3 \i\f1\cgrid \hich\af1\dbch\af0\loch\f1 4.6.2.\tab}}\pard\plain \s3\qj\fi-360\li360\nowidctlpar\widctlpar\ls1\ilvl2\outlinelevel2\adjustright \i\f1\cgrid {32 bit file APIs{\*\bkmkend _Toc287753080}{\*\bkmkend _Toc287900676}{\*\bkmkend _Toc288048239}{\*\bkmkend _Toc288498104}{\*\bkmkend _Toc291078315}{\*\bkmkend _Toc291078668}{\*\bkmkend _Toc291687454}
\par }\pard\plain \qj\nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {The Win32 API supports both the ANSI and Unicode form of the API.  In Windows NT, both of these API forms are supported.  In Chicago, only the ANSI form of  the Win32 API is supported.  Hence Win32 apps using the file system APIs need to pass characters in the ANSI code page under Chicago.  The Win32 }{\i SetFileApisToOEM}{ API will }{\i not}{ be supported in Chicago.
\par 
\par {\*\bkmkstart _Toc287753081}{\*\bkmkstart _Toc287900677}{\*\bkmkstart _Toc288048240}{\*\bkmkstart _Toc288498105}{\*\bkmkstart _Toc291078316}{\*\bkmkstart _Toc291078669}{\*\bkmkstart _Toc291687455}{\listtext\pard\plain\s3 \i\f1\cgrid \hich\af1\dbch\af0\loch\f1 4.6.3.\tab}}\pard\plain \s3\qj\fi-360\li360\nowidctlpar\widctlpar\ls1\ilvl2\outlinelevel2\adjustright \i\f1\cgrid {On-Disk names{\*\bkmkend _Toc287753081}{\*\bkmkend _Toc287900677}{\*\bkmkend _Toc288048240}{\*\bkmkend _Toc288498105}{\*\bkmkend _Toc291078316}{\*\bkmkend _Toc291078669}{\*\bkmkend _Toc291687455}
\par }\pard\plain \qj\nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {Any application using the regular file system APIs, need not worry about the character set of the names on the disk.  The APIs do the right translation on behalf of the application.  However disk utilities that directly read the disk will have to contend with the character set on the disk.  The alias (8.3 names) are stored using characters from the OEM code page for compatibility reasons.  The (long) file names are stored in Unicode on the disk.
\par 
\par {\*\bkmkstart _Toc287753082}{\*\bkmkstart _Toc287900678}{\*\bkmkstart _Toc288048241}{\*\bkmkstart _Toc288498106}{\*\bkmkstart _Toc291078317}{\*\bkmkstart _Toc291078670}{\*\bkmkstart _Toc291687456}{\listtext\pard\plain\s2 \b\f1\cgrid \hich\af1\dbch\af0\loch\f1 4.7.\tab}}\pard\plain \s2\qj\fi-360\li360\sb120\nowidctlpar\widctlpar\ls1\ilvl1\outlinelevel1\adjustright \b\f1\cgrid {CreateProcess, WinExec & $exec functions and LFNs{\*\bkmkend _Toc287753082}{\*\bkmkend _Toc287900678}{\*\bkmkend _Toc288048241}{\*\bkmkend _Toc288498106}{\*\bkmkend _Toc291078317}{\*\bkmkend _Toc291078670}{\*\bkmkend _Toc291687456}
\par }\pard\plain \qj\nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {The Win32 CreateProcess & WinExec and the Win16 WinExec functions will all support long file name arguments. A DOS app using the $exec function (INT 21H, 4BH) will be restricted to the execution of 8.3 names for compatibility.  Any newer DOS app using the 16-bit $exec function (INT 21H, 4BH) and dealing with long file name executables, should translate the executable names to the equivalent 8.3 names using the Canonical API.  COMMAND.COM and the Shell VxD would support long file name execution by doing the necessary translations on behalf of the user.  
\par 
\par {\*\bkmkstart _Toc287753083}{\*\bkmkstart _Toc287900679}{\*\bkmkstart _Toc288048242}{\*\bkmkstart _Toc288498107}{\*\bkmkstart _Toc291078318}{\*\bkmkstart _Toc291078671}{\*\bkmkstart _Toc291687457}{\listtext\pard\plain\s2 \b\f1\cgrid \hich\af1\dbch\af0\loch\f1 4.8.\tab}}\pard\plain \s2\qj\fi-360\li360\sb120\nowidctlpar\widctlpar\ls1\ilvl1\outlinelevel1\adjustright \b\f1\cgrid {Canonical API{\*\bkmkend _Toc287753083}{\*\bkmkend _Toc287900679}{\*\bkmkend _Toc288048242}{\*\bkmkend _Toc288498107}{\*\bkmkend _Toc291078318}{\*\bkmkend _Toc291078671}{\*\bkmkend _Toc291687457}
\par }\pard\plain \qj\nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {The Win32 GetFullPathName can be used to get a fully enumerated path name, where traversals such as "." and ".." are expanded.  A parallel 16-bit GetFullPathName function (INT 21H, 7160H, CX=0) will provide a similar facility for 16 bit apps.  In addition this 16 bit API will also expand SUBST-ed drives.  Another subfunction of this 16-bit API (INT 21H, 7160H, CX=1) will provide support for a GetShortPathName (16 bit only) API, which will allow an application to get a pure 8.3 name.  Setup applications need to use this API if they have to load files from CONFIG.SYS or AUTOEXEC.BAT.  Note that long file names are not present at boot up time and in Single MS-DOS application mode.
\par  
\par {\*\bkmkstart _Toc287753084}{\*\bkmkstart _Toc287900680}{\*\bkmkstart _Toc288048243}{\*\bkmkstart _Toc288498108}{\*\bkmkstart _Toc291078319}{\*\bkmkstart _Toc291078672}{\*\bkmkstart _Toc291687458}{\listtext\pard\plain\s2 \b\f1\cgrid \hich\af1\dbch\af0\loch\f1 4.9.\tab}}\pard\plain \s2\qj\fi-360\li360\sb120\nowidctlpar\widctlpar\ls1\ilvl1\outlinelevel1\adjustright \b\f1\cgrid {Exclusive Volume API (specific to Chicago){\*\bkmkend _Toc287753084}{\*\bkmkend _Toc287900680}{\*\bkmkend _Toc288048243}{\*\bkmkend _Toc288498108}{\*\bkmkend _Toc291078319}{\*\bkmkend _Toc291078672}{\*\bkmkend _Toc291687458}
\par }\pard\plain \qj\nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {New 16-bit volume locking IOCTLs (MS-DOS IOCTL: INT 21, Func 440D, Major Code 08, Minor Code 4A, 4B, 6A, 6B etc.) will be supported in the next release of Windows.  Any utility that needs exclusive volume access to perform direct disk writes (INT 26H or INT 13H), should use these 16 bit Exclusive Volume IOCTLs, before performing direct disk writes.  Please refer to the Exclusive Volume API specification for more information on the locking levels that are relevant to this API.  This API will be documented in the SDK.
\par 
\par A Win32 app can use the DeviceIoControl function to communicate with the VWIN32 VxD and perform drive letter based (INT 21, 44OD) IOCTLs.  The same mechanism can also be used to perform direct disk reads and writes (INT 25, INT 26 & INT 13) from a Win32 app.  These DeviceIoControls will }{\i not}{ be supported on Windows NT at this time.  Please refer to the documentation on DeviceIoControl in the SDK for more information.
\par 
\par }\pard \qj\fi-360\li360\nowidctlpar\widctlpar\adjustright {\f17\fs24 \'2a}{ }{\f17\fs24 \tab }{The above mentioned Win32 DeviceIoControls will }{\i not}{ be supported on Windows NT.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {
\par {\*\bkmkstart _Toc287753085}{\*\bkmkstart _Toc287900681}{\*\bkmkstart _Toc288048244}{\*\bkmkstart _Toc288498109}{\*\bkmkstart _Toc291078320}{\*\bkmkstart _Toc291078673}{\*\bkmkstart _Toc291687459}{\listtext\pard\plain\s2 \b\f1\cgrid \hich\af1\dbch\af0\loch\f1 4.10.\tab}}\pard\plain \s2\qj\fi-360\li360\sb120\nowidctlpar\widctlpar\ls1\ilvl1\outlinelevel1\adjustright \b\f1\cgrid {Keying off file names{\*\bkmkend _Toc287753085}{\*\bkmkend _Toc287900681}{\*\bkmkend _Toc288048244}{\*\bkmkend _Toc288498109}{\*\bkmkend _Toc291078320}{\*\bkmkend _Toc291078673}{\*\bkmkend _Toc291687459}
\par }\pard\plain \qj\nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {When an application keys off file names, it should be aware of the following:
\par }\pard \qj\fi-360\li360\nowidctlpar\widctlpar\adjustright {\field\flddirty{\*\fldinst {SYMBOL 183 \\f "Symbol" \\s 10 \\h}}{\fldrslt }}{\tab Using the alias (8.3 name) instead of the file name could break the association with the file because operations such as editing the file could potentially change the alias.  For example, consider the server side of the network which uses the file name to store information related to the file (like access permissions).  If the server side uses the alias (8.3 name) as opposed to the long name of the client file to store such information, it will be more susceptible to lose the association of permissions with the file.  If the user edits the file on the client side, the alias (8.3 name) could potentially change, and when it changes the server side will lose the associated information. 
\par }\pard \qj\fi-360\li360\nowidctlpar\widctlpar\adjustright {\field\flddirty{\*\fldinst {SYMBOL 183 \\f "Symbol" \\s 10 \\h}}{\fldrslt }}{\tab When an app caches the absolute path to the file name, the path itself could be a mixture of file names and aliases.  If there are }{\i n}{ such name components in the path, then there are possibly }{\i 2**n}{ such combinations.  Hence apps should store a canonical form of the absolute path, if the path needs to be stored at all.  The API provided to canonicalize the path should be used for this purpose.  The same is true for apps that use full path names to see if two files are the same.  Alternatively such apps can use the \ldblquote index\rdblquote  field in GetFileInfoByHandle to verify whether it is the same file.  The \ldblquote index\rdblquote  field of the GetFileInfoByHandle API might not be supported on real mode file systems, such as MSCDEX or real mode networks.
\par }{\field\flddirty{\*\fldinst {SYMBOL 183 \\f "Symbol" \\s 10 \\h}}{\fldrslt }}{\tab A setup program that needs to enter information into configuration files, such as CONFIG.SYS, should make sure it uses paths qualified with aliases (8.3 name components), since the long file names will not be visible at boot up time when files such as CONFIG.SYS and AUTOEXEC.BAT are processed.  The GetShortPathName API should be used for this purpose.
\par 
\par {\*\bkmkstart _Toc287753086}{\*\bkmkstart _Toc287900682}{\*\bkmkstart _Toc288048245}{\*\bkmkstart _Toc288498110}{\*\bkmkstart _Toc291078321}{\*\bkmkstart _Toc291078674}{\*\bkmkstart _Toc291687460}{\listtext\pard\plain\s2 \b\f1\cgrid \hich\af1\dbch\af0\loch\f1 4.11.\tab}}\pard\plain \s2\qj\fi-360\li360\sb120\nowidctlpar\widctlpar\ls1\ilvl1\outlinelevel1\adjustright \b\f1\cgrid {Checking Directory Entries{\*\bkmkend _Toc287753086}{\*\bkmkend _Toc287900682}{\*\bkmkend _Toc288048245}{\*\bkmkend _Toc288498110}{\*\bkmkend _Toc291078321}{\*\bkmkend _Toc291078674}{\*\bkmkend _Toc291687460}
\par }\pard\plain \qj\nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {A disk utility that is checking for directory entry coherence, should }{\i only}{ check the }{\i valid}{ entries.  Specifically reserved locations should either be }{\i not}{ checked against zero values or such checks should be combined with MS-DOS version checks.  Otherwise the utility will malfunction when the entries are extended by using the reserved locations.
\par 
\par Values in bit fields should be checked by masking the bits of interest and then comparing it against a desired value.  Direct comparisons against a value, without masking the bits of interest, will cause the utility to break if reserved bits in the field are used in future revs of the operating system.
\par 
\par {\*\bkmkstart _Toc287753087}{\*\bkmkstart _Toc287900683}{\*\bkmkstart _Toc288048246}{\*\bkmkstart _Toc288498111}{\*\bkmkstart _Toc291078322}{\*\bkmkstart _Toc291078675}{\*\bkmkstart _Toc291687461}{\listtext\pard\plain\s2 \b\f1\cgrid \hich\af1\dbch\af0\loch\f1 4.12.\tab}}\pard\plain \s2\qj\fi-360\li360\sb120\nowidctlpar\widctlpar\ls1\ilvl1\outlinelevel1\adjustright \b\f1\cgrid {Win32 & New INT 21 FindFirst/Next and FindClose{\*\bkmkend _Toc287753087}{\*\bkmkend _Toc287900683}{\*\bkmkend _Toc288048246}{\*\bkmkend _Toc288498111}{\*\bkmkend _Toc291078322}{\*\bkmkend _Toc291078675}{\*\bkmkend _Toc291687461}
\par }\pard\plain \qj\nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {The Win32 and new INT 21 FindFirst return a handle.  The user is expected to use this handle in subsequent FindNext calls.  It is necessary that an app return this handle to the system by calling }{\i FindClose}{, when the app no longer needs the handle.  This is different from the 16-bit old INT 21 FindFirst and FindNext calls.  The older 16 bit INT 21 equivalents of these APIs did not require such a close operation.
\par 
\par The new FindFirst/Next calls return time in Coordinated Universal Time (UTC or FileTime) defined by Windows NT.  Please see the Time APIs section in this document and other relevant API specification documents for more information.
\par 
\par File systems, such as HPFS, may support only one name space.  If there is only one name associated with the file, it is returned as the (primary) FileName in the FindFirst/Next structure irrespective of whether the only visible name is a long file name or an 8.3 name.  In this case, the AlternateFileName is NULL.  Applications should be coded to handle this case.  The same is true for a file that has a name in 8.3 format.
\par 
\par As noted above, multiple periods and leading periods are allowed in a (long) file name.  Consider some parsing code running on Chicago that ends up using the updated FindFirst and FindNext calls.  If this parsing code ignores all files that start with a }{\b .}{ character, with the intent of filtering out }{\b .}{ and }{\b ..}{ directories, it will end up ignoring file names such as }{\b .login}{.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {
\par {\*\bkmkstart _Toc287753088}{\*\bkmkstart _Toc287900684}{\*\bkmkstart _Toc288048247}{\*\bkmkstart _Toc288498112}{\*\bkmkstart _Toc291078323}{\*\bkmkstart _Toc291078676}{\*\bkmkstart _Toc291687462}{\listtext\pard\plain\s2 \b\f1\cgrid \hich\af1\dbch\af0\loch\f1 4.13.\tab}}\pard\plain \s2\qj\fi-360\li360\sb120\nowidctlpar\widctlpar\ls1\ilvl1\outlinelevel1\adjustright \b\f1\cgrid {Time APIs{\*\bkmkend _Toc287753088}{\*\bkmkend _Toc287900684}{\*\bkmkend _Toc288048247}{\*\bkmkend _Toc288498112}{\*\bkmkend _Toc291078323}{\*\bkmkend _Toc291078676}{\*\bkmkend _Toc291687462}
\par }\pard\plain \qj\nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {Coordinated Universal Time (UTC or FileTime) is supported across the network.  The FAT file system stamps local time in the directory entry for compatibility reasons.  At this point a bias is }{\i not}{ stamped to allow translation of this time across different time zones. The new Win32 FindFirst/Next APIs return time in UTC (or FileTime) format.  The equivalent 16 bit (INT 21, 714E and 714F) FindFirst/Next APIs return time either in DOS date/time format or in UTC (or FileTime) format, depending on a parameter passed in by the app, as part of the API.
\par 
\par FileTimeToDosDateTime and DosDateTimeToFileTime will be supported both as Win32 and 16-bit APIs.  Please use the relevant functions if you need to convert the FileTime returned by the new FindFirst/Next functions to MS-DOS date/time format.  The rest of the Time APIs will be supported only as Win32 APIs.
\par 
\par The FAT file system now sports Creation date/time and Last Access date, in addition to the existing Last Modified date/time.  The new Creation time for a file is a more precise time than the existing Last Modified time in the FAT file system. The Creation time includes the "number of ten milliseconds in the 2 second interval\rdblquote .  Hence the accuracy of the Creation time is ten milliseconds.  The new Last Access date/time is actually only a date.  There is no Last Access time.  Hence the proper assumption is that the Last Access time is always 0 (and that is what is returned in the Win32 APIs).
\par 
\par {\*\bkmkstart _Toc287753089}{\*\bkmkstart _Toc287900685}{\*\bkmkstart _Toc288048248}{\*\bkmkstart _Toc288498113}{\*\bkmkstart _Toc291078324}{\*\bkmkstart _Toc291078677}{\*\bkmkstart _Toc291687463}{\listtext\pard\plain\s2 \b\f1\cgrid \hich\af1\dbch\af0\loch\f1 4.14.\tab}}\pard\plain \s2\qj\fi-360\li360\sb120\nowidctlpar\widctlpar\ls1\ilvl1\outlinelevel1\adjustright \b\f1\cgrid {TSR and Apps that monitor INT 21 calls (INT 21 hookers{\*\bkmkend _Toc287753089}{\*\bkmkend _Toc287900685}){\*\bkmkend _Toc288048248}{\*\bkmkend _Toc288498113}{\*\bkmkend _Toc291078324}{\*\bkmkend _Toc291078677}{\*\bkmkend _Toc291687463}
\par }\pard\plain \qj\nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {On default all INT 21 interrupts, except file API INT 21s, are passed down to any hooker present in the system.  The file API INT 21s are just passed to VM (local) hookers, but not to global (AUTOEXEC.BAT) type hookers.  This is done because there are new file APIs (new INT 21s) that support long file names for delete, rename and so on that an older hooker won't understand anyway.   Further more not all file API calls are INT 21 calls.  Specifically server calls and swapper calls to the file system are not INT 21 calls.  
\par 
\par If the user forces the file system into }{\i Win 3.1 compatible mode}{, then none of the new features in the file system are turned on.  In the Win 3.1 compatible mode the file system will }{\i not}{ support long file names, last access date and creation date/time.  In this case all the INT 21s, including the file API INT 21s, are passed to any hooker (whether they are global or local).   Before a }{\i relevant}{ file API INT 21 is passed to a global or local hooker, the newer file API INT 21 is mapped to the equivalent older file API INT 21.  For name based new file API INT 21s, the name has to be 8.3 format conformant. If the name is not 8.3 format conformant the newer name or path based file API INT 21 call is failed.  
\par 
\par Good citizens of Chicago will use the FileHook API to monitor file activity.  This entails writing a Ring 0 VxD.  Doing this will avoid unnecessary Ring 3 transitions which is a performance win and will allow the software to see all file I/O.  Please refer to the IFS Manager specification for information on the FileHook API.
\par 
\par As with Windows 3.1, software interrupts are first passed through the Ring 0 protect mode components (VxDs), then through the Ring 3 protect mode components and lastly through any relevant Virtual 8086 components (TSRs and the like).  If any of the earlier components consume the interrupt then the subsequent components do not see the interrupt.  This is very similar to the behavior seen by existing software interrupt hookers.
\par 
\par Any VxD that uses the FileHook API should use the FSD_Init_Order field defined in VMM.H.  This will ensure that this VxD loads in the right order.
\par 
\par {\*\bkmkstart _Toc287753090}{\*\bkmkstart _Toc287900686}{\*\bkmkstart _Toc288048249}{\*\bkmkstart _Toc288498114}{\*\bkmkstart _Toc291078325}{\*\bkmkstart _Toc291078678}{\*\bkmkstart _Toc291687464}{\listtext\pard\plain\s2 \b\f1\cgrid \hich\af1\dbch\af0\loch\f1 4.15.\tab}}\pard\plain \s2\qj\fi-360\li360\sb120\nowidctlpar\widctlpar\ls1\ilvl1\outlinelevel1\adjustright \b\f1\cgrid {File System "Compatibility" switch{\*\bkmkend _Toc287753090}{\*\bkmkend _Toc287900686}{\*\bkmkend _Toc288048249}{\*\bkmkend _Toc288498114}{\*\bkmkend _Toc291078325}{\*\bkmkend _Toc291078678}{\*\bkmkend _Toc291687464}
\par }\pard\plain \qj\nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {On default the file system in Chicago sports a whole set of new features in the file system.  The relevant ones here are long file names, last access date and creation date/time.  The user can force the file system into }{\i Win 3.1 compatible mode}{ through a check box in the System Folder of the Control Panel.  When the user sets the file system in this mode, the disk is purged of all long file names, last access date and creation date/time, thus ensuring that the disk structure is compatible with Win 3.1.  Long file names, last access date and creation date/time are not supported while the file system is in Win 3.1 compatible mode.  Further all INT 21s are passed down to any hookers, thus ensuring that the system in this compatible mode will support existing TSRs.  When the file system is in Win 3.1 compatible mode the registry is stamped with the following setting:
\par 
\par Key: HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\FileSystem
\par Win31FileSystem=1
\par 
\par On default Win31FileSystem=0.
\par 
\par Note that direct disk writes are still failed in Chicago, even if the file system is in Win 3.1 compatible mode.  This is needed to protect cached data in the file system.   A COMMAND.COM switch needs to be set to run older versions of utilities that perform direct disk writes.  These direct disk writes are }{\i not}{ failed in Single MS-DOS application mode, if the file system is in Win 3.1 compatible mode.
\par 
\par Lastly the Shell uses the Creation Date/time for link tracking purposes.  When the file system is in Win 3.1 compatibility mode, the shell link tracking won\rquote t function optimally.
\par 
\par }\pard \qj\fi-360\li360\nowidctlpar\widctlpar\adjustright {\f17\fs24 \'2a}{ }{\f17\fs24 \tab }{The Win31FileSystem key might become a volume based bitmap before ship.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {
\par {\*\bkmkstart _Toc287753091}{\*\bkmkstart _Toc287900687}{\*\bkmkstart _Toc288048250}{\*\bkmkstart _Toc288498115}{\*\bkmkstart _Toc291078326}{\*\bkmkstart _Toc291078679}{\*\bkmkstart _Toc291687465}{\listtext\pard\plain\s2 \b\f1\cgrid \hich\af1\dbch\af0\loch\f1 4.16.\tab}}\pard\plain \s2\qj\fi-360\li360\sb120\nowidctlpar\widctlpar\ls1\ilvl1\outlinelevel1\adjustright \b\f1\cgrid {"for" command in COMMAND.COM{\*\bkmkend _Toc287753091}{\*\bkmkend _Toc287900687}{\*\bkmkend _Toc288048250}{\*\bkmkend _Toc288498115}{\*\bkmkend _Toc291078326}{\*\bkmkend _Toc291078679}{\*\bkmkend _Toc291687465}
\par }\pard\plain \qj\nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {The }{\b for}{ command in COMMAND.COM is modal.  The default will be }{\b LFNFOR=OFF}{. This will cause the }{\b for}{ command to use the old INT 21s.  This implies that only aliases (8.3 names) can be used in the }{\b for}{ command.  If }{\b LFNFOR=ON}{ is set, then the }{\b for}{ command uses the new INT 21s, and (long) file names can be used as part of the }{\b for}{ command.  The default was chosen for compatibility with existing batch files.
\par 
\par {\*\bkmkstart _Toc291078327}{\*\bkmkstart _Toc291078680}{\*\bkmkstart _Toc291687466}{\listtext\pard\plain\s2 \b\f1\cgrid \hich\af1\dbch\af0\loch\f1 4.17.\tab}}\pard\plain \s2\qj\fi-360\li360\sb120\nowidctlpar\widctlpar\ls1\ilvl1\outlinelevel1\adjustright \b\f1\cgrid {Down level system idiosyncrasies{\*\bkmkend _Toc291078327}{\*\bkmkend _Toc291078680}{\*\bkmkend _Toc291687466}
\par }\pard\plain \qj\nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {The source of a copy can be from a file system that supports long file names, while the target of the copy can be to a file system that supports only the old 8.3 name.  An application that supports a \ldblquote copy\rdblquote  type feature has to make a conscious choice about the semantics of the copy command in this case.  For example consider a copy of the form:
\par 
\par }{\b \tab copy c:ThisIsALongFileName d:
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {\b 
\par }{One possibility is to emulate COMMAND.COM copy semantics.  In this case, COMMAND.COM uses the alias (8.3) name of the source as the primary name for the target.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {
\par Single MS-DOS application mode behaves like a down level MS-DOS system for all APIs, except for direct disk writes (INT 26H).  Direct disk writes are failed in Single MS-DOS application mode unless the application takes an exclusive volume lock (see above).
\par 
\par {\*\bkmkstart _Toc291078328}{\*\bkmkstart _Toc291078681}{\*\bkmkstart _Toc291687467}{\listtext\pard\plain\s2 \b\f1\cgrid \hich\af1\dbch\af0\loch\f1 4.18.\tab}}\pard\plain \s2\qj\fi-360\li360\sb120\nowidctlpar\widctlpar\ls1\ilvl1\outlinelevel1\adjustright \b\f1\cgrid {Long command lines{\*\bkmkend _Toc291078328}{\*\bkmkend _Toc291078681}{\*\bkmkend _Toc291687467}
\par }\pard\plain \qj\nowidctlpar\widctlpar\adjustright \fs20\cgrid {
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {COMMAND.COM now sports a 1024 character limit for environment variables and batch file lines.    This is the default in Chicago, which can be overridden by the user.  However the keyboard buffer is still limited to 128 characters on default.  This can also be overridden by the user.
\par 
\par Command lines passed to Windows applications (both Win32 and Win16 applications) had no inherent limit.  If these applications are invoked from the MS-DOS box, which is also the Win32 console, through batch files or through environment variables that expand to command lines longer than 128 characters, the applications will still see and be able to work with these long command lines without revving.
\par 
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {However MS-DOS applications will have to rev to see the longer command lines.  MS-DOS applications invariably pick up the command line from the PSP.  The command tail in the PSP is limited to 128 characters, including the leading length field and the trailing Carriage Return.  If a command tail passed to a DOS program is less than 126 actual characters, the command tail is still set in the PSP as before.  This is done for the sake of compatibility.  If a command tail passed to a DOS program is greater than 126 actual characters, then the entire command line is actually set in the environment variable }{\b CMDLINE}{.  The PSP itself will just contain a Carriage Return, which is a null command tail.   Note that language vendors that provide compiler run time routines have to update their MS-DOS tools to pick up the command line from the correct location.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {
\par }\pard \qj\fi-360\li360\nowidctlpar\widctlpar\adjustright {\f17\fs24 \'2a}{ }{\f17\fs24 \tab }{With the current scheme, users of INT 21, 4B ($exec call) will have to set the CMDLINE environment variable appropriately.  This will mostly be DOS apps.  Win16 and Win32 apps will be taken care of by the appropriate APIs.  This onus on INT 21, 4B will almost definitely change before ship time.  Either an API will be provided to get a command line or the INT 21, 4B call will be enhanced and/or an INT 21, 714B call will be added that will handle long command lines.  So any users of INT 21, 4B should watch for the final solution and use that.
\par }\pard \qj\nowidctlpar\widctlpar\adjustright {
\par }}